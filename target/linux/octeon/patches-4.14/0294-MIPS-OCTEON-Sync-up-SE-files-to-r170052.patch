From 98bad2dbd1f408b5601abfd0baf2643223ad47b6 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Wed, 8 May 2019 14:19:35 +0200
Subject: [PATCH 294/345] MIPS:OCTEON: Sync-up SE files to -r170052

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
---
 .../executive/cvmx-error-trees.c              | 15548 ++++++++--------
 arch/mips/cavium-octeon/executive/cvmx-pcie.c |    21 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c |    23 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c  |    20 +-
 arch/mips/include/asm/octeon/cvmx-agl-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-asxx-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-bch-defs.h  |     4 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h |   161 +-
 arch/mips/include/asm/octeon/cvmx-bootmem.h   |    20 +-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h  |    14 +-
 arch/mips/include/asm/octeon/cvmx-ciu2-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-dbg-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h  |    26 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h  |  1046 +-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-gmxx-defs.h |    10 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h |     2 +-
 .../mips/include/asm/octeon/cvmx-gserx-defs.h |   399 +-
 .../mips/include/asm/octeon/cvmx-helper-cfg.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-iob-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h |     8 +-
 arch/mips/include/asm/octeon/cvmx-iobp-defs.h |     8 +-
 arch/mips/include/asm/octeon/cvmx-ipd-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h  |   106 +-
 arch/mips/include/asm/octeon/cvmx-l2d-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-l2t-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-led-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h |   411 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h  |    65 +-
 arch/mips/include/asm/octeon/cvmx-ndf-defs.h  |     6 +-
 arch/mips/include/asm/octeon/cvmx-npei-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-npi-defs.h  |     2 +-
 .../mips/include/asm/octeon/cvmx-oclax-defs.h |    20 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h  |   103 +-
 arch/mips/include/asm/octeon/cvmx-pci-defs.h  |     2 +-
 .../include/asm/octeon/cvmx-pcieepx-defs.h    |   127 +-
 .../include/asm/octeon/cvmx-pciercx-defs.h    |   134 +-
 arch/mips/include/asm/octeon/cvmx-pcsx-defs.h |     2 +-
 .../mips/include/asm/octeon/cvmx-pcsxx-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h |    15 +-
 .../mips/include/asm/octeon/cvmx-pescx-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-pip-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h  |    21 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h  |    45 +-
 arch/mips/include/asm/octeon/cvmx-pow-defs.h  |     2 +-
 arch/mips/include/asm/octeon/cvmx-rnm-defs.h  |     3 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h  |    24 +-
 arch/mips/include/asm/octeon/cvmx-sata-defs.h |    13 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h  |   105 +-
 arch/mips/include/asm/octeon/cvmx-smix-defs.h |     6 +-
 .../mips/include/asm/octeon/cvmx-spemx-defs.h |    13 +-
 arch/mips/include/asm/octeon/cvmx-spxx-defs.h |     2 +-
 .../include/asm/octeon/cvmx-sriomaintx-defs.h |     2 +-
 .../mips/include/asm/octeon/cvmx-sriox-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-srxx-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h  |    26 +-
 arch/mips/include/asm/octeon/cvmx-stxx-defs.h |     2 +-
 .../mips/include/asm/octeon/cvmx-usbcx-defs.h |     2 +-
 .../include/asm/octeon/cvmx-usbdrdx-defs.h    |    32 +-
 .../mips/include/asm/octeon/cvmx-usbnx-defs.h |     2 +-
 arch/mips/include/asm/octeon/cvmx-xcv-defs.h  |     6 +-
 61 files changed, 9560 insertions(+), 9083 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-error-trees.c b/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
index ea927f39f122..af8156df3d65 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
@@ -7,766 +7,766 @@ static struct cvmx_error_muxchild error_tree_cn68xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070100086000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_PKT(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 4 /* agx:4 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, "GMXX_RXX_INT_REG(0,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, "GMXX_RXX_INT_REG(0,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, "GMXX_RXX_INT_REG(0,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, "GMXX_RXX_INT_REG(0,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3072, "GMXX_RXX_INT_REG(0,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3072, "GMXX_RXX_INT_REG(0,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3072, "GMXX_RXX_INT_REG(0,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3072, "GMXX_RXX_INT_REG(0,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3072, "GMXX_RXX_INT_REG(0,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3072, "GMXX_RXX_INT_REG(0,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3072, "GMXX_RXX_INT_REG(0,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3072, "GMXX_RXX_INT_REG(0,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, 0, "GMXX_RXX_INT_REG(0,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, 0, "GMXX_RXX_INT_REG(0,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, 0, "GMXX_RXX_INT_REG(0,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, 0, "GMXX_RXX_INT_REG(0,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3072, 0, "GMXX_RXX_INT_REG(0,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3072, 0, "GMXX_RXX_INT_REG(0,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3072, 0, "GMXX_RXX_INT_REG(0,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3072, 0, "GMXX_RXX_INT_REG(0,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3072, 0, "GMXX_RXX_INT_REG(0,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3072, 0, "GMXX_RXX_INT_REG(0,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3072, 0, "GMXX_RXX_INT_REG(0,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3072, 0, "GMXX_RXX_INT_REG(0,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3088, "GMXX_RXX_INT_REG(1,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, "GMXX_RXX_INT_REG(1,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, "GMXX_RXX_INT_REG(1,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3088, "GMXX_RXX_INT_REG(1,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3088, "GMXX_RXX_INT_REG(1,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3088, "GMXX_RXX_INT_REG(1,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3088, "GMXX_RXX_INT_REG(1,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3088, "GMXX_RXX_INT_REG(1,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3088, "GMXX_RXX_INT_REG(1,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3088, "GMXX_RXX_INT_REG(1,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3088, "GMXX_RXX_INT_REG(1,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3088, "GMXX_RXX_INT_REG(1,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3088, 0, "GMXX_RXX_INT_REG(1,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, 0, "GMXX_RXX_INT_REG(1,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, 0, "GMXX_RXX_INT_REG(1,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3088, 0, "GMXX_RXX_INT_REG(1,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3088, 0, "GMXX_RXX_INT_REG(1,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3088, 0, "GMXX_RXX_INT_REG(1,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3088, 0, "GMXX_RXX_INT_REG(1,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3088, 0, "GMXX_RXX_INT_REG(1,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3088, 0, "GMXX_RXX_INT_REG(1,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3088, 0, "GMXX_RXX_INT_REG(1,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3088, 0, "GMXX_RXX_INT_REG(1,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3088, 0, "GMXX_RXX_INT_REG(1,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3104, "GMXX_RXX_INT_REG(2,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, "GMXX_RXX_INT_REG(2,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, "GMXX_RXX_INT_REG(2,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3104, "GMXX_RXX_INT_REG(2,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3104, "GMXX_RXX_INT_REG(2,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3104, "GMXX_RXX_INT_REG(2,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3104, "GMXX_RXX_INT_REG(2,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3104, "GMXX_RXX_INT_REG(2,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3104, "GMXX_RXX_INT_REG(2,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3104, "GMXX_RXX_INT_REG(2,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3104, "GMXX_RXX_INT_REG(2,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3104, "GMXX_RXX_INT_REG(2,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3104, 0, "GMXX_RXX_INT_REG(2,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, 0, "GMXX_RXX_INT_REG(2,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, 0, "GMXX_RXX_INT_REG(2,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3104, 0, "GMXX_RXX_INT_REG(2,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3104, 0, "GMXX_RXX_INT_REG(2,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3104, 0, "GMXX_RXX_INT_REG(2,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3104, 0, "GMXX_RXX_INT_REG(2,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3104, 0, "GMXX_RXX_INT_REG(2,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3104, 0, "GMXX_RXX_INT_REG(2,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3104, 0, "GMXX_RXX_INT_REG(2,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3104, 0, "GMXX_RXX_INT_REG(2,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3104, 0, "GMXX_RXX_INT_REG(2,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3120, "GMXX_RXX_INT_REG(3,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, "GMXX_RXX_INT_REG(3,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, "GMXX_RXX_INT_REG(3,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3120, "GMXX_RXX_INT_REG(3,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3120, "GMXX_RXX_INT_REG(3,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3120, "GMXX_RXX_INT_REG(3,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3120, "GMXX_RXX_INT_REG(3,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3120, "GMXX_RXX_INT_REG(3,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3120, "GMXX_RXX_INT_REG(3,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3120, "GMXX_RXX_INT_REG(3,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3120, "GMXX_RXX_INT_REG(3,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3120, "GMXX_RXX_INT_REG(3,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3120, 0, "GMXX_RXX_INT_REG(3,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, 0, "GMXX_RXX_INT_REG(3,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, 0, "GMXX_RXX_INT_REG(3,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3120, 0, "GMXX_RXX_INT_REG(3,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3120, 0, "GMXX_RXX_INT_REG(3,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3120, 0, "GMXX_RXX_INT_REG(3,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3120, 0, "GMXX_RXX_INT_REG(3,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3120, 0, "GMXX_RXX_INT_REG(3,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3120, 0, "GMXX_RXX_INT_REG(3,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3120, 0, "GMXX_RXX_INT_REG(3,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3120, 0, "GMXX_RXX_INT_REG(3,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3120, 0, "GMXX_RXX_INT_REG(3,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((4) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(4) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((4) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, "GMXX_TX_INT_REG(4)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, "GMXX_TX_INT_REG(4)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, "GMXX_TX_INT_REG(4)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, 0, "GMXX_TX_INT_REG(4)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, 0, "GMXX_TX_INT_REG(4)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, 0, "GMXX_TX_INT_REG(4)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, "PCSX_INTX_REG(0,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, "PCSX_INTX_REG(0,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, "PCSX_INTX_REG(0,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, "PCSX_INTX_REG(0,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3072, "PCSX_INTX_REG(0,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, "PCSX_INTX_REG(0,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3072, "PCSX_INTX_REG(0,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, "PCSX_INTX_REG(0,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3072, "PCSX_INTX_REG(0,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, 0, "PCSX_INTX_REG(0,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, 0, "PCSX_INTX_REG(0,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, 0, "PCSX_INTX_REG(0,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, 0, "PCSX_INTX_REG(0,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3072, 0, "PCSX_INTX_REG(0,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, 0, "PCSX_INTX_REG(0,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3072, 0, "PCSX_INTX_REG(0,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, 0, "PCSX_INTX_REG(0,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3072, 0, "PCSX_INTX_REG(0,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3088, "PCSX_INTX_REG(1,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3088, "PCSX_INTX_REG(1,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3088, "PCSX_INTX_REG(1,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3088, "PCSX_INTX_REG(1,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3088, "PCSX_INTX_REG(1,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, "PCSX_INTX_REG(1,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3088, "PCSX_INTX_REG(1,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, "PCSX_INTX_REG(1,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3088, "PCSX_INTX_REG(1,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3088, 0, "PCSX_INTX_REG(1,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3088, 0, "PCSX_INTX_REG(1,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3088, 0, "PCSX_INTX_REG(1,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3088, 0, "PCSX_INTX_REG(1,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3088, 0, "PCSX_INTX_REG(1,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, 0, "PCSX_INTX_REG(1,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3088, 0, "PCSX_INTX_REG(1,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, 0, "PCSX_INTX_REG(1,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3088, 0, "PCSX_INTX_REG(1,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3104, "PCSX_INTX_REG(2,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3104, "PCSX_INTX_REG(2,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3104, "PCSX_INTX_REG(2,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3104, "PCSX_INTX_REG(2,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3104, "PCSX_INTX_REG(2,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, "PCSX_INTX_REG(2,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3104, "PCSX_INTX_REG(2,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, "PCSX_INTX_REG(2,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3104, "PCSX_INTX_REG(2,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3104, 0, "PCSX_INTX_REG(2,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3104, 0, "PCSX_INTX_REG(2,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3104, 0, "PCSX_INTX_REG(2,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3104, 0, "PCSX_INTX_REG(2,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3104, 0, "PCSX_INTX_REG(2,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, 0, "PCSX_INTX_REG(2,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3104, 0, "PCSX_INTX_REG(2,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, 0, "PCSX_INTX_REG(2,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3104, 0, "PCSX_INTX_REG(2,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3120, "PCSX_INTX_REG(3,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3120, "PCSX_INTX_REG(3,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3120, "PCSX_INTX_REG(3,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3120, "PCSX_INTX_REG(3,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3120, "PCSX_INTX_REG(3,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, "PCSX_INTX_REG(3,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3120, "PCSX_INTX_REG(3,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, "PCSX_INTX_REG(3,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3120, "PCSX_INTX_REG(3,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3120, 0, "PCSX_INTX_REG(3,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3120, 0, "PCSX_INTX_REG(3,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3120, 0, "PCSX_INTX_REG(3,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3120, 0, "PCSX_INTX_REG(3,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3120, 0, "PCSX_INTX_REG(3,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, 0, "PCSX_INTX_REG(3,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3120, 0, "PCSX_INTX_REG(3,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, 0, "PCSX_INTX_REG(3,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3120, 0, "PCSX_INTX_REG(3,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((4) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(4) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((4) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, "PCSXX_INT_REG(4)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, "PCSXX_INT_REG(4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, "PCSXX_INT_REG(4)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, "PCSXX_INT_REG(4)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, "PCSXX_INT_REG(4)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, "PCSXX_INT_REG(4)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3072, "PCSXX_INT_REG(4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, 0, "PCSXX_INT_REG(4)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, 0, "PCSXX_INT_REG(4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, 0, "PCSXX_INT_REG(4)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, 0, "PCSXX_INT_REG(4)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, 0, "PCSXX_INT_REG(4)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, 0, "PCSXX_INT_REG(4)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3072, 0, "PCSXX_INT_REG(4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 3 /* agx:3 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, "GMXX_RXX_INT_REG(0,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, "GMXX_RXX_INT_REG(0,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, "GMXX_RXX_INT_REG(0,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, "GMXX_RXX_INT_REG(0,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2816, "GMXX_RXX_INT_REG(0,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2816, "GMXX_RXX_INT_REG(0,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2816, "GMXX_RXX_INT_REG(0,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2816, "GMXX_RXX_INT_REG(0,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2816, "GMXX_RXX_INT_REG(0,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2816, "GMXX_RXX_INT_REG(0,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2816, "GMXX_RXX_INT_REG(0,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2816, "GMXX_RXX_INT_REG(0,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, 0, "GMXX_RXX_INT_REG(0,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, 0, "GMXX_RXX_INT_REG(0,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, 0, "GMXX_RXX_INT_REG(0,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, 0, "GMXX_RXX_INT_REG(0,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2816, 0, "GMXX_RXX_INT_REG(0,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2816, 0, "GMXX_RXX_INT_REG(0,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2816, 0, "GMXX_RXX_INT_REG(0,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2816, 0, "GMXX_RXX_INT_REG(0,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2816, 0, "GMXX_RXX_INT_REG(0,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2816, 0, "GMXX_RXX_INT_REG(0,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2816, 0, "GMXX_RXX_INT_REG(0,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2816, 0, "GMXX_RXX_INT_REG(0,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2832, "GMXX_RXX_INT_REG(1,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, "GMXX_RXX_INT_REG(1,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, "GMXX_RXX_INT_REG(1,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2832, "GMXX_RXX_INT_REG(1,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2832, "GMXX_RXX_INT_REG(1,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2832, "GMXX_RXX_INT_REG(1,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2832, "GMXX_RXX_INT_REG(1,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2832, "GMXX_RXX_INT_REG(1,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2832, "GMXX_RXX_INT_REG(1,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2832, "GMXX_RXX_INT_REG(1,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2832, "GMXX_RXX_INT_REG(1,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2832, "GMXX_RXX_INT_REG(1,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2832, 0, "GMXX_RXX_INT_REG(1,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, 0, "GMXX_RXX_INT_REG(1,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, 0, "GMXX_RXX_INT_REG(1,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2832, 0, "GMXX_RXX_INT_REG(1,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2832, 0, "GMXX_RXX_INT_REG(1,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2832, 0, "GMXX_RXX_INT_REG(1,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2832, 0, "GMXX_RXX_INT_REG(1,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2832, 0, "GMXX_RXX_INT_REG(1,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2832, 0, "GMXX_RXX_INT_REG(1,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2832, 0, "GMXX_RXX_INT_REG(1,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2832, 0, "GMXX_RXX_INT_REG(1,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2832, 0, "GMXX_RXX_INT_REG(1,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2848, "GMXX_RXX_INT_REG(2,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, "GMXX_RXX_INT_REG(2,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, "GMXX_RXX_INT_REG(2,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2848, "GMXX_RXX_INT_REG(2,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2848, "GMXX_RXX_INT_REG(2,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2848, "GMXX_RXX_INT_REG(2,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2848, "GMXX_RXX_INT_REG(2,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2848, "GMXX_RXX_INT_REG(2,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2848, "GMXX_RXX_INT_REG(2,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2848, "GMXX_RXX_INT_REG(2,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2848, "GMXX_RXX_INT_REG(2,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2848, "GMXX_RXX_INT_REG(2,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2848, 0, "GMXX_RXX_INT_REG(2,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, 0, "GMXX_RXX_INT_REG(2,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, 0, "GMXX_RXX_INT_REG(2,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2848, 0, "GMXX_RXX_INT_REG(2,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2848, 0, "GMXX_RXX_INT_REG(2,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2848, 0, "GMXX_RXX_INT_REG(2,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2848, 0, "GMXX_RXX_INT_REG(2,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2848, 0, "GMXX_RXX_INT_REG(2,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2848, 0, "GMXX_RXX_INT_REG(2,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2848, 0, "GMXX_RXX_INT_REG(2,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2848, 0, "GMXX_RXX_INT_REG(2,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2848, 0, "GMXX_RXX_INT_REG(2,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2864, "GMXX_RXX_INT_REG(3,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2864, "GMXX_RXX_INT_REG(3,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2864, "GMXX_RXX_INT_REG(3,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2864, "GMXX_RXX_INT_REG(3,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2864, "GMXX_RXX_INT_REG(3,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2864, "GMXX_RXX_INT_REG(3,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2864, "GMXX_RXX_INT_REG(3,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2864, "GMXX_RXX_INT_REG(3,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2864, "GMXX_RXX_INT_REG(3,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2864, "GMXX_RXX_INT_REG(3,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2864, "GMXX_RXX_INT_REG(3,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2864, "GMXX_RXX_INT_REG(3,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2864, 0, "GMXX_RXX_INT_REG(3,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2864, 0, "GMXX_RXX_INT_REG(3,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2864, 0, "GMXX_RXX_INT_REG(3,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2864, 0, "GMXX_RXX_INT_REG(3,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2864, 0, "GMXX_RXX_INT_REG(3,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2864, 0, "GMXX_RXX_INT_REG(3,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2864, 0, "GMXX_RXX_INT_REG(3,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2864, 0, "GMXX_RXX_INT_REG(3,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2864, 0, "GMXX_RXX_INT_REG(3,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2864, 0, "GMXX_RXX_INT_REG(3,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2864, 0, "GMXX_RXX_INT_REG(3,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2864, 0, "GMXX_RXX_INT_REG(3,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((3) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(3) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((3) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, "GMXX_TX_INT_REG(3)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, "GMXX_TX_INT_REG(3)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, "GMXX_TX_INT_REG(3)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, 0, "GMXX_TX_INT_REG(3)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, 0, "GMXX_TX_INT_REG(3)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, 0, "GMXX_TX_INT_REG(3)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, "PCSX_INTX_REG(0,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, "PCSX_INTX_REG(0,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, "PCSX_INTX_REG(0,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, "PCSX_INTX_REG(0,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2816, "PCSX_INTX_REG(0,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, "PCSX_INTX_REG(0,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2816, "PCSX_INTX_REG(0,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, "PCSX_INTX_REG(0,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2816, "PCSX_INTX_REG(0,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, 0, "PCSX_INTX_REG(0,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, 0, "PCSX_INTX_REG(0,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, 0, "PCSX_INTX_REG(0,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, 0, "PCSX_INTX_REG(0,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2816, 0, "PCSX_INTX_REG(0,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, 0, "PCSX_INTX_REG(0,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2816, 0, "PCSX_INTX_REG(0,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, 0, "PCSX_INTX_REG(0,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2816, 0, "PCSX_INTX_REG(0,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2832, "PCSX_INTX_REG(1,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2832, "PCSX_INTX_REG(1,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2832, "PCSX_INTX_REG(1,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2832, "PCSX_INTX_REG(1,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2832, "PCSX_INTX_REG(1,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, "PCSX_INTX_REG(1,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2832, "PCSX_INTX_REG(1,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, "PCSX_INTX_REG(1,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2832, "PCSX_INTX_REG(1,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2832, 0, "PCSX_INTX_REG(1,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2832, 0, "PCSX_INTX_REG(1,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2832, 0, "PCSX_INTX_REG(1,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2832, 0, "PCSX_INTX_REG(1,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2832, 0, "PCSX_INTX_REG(1,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, 0, "PCSX_INTX_REG(1,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2832, 0, "PCSX_INTX_REG(1,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, 0, "PCSX_INTX_REG(1,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2832, 0, "PCSX_INTX_REG(1,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2848, "PCSX_INTX_REG(2,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2848, "PCSX_INTX_REG(2,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2848, "PCSX_INTX_REG(2,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2848, "PCSX_INTX_REG(2,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2848, "PCSX_INTX_REG(2,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, "PCSX_INTX_REG(2,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2848, "PCSX_INTX_REG(2,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, "PCSX_INTX_REG(2,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2848, "PCSX_INTX_REG(2,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2848, 0, "PCSX_INTX_REG(2,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2848, 0, "PCSX_INTX_REG(2,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2848, 0, "PCSX_INTX_REG(2,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2848, 0, "PCSX_INTX_REG(2,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2848, 0, "PCSX_INTX_REG(2,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, 0, "PCSX_INTX_REG(2,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2848, 0, "PCSX_INTX_REG(2,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, 0, "PCSX_INTX_REG(2,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2848, 0, "PCSX_INTX_REG(2,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2664, "PCSX_INTX_REG(3,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2664, "PCSX_INTX_REG(3,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2664, "PCSX_INTX_REG(3,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2664, "PCSX_INTX_REG(3,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2664, "PCSX_INTX_REG(3,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2664, "PCSX_INTX_REG(3,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2664, "PCSX_INTX_REG(3,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2664, "PCSX_INTX_REG(3,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2664, "PCSX_INTX_REG(3,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2664, 0, "PCSX_INTX_REG(3,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2664, 0, "PCSX_INTX_REG(3,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2664, 0, "PCSX_INTX_REG(3,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2664, 0, "PCSX_INTX_REG(3,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2664, 0, "PCSX_INTX_REG(3,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2664, 0, "PCSX_INTX_REG(3,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2664, 0, "PCSX_INTX_REG(3,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2664, 0, "PCSX_INTX_REG(3,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2664, 0, "PCSX_INTX_REG(3,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((3) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(3) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((3) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, "PCSXX_INT_REG(3)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, "PCSXX_INT_REG(3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, "PCSXX_INT_REG(3)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, "PCSXX_INT_REG(3)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, "PCSXX_INT_REG(3)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, "PCSXX_INT_REG(3)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2816, "PCSXX_INT_REG(3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, 0, "PCSXX_INT_REG(3)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, 0, "PCSXX_INT_REG(3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, 0, "PCSXX_INT_REG(3)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, 0, "PCSXX_INT_REG(3)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, 0, "PCSXX_INT_REG(3)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, 0, "PCSXX_INT_REG(3)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2816, 0, "PCSXX_INT_REG(3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 2 /* agx:2 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, "GMXX_RXX_INT_REG(0,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, "GMXX_RXX_INT_REG(0,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, "GMXX_RXX_INT_REG(0,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, "GMXX_RXX_INT_REG(0,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2560, "GMXX_RXX_INT_REG(0,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2560, "GMXX_RXX_INT_REG(0,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2560, "GMXX_RXX_INT_REG(0,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2560, "GMXX_RXX_INT_REG(0,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2560, "GMXX_RXX_INT_REG(0,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2560, "GMXX_RXX_INT_REG(0,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2560, "GMXX_RXX_INT_REG(0,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2560, "GMXX_RXX_INT_REG(0,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, 0, "GMXX_RXX_INT_REG(0,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, 0, "GMXX_RXX_INT_REG(0,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, 0, "GMXX_RXX_INT_REG(0,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, 0, "GMXX_RXX_INT_REG(0,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2560, 0, "GMXX_RXX_INT_REG(0,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2560, 0, "GMXX_RXX_INT_REG(0,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2560, 0, "GMXX_RXX_INT_REG(0,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2560, 0, "GMXX_RXX_INT_REG(0,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2560, 0, "GMXX_RXX_INT_REG(0,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2560, 0, "GMXX_RXX_INT_REG(0,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2560, 0, "GMXX_RXX_INT_REG(0,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2560, 0, "GMXX_RXX_INT_REG(0,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2576, "GMXX_RXX_INT_REG(1,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, "GMXX_RXX_INT_REG(1,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, "GMXX_RXX_INT_REG(1,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2576, "GMXX_RXX_INT_REG(1,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2576, "GMXX_RXX_INT_REG(1,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2576, "GMXX_RXX_INT_REG(1,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2576, "GMXX_RXX_INT_REG(1,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2576, "GMXX_RXX_INT_REG(1,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2576, "GMXX_RXX_INT_REG(1,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2576, "GMXX_RXX_INT_REG(1,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2576, "GMXX_RXX_INT_REG(1,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2576, "GMXX_RXX_INT_REG(1,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2576, 0, "GMXX_RXX_INT_REG(1,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, 0, "GMXX_RXX_INT_REG(1,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, 0, "GMXX_RXX_INT_REG(1,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2576, 0, "GMXX_RXX_INT_REG(1,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2576, 0, "GMXX_RXX_INT_REG(1,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2576, 0, "GMXX_RXX_INT_REG(1,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2576, 0, "GMXX_RXX_INT_REG(1,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2576, 0, "GMXX_RXX_INT_REG(1,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2576, 0, "GMXX_RXX_INT_REG(1,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2576, 0, "GMXX_RXX_INT_REG(1,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2576, 0, "GMXX_RXX_INT_REG(1,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2576, 0, "GMXX_RXX_INT_REG(1,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2592, "GMXX_RXX_INT_REG(2,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, "GMXX_RXX_INT_REG(2,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, "GMXX_RXX_INT_REG(2,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2592, "GMXX_RXX_INT_REG(2,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2592, "GMXX_RXX_INT_REG(2,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2592, "GMXX_RXX_INT_REG(2,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2592, "GMXX_RXX_INT_REG(2,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2592, "GMXX_RXX_INT_REG(2,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2592, "GMXX_RXX_INT_REG(2,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2592, "GMXX_RXX_INT_REG(2,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2592, "GMXX_RXX_INT_REG(2,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2592, "GMXX_RXX_INT_REG(2,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2592, 0, "GMXX_RXX_INT_REG(2,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, 0, "GMXX_RXX_INT_REG(2,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, 0, "GMXX_RXX_INT_REG(2,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2592, 0, "GMXX_RXX_INT_REG(2,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2592, 0, "GMXX_RXX_INT_REG(2,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2592, 0, "GMXX_RXX_INT_REG(2,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2592, 0, "GMXX_RXX_INT_REG(2,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2592, 0, "GMXX_RXX_INT_REG(2,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2592, 0, "GMXX_RXX_INT_REG(2,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2592, 0, "GMXX_RXX_INT_REG(2,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2592, 0, "GMXX_RXX_INT_REG(2,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2592, 0, "GMXX_RXX_INT_REG(2,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2608, "GMXX_RXX_INT_REG(3,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, "GMXX_RXX_INT_REG(3,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, "GMXX_RXX_INT_REG(3,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2608, "GMXX_RXX_INT_REG(3,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2608, "GMXX_RXX_INT_REG(3,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2608, "GMXX_RXX_INT_REG(3,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2608, "GMXX_RXX_INT_REG(3,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2608, "GMXX_RXX_INT_REG(3,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2608, "GMXX_RXX_INT_REG(3,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2608, "GMXX_RXX_INT_REG(3,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2608, "GMXX_RXX_INT_REG(3,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2608, "GMXX_RXX_INT_REG(3,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2608, 0, "GMXX_RXX_INT_REG(3,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, 0, "GMXX_RXX_INT_REG(3,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, 0, "GMXX_RXX_INT_REG(3,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2608, 0, "GMXX_RXX_INT_REG(3,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2608, 0, "GMXX_RXX_INT_REG(3,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2608, 0, "GMXX_RXX_INT_REG(3,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2608, 0, "GMXX_RXX_INT_REG(3,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2608, 0, "GMXX_RXX_INT_REG(3,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2608, 0, "GMXX_RXX_INT_REG(3,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2608, 0, "GMXX_RXX_INT_REG(3,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2608, 0, "GMXX_RXX_INT_REG(3,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2608, 0, "GMXX_RXX_INT_REG(3,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((2) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(2) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((2) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, "GMXX_TX_INT_REG(2)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, "GMXX_TX_INT_REG(2)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, "GMXX_TX_INT_REG(2)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, 0, "GMXX_TX_INT_REG(2)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, 0, "GMXX_TX_INT_REG(2)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, 0, "GMXX_TX_INT_REG(2)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, "PCSX_INTX_REG(0,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, "PCSX_INTX_REG(0,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, "PCSX_INTX_REG(0,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, "PCSX_INTX_REG(0,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2560, "PCSX_INTX_REG(0,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, "PCSX_INTX_REG(0,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2560, "PCSX_INTX_REG(0,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, "PCSX_INTX_REG(0,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2560, "PCSX_INTX_REG(0,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, 0, "PCSX_INTX_REG(0,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, 0, "PCSX_INTX_REG(0,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, 0, "PCSX_INTX_REG(0,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, 0, "PCSX_INTX_REG(0,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2560, 0, "PCSX_INTX_REG(0,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, 0, "PCSX_INTX_REG(0,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2560, 0, "PCSX_INTX_REG(0,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, 0, "PCSX_INTX_REG(0,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2560, 0, "PCSX_INTX_REG(0,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2576, "PCSX_INTX_REG(1,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2576, "PCSX_INTX_REG(1,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2576, "PCSX_INTX_REG(1,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2576, "PCSX_INTX_REG(1,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2576, "PCSX_INTX_REG(1,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, "PCSX_INTX_REG(1,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2576, "PCSX_INTX_REG(1,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, "PCSX_INTX_REG(1,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2576, "PCSX_INTX_REG(1,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2576, 0, "PCSX_INTX_REG(1,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2576, 0, "PCSX_INTX_REG(1,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2576, 0, "PCSX_INTX_REG(1,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2576, 0, "PCSX_INTX_REG(1,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2576, 0, "PCSX_INTX_REG(1,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, 0, "PCSX_INTX_REG(1,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2576, 0, "PCSX_INTX_REG(1,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, 0, "PCSX_INTX_REG(1,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2576, 0, "PCSX_INTX_REG(1,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2592, "PCSX_INTX_REG(2,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2592, "PCSX_INTX_REG(2,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2592, "PCSX_INTX_REG(2,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2592, "PCSX_INTX_REG(2,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2592, "PCSX_INTX_REG(2,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, "PCSX_INTX_REG(2,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2592, "PCSX_INTX_REG(2,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, "PCSX_INTX_REG(2,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2592, "PCSX_INTX_REG(2,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2592, 0, "PCSX_INTX_REG(2,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2592, 0, "PCSX_INTX_REG(2,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2592, 0, "PCSX_INTX_REG(2,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2592, 0, "PCSX_INTX_REG(2,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2592, 0, "PCSX_INTX_REG(2,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, 0, "PCSX_INTX_REG(2,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2592, 0, "PCSX_INTX_REG(2,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, 0, "PCSX_INTX_REG(2,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2592, 0, "PCSX_INTX_REG(2,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2608, "PCSX_INTX_REG(3,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2608, "PCSX_INTX_REG(3,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2608, "PCSX_INTX_REG(3,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2608, "PCSX_INTX_REG(3,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2608, "PCSX_INTX_REG(3,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, "PCSX_INTX_REG(3,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2608, "PCSX_INTX_REG(3,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, "PCSX_INTX_REG(3,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2608, "PCSX_INTX_REG(3,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2608, 0, "PCSX_INTX_REG(3,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2608, 0, "PCSX_INTX_REG(3,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2608, 0, "PCSX_INTX_REG(3,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2608, 0, "PCSX_INTX_REG(3,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2608, 0, "PCSX_INTX_REG(3,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, 0, "PCSX_INTX_REG(3,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2608, 0, "PCSX_INTX_REG(3,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, 0, "PCSX_INTX_REG(3,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2608, 0, "PCSX_INTX_REG(3,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((2) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(2) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((2) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, "PCSXX_INT_REG(2)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, "PCSXX_INT_REG(2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, "PCSXX_INT_REG(2)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, "PCSXX_INT_REG(2)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, "PCSXX_INT_REG(2)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, "PCSXX_INT_REG(2)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2560, "PCSXX_INT_REG(2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, 0, "PCSXX_INT_REG(2)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, 0, "PCSXX_INT_REG(2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, 0, "PCSXX_INT_REG(2)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, 0, "PCSXX_INT_REG(2)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, 0, "PCSXX_INT_REG(2)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, 0, "PCSXX_INT_REG(2)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2560, 0, "PCSXX_INT_REG(2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 1 /* agx:1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2368, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2368, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2368, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2368, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2368, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2368, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2368, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2368, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2368, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2368, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2368, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2368, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2368, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2368, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2368, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2368, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, "GMXX_TX_INT_REG(1)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, 0, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, "PCSX_INTX_REG(0,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2368, "PCSX_INTX_REG(0,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2368, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2368, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2368, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2368, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2368, 0, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, "PCSXX_INT_REG(1)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, "PCSXX_INT_REG(1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, "PCSXX_INT_REG(1)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, "PCSXX_INT_REG(1)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, "PCSXX_INT_REG(1)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2368, "PCSXX_INT_REG(1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, 0, "PCSXX_INT_REG(1)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, 0, "PCSXX_INT_REG(1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, 0, "PCSXX_INT_REG(1)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, 0, "PCSXX_INT_REG(1)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, 0, "PCSXX_INT_REG(1)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, 0, "PCSXX_INT_REG(1)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2368, 0, "PCSXX_INT_REG(1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 0 /* agx:0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2048, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2048, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2048, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2048, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2048, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2048, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2048, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2048, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2048, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2048, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2048, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2048, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2048, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2048, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2048, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2048, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2064, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2064, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2064, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2064, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2064, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2064, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2064, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2064, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2064, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2064, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2064, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2064, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2064, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2064, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2064, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2064, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2064, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2064, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2064, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2064, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2080, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2080, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2080, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2080, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2080, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2080, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2080, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2080, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2080, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2080, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2080, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2080, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2080, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2080, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2080, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2080, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2080, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2080, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2080, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2080, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2096, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2096, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2096, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2096, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2096, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2096, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2096, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2096, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2096, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2096, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2096, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2096, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2096, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2096, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2096, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2096, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2096, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2096, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2096, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2096, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2048, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2048, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2048, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2048, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2048, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2048, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2064, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2064, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2064, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2064, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2064, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2064, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2064, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2064, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2064, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2064, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2064, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2064, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2064, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2064, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2080, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2080, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2080, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2080, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2080, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2080, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2080, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2080, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2080, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2080, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2080, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2080, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2080, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2080, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2096, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2096, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2096, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2096, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2096, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2096, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2096, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2096, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2096, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2096, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2096, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2096, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2096, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2096, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2048, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2048, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* ilk */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180014000008ull) /* CVMX_ILK_GBL_INT */, CVMX_ADD_IO_SEG(0x0001180014000010ull) /* CVMX_ILK_GBL_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, "ILK_GBL_INT[RXF_LNK0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_GBL_INT[RXF_LNK1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, "ILK_GBL_INT[RXF_CTL_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, "ILK_GBL_INT[RXF_POP_EMPTY]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, "ILK_GBL_INT[RXF_PUSH_FULL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, 0, "ILK_GBL_INT[RXF_LNK0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_GBL_INT[RXF_LNK1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, 0, "ILK_GBL_INT[RXF_CTL_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, 0, "ILK_GBL_INT[RXF_POP_EMPTY]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, 0, "ILK_GBL_INT[RXF_PUSH_FULL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014010078ull) + ((0) & 1) * 16384 /* CVMX_ILK_TXX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180014010080ull) + ((0) & 1) * 16384 /* CVMX_ILK_TXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_TXX_INT(0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, "ILK_TXX_INT(0)[BAD_PIPE]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, "ILK_TXX_INT(0)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_TXX_INT(0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, 0, "ILK_TXX_INT(0)[BAD_PIPE]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, 0, "ILK_TXX_INT(0)[STAT_CNT_OVFL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014010078ull) + ((1) & 1) * 16384 /* CVMX_ILK_TXX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180014010080ull) + ((1) & 1) * 16384 /* CVMX_ILK_TXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, "ILK_TXX_INT(1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, "ILK_TXX_INT(1)[BAD_PIPE]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, "ILK_TXX_INT(1)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, 0, "ILK_TXX_INT(1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, 0, "ILK_TXX_INT(1)[BAD_PIPE]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, 0, "ILK_TXX_INT(1)[STAT_CNT_OVFL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014020010ull) + ((0) & 1) * 16384 /* CVMX_ILK_RXX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180014020018ull) + ((0) & 1) * 16384 /* CVMX_ILK_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_RXX_INT(0)[CRC24_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, "ILK_RXX_INT(0)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, "ILK_RXX_INT(0)[LANE_BAD_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, "ILK_RXX_INT(0)[PKT_DROP_RXF]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, "ILK_RXX_INT(0)[PKT_DROP_RID]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_RXX_INT(0)[CRC24_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, 0, "ILK_RXX_INT(0)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, 0, "ILK_RXX_INT(0)[LANE_BAD_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, 0, "ILK_RXX_INT(0)[PKT_DROP_RXF]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, 0, "ILK_RXX_INT(0)[PKT_DROP_RID]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014020010ull) + ((1) & 1) * 16384 /* CVMX_ILK_RXX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180014020018ull) + ((1) & 1) * 16384 /* CVMX_ILK_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, "ILK_RXX_INT(1)[CRC24_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, "ILK_RXX_INT(1)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, "ILK_RXX_INT(1)[LANE_BAD_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, "ILK_RXX_INT(1)[PKT_DROP_RXF]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, "ILK_RXX_INT(1)[PKT_DROP_RID]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, 0, "ILK_RXX_INT(1)[CRC24_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, 0, "ILK_RXX_INT(1)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, 0, "ILK_RXX_INT(1)[LANE_BAD_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, 0, "ILK_RXX_INT(1)[PKT_DROP_RXF]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, 0, "ILK_RXX_INT(1)[PKT_DROP_RID]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((0) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((0) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, "ILK_RX_LNEX_INT(0)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_RX_LNEX_INT(0)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, "ILK_RX_LNEX_INT(0)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, "ILK_RX_LNEX_INT(0)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, "ILK_RX_LNEX_INT(0)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, "ILK_RX_LNEX_INT(0)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, "ILK_RX_LNEX_INT(0)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, "ILK_RX_LNEX_INT(0)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 0, "ILK_RX_LNEX_INT(0)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, 0, "ILK_RX_LNEX_INT(0)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_RX_LNEX_INT(0)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, 0, "ILK_RX_LNEX_INT(0)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, 0, "ILK_RX_LNEX_INT(0)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, 0, "ILK_RX_LNEX_INT(0)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, 0, "ILK_RX_LNEX_INT(0)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, 0, "ILK_RX_LNEX_INT(0)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, 0, "ILK_RX_LNEX_INT(0)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 0, 0, "ILK_RX_LNEX_INT(0)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((1) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((1) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 1, "ILK_RX_LNEX_INT(1)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, "ILK_RX_LNEX_INT(1)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, "ILK_RX_LNEX_INT(1)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, "ILK_RX_LNEX_INT(1)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, "ILK_RX_LNEX_INT(1)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, "ILK_RX_LNEX_INT(1)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, "ILK_RX_LNEX_INT(1)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, "ILK_RX_LNEX_INT(1)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 1, "ILK_RX_LNEX_INT(1)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 1, 0, "ILK_RX_LNEX_INT(1)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, 0, "ILK_RX_LNEX_INT(1)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, 0, "ILK_RX_LNEX_INT(1)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, 0, "ILK_RX_LNEX_INT(1)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, 0, "ILK_RX_LNEX_INT(1)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, 0, "ILK_RX_LNEX_INT(1)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, 0, "ILK_RX_LNEX_INT(1)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, 0, "ILK_RX_LNEX_INT(1)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 1, 0, "ILK_RX_LNEX_INT(1)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((2) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(2) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((2) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 2, "ILK_RX_LNEX_INT(2)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 2, "ILK_RX_LNEX_INT(2)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 2, "ILK_RX_LNEX_INT(2)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 2, "ILK_RX_LNEX_INT(2)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 2, "ILK_RX_LNEX_INT(2)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 2, "ILK_RX_LNEX_INT(2)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 2, "ILK_RX_LNEX_INT(2)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 2, "ILK_RX_LNEX_INT(2)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 2, "ILK_RX_LNEX_INT(2)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 2, 0, "ILK_RX_LNEX_INT(2)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 2, 0, "ILK_RX_LNEX_INT(2)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 2, 0, "ILK_RX_LNEX_INT(2)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 2, 0, "ILK_RX_LNEX_INT(2)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 2, 0, "ILK_RX_LNEX_INT(2)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 2, 0, "ILK_RX_LNEX_INT(2)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 2, 0, "ILK_RX_LNEX_INT(2)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 2, 0, "ILK_RX_LNEX_INT(2)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 2, 0, "ILK_RX_LNEX_INT(2)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((3) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(3) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((3) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 3, "ILK_RX_LNEX_INT(3)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 3, "ILK_RX_LNEX_INT(3)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 3, "ILK_RX_LNEX_INT(3)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 3, "ILK_RX_LNEX_INT(3)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 3, "ILK_RX_LNEX_INT(3)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 3, "ILK_RX_LNEX_INT(3)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 3, "ILK_RX_LNEX_INT(3)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 3, "ILK_RX_LNEX_INT(3)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 3, "ILK_RX_LNEX_INT(3)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 3, 0, "ILK_RX_LNEX_INT(3)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 3, 0, "ILK_RX_LNEX_INT(3)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 3, 0, "ILK_RX_LNEX_INT(3)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 3, 0, "ILK_RX_LNEX_INT(3)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 3, 0, "ILK_RX_LNEX_INT(3)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 3, 0, "ILK_RX_LNEX_INT(3)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 3, 0, "ILK_RX_LNEX_INT(3)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 3, 0, "ILK_RX_LNEX_INT(3)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 3, 0, "ILK_RX_LNEX_INT(3)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((4) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(4) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((4) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 4, "ILK_RX_LNEX_INT(4)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 4, "ILK_RX_LNEX_INT(4)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 4, "ILK_RX_LNEX_INT(4)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 4, "ILK_RX_LNEX_INT(4)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 4, "ILK_RX_LNEX_INT(4)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 4, "ILK_RX_LNEX_INT(4)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 4, "ILK_RX_LNEX_INT(4)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 4, "ILK_RX_LNEX_INT(4)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 4, "ILK_RX_LNEX_INT(4)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 4, 0, "ILK_RX_LNEX_INT(4)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 4, 0, "ILK_RX_LNEX_INT(4)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 4, 0, "ILK_RX_LNEX_INT(4)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 4, 0, "ILK_RX_LNEX_INT(4)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 4, 0, "ILK_RX_LNEX_INT(4)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 4, 0, "ILK_RX_LNEX_INT(4)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 4, 0, "ILK_RX_LNEX_INT(4)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 4, 0, "ILK_RX_LNEX_INT(4)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 4, 0, "ILK_RX_LNEX_INT(4)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((5) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(5) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((5) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(5) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 5, "ILK_RX_LNEX_INT(5)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 5, "ILK_RX_LNEX_INT(5)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 5, "ILK_RX_LNEX_INT(5)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 5, "ILK_RX_LNEX_INT(5)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 5, "ILK_RX_LNEX_INT(5)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 5, "ILK_RX_LNEX_INT(5)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 5, "ILK_RX_LNEX_INT(5)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 5, "ILK_RX_LNEX_INT(5)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 5, "ILK_RX_LNEX_INT(5)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 5, 0, "ILK_RX_LNEX_INT(5)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 5, 0, "ILK_RX_LNEX_INT(5)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 5, 0, "ILK_RX_LNEX_INT(5)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 5, 0, "ILK_RX_LNEX_INT(5)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 5, 0, "ILK_RX_LNEX_INT(5)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 5, 0, "ILK_RX_LNEX_INT(5)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 5, 0, "ILK_RX_LNEX_INT(5)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 5, 0, "ILK_RX_LNEX_INT(5)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 5, 0, "ILK_RX_LNEX_INT(5)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((6) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(6) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((6) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(6) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 6, "ILK_RX_LNEX_INT(6)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 6, "ILK_RX_LNEX_INT(6)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 6, "ILK_RX_LNEX_INT(6)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 6, "ILK_RX_LNEX_INT(6)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 6, "ILK_RX_LNEX_INT(6)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 6, "ILK_RX_LNEX_INT(6)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 6, "ILK_RX_LNEX_INT(6)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 6, "ILK_RX_LNEX_INT(6)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 6, "ILK_RX_LNEX_INT(6)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 6, 0, "ILK_RX_LNEX_INT(6)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 6, 0, "ILK_RX_LNEX_INT(6)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 6, 0, "ILK_RX_LNEX_INT(6)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 6, 0, "ILK_RX_LNEX_INT(6)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 6, 0, "ILK_RX_LNEX_INT(6)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 6, 0, "ILK_RX_LNEX_INT(6)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 6, 0, "ILK_RX_LNEX_INT(6)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 6, 0, "ILK_RX_LNEX_INT(6)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 6, 0, "ILK_RX_LNEX_INT(6)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((7) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(7) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((7) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(7) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 7, "ILK_RX_LNEX_INT(7)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 7, "ILK_RX_LNEX_INT(7)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 7, "ILK_RX_LNEX_INT(7)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 7, "ILK_RX_LNEX_INT(7)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 7, "ILK_RX_LNEX_INT(7)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 7, "ILK_RX_LNEX_INT(7)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 7, "ILK_RX_LNEX_INT(7)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 7, "ILK_RX_LNEX_INT(7)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 7, "ILK_RX_LNEX_INT(7)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 7, 0, "ILK_RX_LNEX_INT(7)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 7, 0, "ILK_RX_LNEX_INT(7)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 7, 0, "ILK_RX_LNEX_INT(7)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 7, 0, "ILK_RX_LNEX_INT(7)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 7, 0, "ILK_RX_LNEX_INT(7)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 7, 0, "ILK_RX_LNEX_INT(7)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 7, 0, "ILK_RX_LNEX_INT(7)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 7, 0, "ILK_RX_LNEX_INT(7)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 7, 0, "ILK_RX_LNEX_INT(7)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -776,36 +776,36 @@ static struct cvmx_error_muxchild error_tree_cn68xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070100085000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_MEM(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 3 /* lmc:3 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((3) & 3) * 0x1000000ull /* CVMX_LMCX_INT(3) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((3) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 3, "LMCX_INT(3)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 3, "LMCX_INT(3)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 3, "LMCX_INT(3)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 3, CVMX_ERROR_TYPE_SBE, "LMCX_INT(3)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 3, 0, "LMCX_INT(3)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 3, CVMX_ERROR_TYPE_DBE, "LMCX_INT(3)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 2 /* lmc:2 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((2) & 3) * 0x1000000ull /* CVMX_LMCX_INT(2) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((2) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 2, "LMCX_INT(2)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 2, "LMCX_INT(2)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 2, "LMCX_INT(2)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 2, CVMX_ERROR_TYPE_SBE, "LMCX_INT(2)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 2, 0, "LMCX_INT(2)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 2, CVMX_ERROR_TYPE_DBE, "LMCX_INT(2)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 1 /* lmc:1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((1) & 3) * 0x1000000ull /* CVMX_LMCX_INT(1) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((1) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 1, "LMCX_INT(1)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 1, "LMCX_INT(1)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 1, "LMCX_INT(1)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 1, CVMX_ERROR_TYPE_SBE, "LMCX_INT(1)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 1, 0, "LMCX_INT(1)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 1, CVMX_ERROR_TYPE_DBE, "LMCX_INT(1)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 0 /* lmc:0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((0) & 3) * 0x1000000ull /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((0) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -815,132 +815,132 @@ static struct cvmx_error_muxchild error_tree_cn68xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070100082000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_RML(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 48 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_REG[BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_REG[BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_INT_REG[BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_REG[BIGRD]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 17 /* tad1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 1, "L2C_TADX_INT(1)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 1, "L2C_TADX_INT(1)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 1, "L2C_TADX_INT(1)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 1, "L2C_TADX_INT(1)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 1, "L2C_TADX_INT(1)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 1, "L2C_TADX_INT(1)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 1, "L2C_TADX_INT(1)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 1, "L2C_TADX_INT(1)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 1, "L2C_TADX_INT(1)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 1, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(1)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 1, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(1)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 1, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(1)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 1, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(1)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 1, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(1)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 1, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(1)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 1, 0, "L2C_TADX_INT(1)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 1, 0, "L2C_TADX_INT(1)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 1, 0, "L2C_TADX_INT(1)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 1, "L2C_ERR_TDTX(1)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, "L2C_ERR_TDTX(1)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, "L2C_ERR_TDTX(1)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, "L2C_ERR_TDTX(1)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 1, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(1)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(1)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(1)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(1)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, "L2C_ERR_TTGX(1)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, "L2C_ERR_TTGX(1)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, "L2C_ERR_TTGX(1)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, 0, "L2C_ERR_TTGX(1)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(1)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(1)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_TADX_INT(0)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_TADX_INT(0)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_TADX_INT(0)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_TADX_INT(0)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_TADX_INT(0)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_TADX_INT(0)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_TADX_INT(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_TADX_INT(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, "L2C_ERR_TDTX(0)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TDTX(0)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TDTX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TDTX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TTGX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TTGX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 19 /* tad3 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(3) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(3) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 3, "L2C_TADX_INT(3)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 3, "L2C_TADX_INT(3)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 3, "L2C_TADX_INT(3)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 3, "L2C_TADX_INT(3)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 3, "L2C_TADX_INT(3)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 3, "L2C_TADX_INT(3)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 3, "L2C_TADX_INT(3)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 3, "L2C_TADX_INT(3)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 3, "L2C_TADX_INT(3)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 3, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(3)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 3, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(3)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 3, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(3)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 3, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(3)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 3, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(3)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 3, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(3)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 3, 0, "L2C_TADX_INT(3)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 3, 0, "L2C_TADX_INT(3)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 3, 0, "L2C_TADX_INT(3)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(3) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 3, "L2C_ERR_TDTX(3)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, "L2C_ERR_TDTX(3)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, "L2C_ERR_TDTX(3)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, "L2C_ERR_TDTX(3)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 3, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(3)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(3)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(3)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(3)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(3) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, "L2C_ERR_TTGX(3)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, "L2C_ERR_TTGX(3)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, "L2C_ERR_TTGX(3)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, 0, "L2C_ERR_TTGX(3)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(3)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(3)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 18 /* tad2 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(2) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(2) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 2, "L2C_TADX_INT(2)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 2, "L2C_TADX_INT(2)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 2, "L2C_TADX_INT(2)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 2, "L2C_TADX_INT(2)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 2, "L2C_TADX_INT(2)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 2, "L2C_TADX_INT(2)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 2, "L2C_TADX_INT(2)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 2, "L2C_TADX_INT(2)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 2, "L2C_TADX_INT(2)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 2, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(2)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 2, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(2)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 2, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(2)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 2, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(2)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 2, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(2)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 2, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(2)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 2, 0, "L2C_TADX_INT(2)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 2, 0, "L2C_TADX_INT(2)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 2, 0, "L2C_TADX_INT(2)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(2) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 2, "L2C_ERR_TDTX(2)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, "L2C_ERR_TDTX(2)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, "L2C_ERR_TDTX(2)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, "L2C_ERR_TDTX(2)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 2, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(2)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(2)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(2)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(2)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(2) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, "L2C_ERR_TTGX(2)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, "L2C_ERR_TTGX(2)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, "L2C_ERR_TTGX(2)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, 0, "L2C_ERR_TTGX(2)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(2)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(2)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -950,250 +950,250 @@ static struct cvmx_error_muxchild error_tree_cn68xxp1 =
 					{0}}},
 				{1, 4 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 44, 0, "FPA_INT_SUM[FREE8]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, "FPA_INT_SUM[Q8_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, "FPA_INT_SUM[Q8_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, "FPA_INT_SUM[Q8_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "FPA_INT_SUM[POOL8TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 44, 0, 0, "FPA_INT_SUM[FREE8]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, 0, "FPA_INT_SUM[Q8_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, 0, "FPA_INT_SUM[Q8_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, 0, "FPA_INT_SUM[Q8_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "FPA_INT_SUM[POOL8TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 24 /* zip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180038000570ull) /* CVMX_ZIP_INT_REG */, CVMX_ADD_IO_SEG(0x0001180038000580ull) /* CVMX_ZIP_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "ZIP_INT_REG[IBSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "ZIP_INT_REG[IBDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "ZIP_INT_REG[DOORBELL0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "ZIP_INT_REG[DOORBELL1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "ZIP_INT_REG[IBSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "ZIP_INT_REG[IBDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "ZIP_INT_REG[DOORBELL0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "ZIP_INT_REG[DOORBELL1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 5 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "IPD_INT_SUM[SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "IPD_INT_SUM[EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "IPD_INT_SUM[DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "IPD_INT_SUM[PW0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "IPD_INT_SUM[PW0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "IPD_INT_SUM[PW1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "IPD_INT_SUM[PW1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "IPD_INT_SUM[PW2_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "IPD_INT_SUM[PW2_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "IPD_INT_SUM[PW3_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "IPD_INT_SUM[PW3_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "IPD_INT_SUM[SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "IPD_INT_SUM[EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "IPD_INT_SUM[DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW2_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW2_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW3_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW3_DBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 28 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000030ull) /* CVMX_TIM_INT0 */, CVMX_ADD_IO_SEG(0x0001180058000038ull) /* CVMX_TIM_INT0_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_INT0[INT0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_INT0[INT0]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180058000060ull) /* CVMX_TIM_INT_ECCERR */, CVMX_ADD_IO_SEG(0x0001180058000068ull) /* CVMX_TIM_INT_ECCERR_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_INT_ECCERR[SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "TIM_INT_ECCERR[DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "TIM_INT_ECCERR[SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "TIM_INT_ECCERR[DBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 16 /* sso */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000001038ull) /* CVMX_SSO_ERR */, CVMX_ADD_IO_SEG(0x0001670000001030ull) /* CVMX_SSO_ERR_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "SSO_ERR[IOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "SSO_ERR[FIDX_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "SSO_ERR[IDX_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "SSO_ERR[PND_DBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "SSO_ERR[OTH_SBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "SSO_ERR[OTH_DBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "SSO_ERR[OTH_SBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "SSO_ERR[OTH_DBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "SSO_ERR[PND_SBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "SSO_ERR[PND_DBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "SSO_ERR[PND_SBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, "SSO_ERR[FPE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, "SSO_ERR[AWE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, "SSO_ERR[BFP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "SSO_ERR[IDX_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "SSO_ERR[FIDX_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "SSO_ERR[IOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[FIDX_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[IDX_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[PND_DBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[OTH_SBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[OTH_DBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[OTH_SBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[OTH_DBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[PND_SBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[PND_DBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[PND_SBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, 0, "SSO_ERR[FPE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, 0, "SSO_ERR[AWE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, 0, "SSO_ERR[BFP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[IDX_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[FIDX_SBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 61, 0, "PEXP_SLI_INT_SUM[PIPE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 61, 0, 0, "PEXP_SLI_INT_SUM[PIPE_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 6 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 40 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "DFA_ERROR[DC1PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "DFA_ERROR[DC2PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "DFA_ERROR[DLC0_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERROR[DLC1_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DFA_ERROR[DFANXM]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DFA_ERROR[REPLERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "DFA_ERROR[DC1PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "DFA_ERROR[DC2PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "DFA_ERROR[DLC0_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "DFA_ERROR[DLC1_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DFA_ERROR[DFANXM]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DFA_ERROR[REPLERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 7 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PKO_REG_ERROR[LOOPBACK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PKO_REG_ERROR[LOOPBACK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -1203,50 +1203,50 @@ static struct cvmx_error_muxchild error_tree_cn68xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070100083000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_MIO(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 1 /* ssoiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000001048ull) /* CVMX_SSO_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000001050ull) /* CVMX_SSO_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "SSO_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "SSO_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 16 /* nand */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "NDF_INT[WDOG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "NDF_INT[SM_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "NDF_INT[ECC_1BIT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "NDF_INT[ECC_MULT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "NDF_INT[OVRF]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 17 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 40 /* usb_uctl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -1264,106 +1264,106 @@ static struct cvmx_error_muxchild error_tree_cn58xxp1 =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_INT_SUM[PO1_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_INT_SUM[PO2_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_INT_SUM[PO3_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_INT_SUM[I1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_INT_SUM[I2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_INT_SUM[I3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_INT_SUM[I1_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_INT_SUM[I2_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_INT_SUM[I3_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "NPI_INT_SUM[P1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "NPI_INT_SUM[P2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "NPI_INT_SUM[P3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "NPI_INT_SUM[P1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "NPI_INT_SUM[P2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "NPI_INT_SUM[P3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "NPI_INT_SUM[G1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "NPI_INT_SUM[G2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "NPI_INT_SUM[G3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "NPI_INT_SUM[P1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "NPI_INT_SUM[P2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "NPI_INT_SUM[P3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_INT_SUM[P1_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_INT_SUM[P2_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "NPI_INT_SUM[P3_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "NPI_INT_SUM[I1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "NPI_INT_SUM[I2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "NPI_INT_SUM[I3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "NPI_INT_SUM[FCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "NPI_INT_SUM[FCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "NPI_INT_SUM[PCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "NPI_INT_SUM[PCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, "NPI_INT_SUM[Q2_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, "NPI_INT_SUM[Q2_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, "NPI_INT_SUM[Q3_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, "NPI_INT_SUM[Q3_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, "NPI_INT_SUM[COM_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, "NPI_INT_SUM[COM_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, "NPI_INT_SUM[PNC_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "NPI_INT_SUM[PNC_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, "NPI_INT_SUM[RWX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "NPI_INT_SUM[RDX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, "NPI_INT_SUM[PCF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, "NPI_INT_SUM[PCF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, "NPI_INT_SUM[PDF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "NPI_INT_SUM[PDF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, "NPI_INT_SUM[Q1_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, "NPI_INT_SUM[Q1_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_INT_SUM[PO1_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_INT_SUM[PO2_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_INT_SUM[PO3_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_INT_SUM[I1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_INT_SUM[I2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_INT_SUM[I3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_INT_SUM[I1_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_INT_SUM[I2_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_INT_SUM[I3_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "NPI_INT_SUM[P1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "NPI_INT_SUM[P2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "NPI_INT_SUM[P3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "NPI_INT_SUM[P1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "NPI_INT_SUM[P2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "NPI_INT_SUM[P3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "NPI_INT_SUM[G1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "NPI_INT_SUM[G2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "NPI_INT_SUM[G3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "NPI_INT_SUM[P1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "NPI_INT_SUM[P2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "NPI_INT_SUM[P3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_INT_SUM[P1_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_INT_SUM[P2_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "NPI_INT_SUM[P3_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "NPI_INT_SUM[I1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "NPI_INT_SUM[I2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "NPI_INT_SUM[I3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "NPI_INT_SUM[FCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, 0, "NPI_INT_SUM[FCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, 0, "NPI_INT_SUM[PCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, 0, "NPI_INT_SUM[PCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, 0, "NPI_INT_SUM[Q2_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, 0, "NPI_INT_SUM[Q2_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, 0, "NPI_INT_SUM[Q3_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, 0, "NPI_INT_SUM[Q3_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, 0, "NPI_INT_SUM[COM_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, 0, "NPI_INT_SUM[COM_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, 0, "NPI_INT_SUM[PNC_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "NPI_INT_SUM[PNC_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, 0, "NPI_INT_SUM[RWX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "NPI_INT_SUM[RDX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, 0, "NPI_INT_SUM[PCF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, 0, "NPI_INT_SUM[PCF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, 0, "NPI_INT_SUM[PDF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "NPI_INT_SUM[PDF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, 0, "NPI_INT_SUM[Q1_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, 0, "NPI_INT_SUM[Q1_A_F]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -1373,346 +1373,346 @@ static struct cvmx_error_muxchild error_tree_cn58xxp1 =
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, 0, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, 0, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, 0, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 2 /* gmx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_BAD_REG(1)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_BAD_REG(1)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_BAD_REG(1)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_BAD_REG(1)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, 0, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, 0, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, 0, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 18 /* spx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "SPXX_INT_REG(0)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "SPXX_INT_REG(0)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "SPXX_INT_REG(0)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "SPXX_INT_REG(0)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "SPXX_INT_REG(0)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "SPXX_INT_REG(0)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "SPXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "SPXX_INT_REG(0)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, "SPXX_INT_REG(0)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "SPXX_INT_REG(0)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "SPXX_INT_REG(0)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "SPXX_INT_REG(0)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "SPXX_INT_REG(0)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "SPXX_INT_REG(0)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "SPXX_INT_REG(0)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "SPXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "SPXX_INT_REG(0)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, 0, "SPXX_INT_REG(0)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "STXX_INT_REG(0)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "STXX_INT_REG(0)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "STXX_INT_REG(0)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "STXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "STXX_INT_REG(0)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "STXX_INT_REG(0)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "STXX_INT_REG(0)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "STXX_INT_REG(0)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "STXX_INT_REG(0)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "STXX_INT_REG(0)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "STXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "STXX_INT_REG(0)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "STXX_INT_REG(0)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "STXX_INT_REG(0)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 19 /* spx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "SPXX_INT_REG(1)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "SPXX_INT_REG(1)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "SPXX_INT_REG(1)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "SPXX_INT_REG(1)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "SPXX_INT_REG(1)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "SPXX_INT_REG(1)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "SPXX_INT_REG(1)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "SPXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "SPXX_INT_REG(1)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, "SPXX_INT_REG(1)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "SPXX_INT_REG(1)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "SPXX_INT_REG(1)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "SPXX_INT_REG(1)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "SPXX_INT_REG(1)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "SPXX_INT_REG(1)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "SPXX_INT_REG(1)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "SPXX_INT_REG(1)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "SPXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "SPXX_INT_REG(1)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, 0, "SPXX_INT_REG(1)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "STXX_INT_REG(1)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "STXX_INT_REG(1)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "STXX_INT_REG(1)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "STXX_INT_REG(1)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "STXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "STXX_INT_REG(1)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "STXX_INT_REG(1)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "STXX_INT_REG(1)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "STXX_INT_REG(1)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "STXX_INT_REG(1)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "STXX_INT_REG(1)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "STXX_INT_REG(1)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "STXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "STXX_INT_REG(1)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "STXX_INT_REG(1)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "STXX_INT_REG(1)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 23 /* asx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "ASXX_INT_REG(1)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "ASXX_INT_REG(1)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "ASXX_INT_REG(1)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "ASXX_INT_REG(1)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "ASXX_INT_REG(1)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "ASXX_INT_REG(1)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 4 /* key */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 0) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 0) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 6 /* dfa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180030000028ull) /* CVMX_DFA_ERR */, 0, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERR[CP2SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "DFA_ERR[CP2DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERR[DTESBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "DFA_ERR[DTEDBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DFA_ERR[DTEPERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "DFA_ERR[CP2PERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "DFA_ERR[DBLOVF]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[CP2SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[CP2DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[DTESBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[DTEDBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DFA_ERR[DTEPERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "DFA_ERR[CP2PERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "DFA_ERR[DBLOVF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -1731,7 +1731,7 @@ static struct cvmx_error_muxchild error_tree_cn63xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -1741,27 +1741,27 @@ static struct cvmx_error_muxchild error_tree_cn63xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) /* CVMX_L2C_ERR_TDTX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, "L2C_ERR_TDTX(0)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TDTX(0)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TDTX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TDTX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) /* CVMX_L2C_ERR_TTGX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TTGX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TTGX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -1771,105 +1771,105 @@ static struct cvmx_error_muxchild error_tree_cn63xxp1 =
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -1879,50 +1879,50 @@ static struct cvmx_error_muxchild error_tree_cn63xxp1 =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -1932,409 +1932,409 @@ static struct cvmx_error_muxchild error_tree_cn63xxp1 =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* usb */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 19 /* nand */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "NDF_INT[WDOG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "NDF_INT[SM_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "NDF_INT[ECC_1BIT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "NDF_INT[ECC_MULT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "NDF_INT[OVRF]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 56 /* dfm */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800D4000408ull) /* CVMX_DFM_FNT_STAT */, CVMX_ADD_IO_SEG(0x00011800D4000410ull) /* CVMX_DFM_FNT_IENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_DFM, 0, 0, "DFM_FNT_STAT[SBE_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_DFM, 1, 0, "DFM_FNT_STAT[DBE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_DFM, 0, 0, CVMX_ERROR_TYPE_SBE, "DFM_FNT_STAT[SBE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_DFM, 1, 0, CVMX_ERROR_TYPE_DBE, "DFM_FNT_STAT[DBE_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 46 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, 0, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, 0, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 28 /* zip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 50 /* srio0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((0) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((0) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_ENABLE(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 0, "SRIOX_INT_REG(0)[BAR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 0, "SRIOX_INT_REG(0)[DENY_WR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 0, "SRIOX_INT_REG(0)[SLI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 0, "SRIOX_INT_REG(0)[MCE_RX]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 0, "SRIOX_INT_REG(0)[LOG_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 0, "SRIOX_INT_REG(0)[PHY_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 0, "SRIOX_INT_REG(0)[OMSG_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 0, "SRIOX_INT_REG(0)[PKO_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 0, "SRIOX_INT_REG(0)[RTRY_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 0, "SRIOX_INT_REG(0)[F_ERROR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 0, 0, "SRIOX_INT_REG(0)[BAR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 0, 0, "SRIOX_INT_REG(0)[DENY_WR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 0, 0, "SRIOX_INT_REG(0)[SLI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 0, 0, "SRIOX_INT_REG(0)[MCE_RX]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 0, 0, "SRIOX_INT_REG(0)[LOG_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 0, 0, "SRIOX_INT_REG(0)[PHY_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 0, 0, "SRIOX_INT_REG(0)[OMSG_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 0, 0, "SRIOX_INT_REG(0)[PKO_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 0, 0, "SRIOX_INT_REG(0)[RTRY_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 0, 0, "SRIOX_INT_REG(0)[F_ERROR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 51 /* srio1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((1) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((1) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_ENABLE(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 1, "SRIOX_INT_REG(1)[BAR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 1, "SRIOX_INT_REG(1)[DENY_WR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 1, "SRIOX_INT_REG(1)[SLI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 1, "SRIOX_INT_REG(1)[MCE_RX]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 1, "SRIOX_INT_REG(1)[LOG_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 1, "SRIOX_INT_REG(1)[PHY_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 1, "SRIOX_INT_REG(1)[OMSG_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 1, "SRIOX_INT_REG(1)[PKO_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 1, "SRIOX_INT_REG(1)[RTRY_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 1, "SRIOX_INT_REG(1)[F_ERROR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 1, 0, "SRIOX_INT_REG(1)[BAR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 1, 0, "SRIOX_INT_REG(1)[DENY_WR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 1, 0, "SRIOX_INT_REG(1)[SLI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 1, 0, "SRIOX_INT_REG(1)[MCE_RX]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 1, 0, "SRIOX_INT_REG(1)[LOG_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 1, 0, "SRIOX_INT_REG(1)[PHY_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 1, 0, "SRIOX_INT_REG(1)[OMSG_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 1, 0, "SRIOX_INT_REG(1)[PKO_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 1, 0, "SRIOX_INT_REG(1)[RTRY_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 1, 0, "SRIOX_INT_REG(1)[F_ERROR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -2352,79 +2352,79 @@ static struct cvmx_error_muxchild error_tree_cn30xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "NPI_INT_SUM[FCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "NPI_INT_SUM[FCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "NPI_INT_SUM[PCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "NPI_INT_SUM[PCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, "NPI_INT_SUM[Q2_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, "NPI_INT_SUM[Q2_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, "NPI_INT_SUM[Q3_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, "NPI_INT_SUM[Q3_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, "NPI_INT_SUM[COM_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, "NPI_INT_SUM[COM_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, "NPI_INT_SUM[PNC_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "NPI_INT_SUM[PNC_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, "NPI_INT_SUM[RWX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "NPI_INT_SUM[RDX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, "NPI_INT_SUM[PCF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, "NPI_INT_SUM[PCF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, "NPI_INT_SUM[PDF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "NPI_INT_SUM[PDF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, "NPI_INT_SUM[Q1_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, "NPI_INT_SUM[Q1_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "NPI_INT_SUM[FCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, 0, "NPI_INT_SUM[FCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, 0, "NPI_INT_SUM[PCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, 0, "NPI_INT_SUM[PCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, 0, "NPI_INT_SUM[Q2_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, 0, "NPI_INT_SUM[Q2_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, 0, "NPI_INT_SUM[Q3_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, 0, "NPI_INT_SUM[Q3_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, 0, "NPI_INT_SUM[COM_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, 0, "NPI_INT_SUM[COM_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, 0, "NPI_INT_SUM[PNC_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "NPI_INT_SUM[PNC_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, 0, "NPI_INT_SUM[RWX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "NPI_INT_SUM[RDX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, 0, "NPI_INT_SUM[PCF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, 0, "NPI_INT_SUM[PCF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, 0, "NPI_INT_SUM[PDF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "NPI_INT_SUM[PDF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, 0, "NPI_INT_SUM[Q1_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, 0, "NPI_INT_SUM[Q1_A_F]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -2434,210 +2434,210 @@ static struct cvmx_error_muxchild error_tree_cn30xx =
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((0) & 0) * 0x8000000ull /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((0) & 0) * 0x8000000ull /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, 0, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, 0, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 0) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 0) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((0) & 0) * 0x10000000ull /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((0) & 0) * 0x10000000ull /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 26, 0, "USBNX_INT_SUM(0)[N2U_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 27, 0, "USBNX_INT_SUM(0)[N2U_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 28, 0, "USBNX_INT_SUM(0)[U2N_D_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 29, 0, "USBNX_INT_SUM(0)[U2N_D_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 30, 0, "USBNX_INT_SUM(0)[U2N_C_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 31, 0, "USBNX_INT_SUM(0)[U2N_C_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 26, 0, 0, "USBNX_INT_SUM(0)[N2U_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 27, 0, 0, "USBNX_INT_SUM(0)[N2U_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 28, 0, 0, "USBNX_INT_SUM(0)[U2N_D_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 29, 0, 0, "USBNX_INT_SUM(0)[U2N_D_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 30, 0, 0, "USBNX_INT_SUM(0)[U2N_C_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 31, 0, 0, "USBNX_INT_SUM(0)[U2N_C_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -2658,88 +2658,88 @@ static struct cvmx_error_muxchild error_tree_cn50xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_INT_SUM[PO1_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_INT_SUM[I1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_INT_SUM[I1_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "NPI_INT_SUM[P1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "NPI_INT_SUM[P1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "NPI_INT_SUM[G1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "NPI_INT_SUM[P1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_INT_SUM[P1_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "NPI_INT_SUM[I1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "NPI_INT_SUM[FCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "NPI_INT_SUM[FCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "NPI_INT_SUM[PCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "NPI_INT_SUM[PCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, "NPI_INT_SUM[Q2_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, "NPI_INT_SUM[Q2_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, "NPI_INT_SUM[Q3_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, "NPI_INT_SUM[Q3_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, "NPI_INT_SUM[COM_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, "NPI_INT_SUM[COM_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, "NPI_INT_SUM[PNC_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "NPI_INT_SUM[PNC_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, "NPI_INT_SUM[RWX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "NPI_INT_SUM[RDX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, "NPI_INT_SUM[PCF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, "NPI_INT_SUM[PCF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, "NPI_INT_SUM[PDF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "NPI_INT_SUM[PDF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, "NPI_INT_SUM[Q1_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, "NPI_INT_SUM[Q1_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_INT_SUM[PO1_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_INT_SUM[I1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_INT_SUM[I1_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "NPI_INT_SUM[P1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "NPI_INT_SUM[P1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "NPI_INT_SUM[G1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "NPI_INT_SUM[P1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_INT_SUM[P1_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "NPI_INT_SUM[I1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "NPI_INT_SUM[FCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, 0, "NPI_INT_SUM[FCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, 0, "NPI_INT_SUM[PCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, 0, "NPI_INT_SUM[PCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, 0, "NPI_INT_SUM[Q2_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, 0, "NPI_INT_SUM[Q2_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, 0, "NPI_INT_SUM[Q3_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, 0, "NPI_INT_SUM[Q3_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, 0, "NPI_INT_SUM[COM_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, 0, "NPI_INT_SUM[COM_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, 0, "NPI_INT_SUM[PNC_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "NPI_INT_SUM[PNC_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, 0, "NPI_INT_SUM[RWX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "NPI_INT_SUM[RDX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, 0, "NPI_INT_SUM[PCF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, 0, "NPI_INT_SUM[PCF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, 0, "NPI_INT_SUM[PDF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "NPI_INT_SUM[PDF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, 0, "NPI_INT_SUM[Q1_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, 0, "NPI_INT_SUM[Q1_A_F]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -2749,206 +2749,206 @@ static struct cvmx_error_muxchild error_tree_cn50xx =
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((0) & 0) * 0x8000000ull /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((0) & 0) * 0x8000000ull /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -2969,373 +2969,373 @@ static struct cvmx_error_muxchild error_tree_cn56xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000008520ull) /* CVMX_PEXP_NPEI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800800000F8ull) /* CVMX_L2C_INT_STAT */, CVMX_ADD_IO_SEG(0x0001180080000100ull) /* CVMX_L2C_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_STAT[L2TSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_STAT[L2DSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_STAT[OOB1]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_STAT[OOB2]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_STAT[OOB3]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_STAT[L2TDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_STAT[L2DDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_STAT[LCK]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_INT_STAT[LCK2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2TSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2DSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_STAT[OOB1]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_STAT[OOB2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_STAT[OOB3]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2TDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2DDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_STAT[LCK]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_INT_STAT[LCK2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 28 /* agl */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 2 /* gmx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, 0, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, 0, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, 0, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, 0, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, 0, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, 0, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npei */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000008530ull) /* CVMX_PEXP_NPEI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F000000BCD0ull) /* CVMX_PEXP_NPEI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "PEXP_NPEI_INT_SUM[C0_LDWN]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEXP_NPEI_INT_SUM[CRS0_DR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEXP_NPEI_INT_SUM[CRS0_ER]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 1, "PEXP_NPEI_INT_SUM[C1_LDWN]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEXP_NPEI_INT_SUM[C1_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEXP_NPEI_INT_SUM[CRS1_DR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEXP_NPEI_INT_SUM[CRS1_ER]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_NPEI_INT_SUM[DMA4DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "PEXP_NPEI_INT_SUM[C0_LDWN]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEXP_NPEI_INT_SUM[CRS0_DR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEXP_NPEI_INT_SUM[CRS0_ER]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 1, 0, "PEXP_NPEI_INT_SUM[C1_LDWN]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEXP_NPEI_INT_SUM[C1_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEXP_NPEI_INT_SUM[CRS1_DR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEXP_NPEI_INT_SUM[CRS1_ER]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_NPEI_INT_SUM[DMA4DBO]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 57 /* c0_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PESCX_DBG_INFO(0)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PESCX_DBG_INFO(0)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PESCX_DBG_INFO(0)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PESCX_DBG_INFO(0)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PESCX_DBG_INFO(0)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PESCX_DBG_INFO(0)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PESCX_DBG_INFO(0)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PESCX_DBG_INFO(0)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PESCX_DBG_INFO(0)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PESCX_DBG_INFO(0)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PESCX_DBG_INFO(0)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PESCX_DBG_INFO(0)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PESCX_DBG_INFO(0)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PESCX_DBG_INFO(0)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PESCX_DBG_INFO(0)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PESCX_DBG_INFO(0)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PESCX_DBG_INFO(0)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PESCX_DBG_INFO(0)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PESCX_DBG_INFO(0)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PESCX_DBG_INFO(0)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PESCX_DBG_INFO(0)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PESCX_DBG_INFO(0)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PESCX_DBG_INFO(0)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PESCX_DBG_INFO(0)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
 									{0}}},
 								{1, 58 /* c1_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PESCX_DBG_INFO(1)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PESCX_DBG_INFO(1)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PESCX_DBG_INFO(1)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PESCX_DBG_INFO(1)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PESCX_DBG_INFO(1)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PESCX_DBG_INFO(1)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PESCX_DBG_INFO(1)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PESCX_DBG_INFO(1)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PESCX_DBG_INFO(1)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PESCX_DBG_INFO(1)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PESCX_DBG_INFO(1)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PESCX_DBG_INFO(1)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PESCX_DBG_INFO(1)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PESCX_DBG_INFO(1)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PESCX_DBG_INFO(1)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PESCX_DBG_INFO(1)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PESCX_DBG_INFO(1)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PESCX_DBG_INFO(1)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PESCX_DBG_INFO(1)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PESCX_DBG_INFO(1)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PESCX_DBG_INFO(1)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PESCX_DBG_INFO(1)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PESCX_DBG_INFO(1)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PESCX_DBG_INFO(1)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PESCX_DBG_INFO(1)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PESCX_DBG_INFO(1)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PESCX_DBG_INFO(1)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PESCX_DBG_INFO(1)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PESCX_DBG_INFO(1)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PESCX_DBG_INFO(1)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PESCX_DBG_INFO(1)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PESCX_DBG_INFO(1)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PESCX_DBG_INFO(1)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PESCX_DBG_INFO(1)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PESCX_DBG_INFO(1)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PESCX_DBG_INFO(1)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PESCX_DBG_INFO(1)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PESCX_DBG_INFO(1)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PESCX_DBG_INFO(1)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PESCX_DBG_INFO(1)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PESCX_DBG_INFO(1)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PESCX_DBG_INFO(1)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PESCX_DBG_INFO(1)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PESCX_DBG_INFO(1)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PESCX_DBG_INFO(1)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PESCX_DBG_INFO(1)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PESCX_DBG_INFO(1)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PESCX_DBG_INFO(1)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PESCX_DBG_INFO(1)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PESCX_DBG_INFO(1)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PESCX_DBG_INFO(1)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PESCX_DBG_INFO(1)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PESCX_DBG_INFO(1)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PESCX_DBG_INFO(1)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PESCX_DBG_INFO(1)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PESCX_DBG_INFO(1)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PESCX_DBG_INFO(1)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PESCX_DBG_INFO(1)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PESCX_DBG_INFO(1)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PESCX_DBG_INFO(1)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -3345,265 +3345,265 @@ static struct cvmx_error_muxchild error_tree_cn56xx =
 							{0}}},
 						{1, 14 /* rad */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 29 /* lmc1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((1) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(1) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((1) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(1) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 1, "LMCX_MEM_CFG0(1)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 1, "LMCX_MEM_CFG0(1)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 1, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(1)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 1, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(1)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 23 /* asxpcs1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSX_INTX_REG(0,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "PCSX_INTX_REG(0,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "PCSX_INTX_REG(1,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, "PCSX_INTX_REG(1,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, "PCSX_INTX_REG(1,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "PCSX_INTX_REG(1,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, "PCSX_INTX_REG(1,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "PCSX_INTX_REG(1,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "PCSX_INTX_REG(1,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "PCSX_INTX_REG(1,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "PCSX_INTX_REG(1,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, 0, "PCSX_INTX_REG(1,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "PCSX_INTX_REG(1,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "PCSX_INTX_REG(1,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "PCSX_INTX_REG(2,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, "PCSX_INTX_REG(2,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, "PCSX_INTX_REG(2,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "PCSX_INTX_REG(2,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, "PCSX_INTX_REG(2,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "PCSX_INTX_REG(2,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "PCSX_INTX_REG(2,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "PCSX_INTX_REG(2,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "PCSX_INTX_REG(2,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, 0, "PCSX_INTX_REG(2,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "PCSX_INTX_REG(2,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "PCSX_INTX_REG(2,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "PCSX_INTX_REG(3,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, "PCSX_INTX_REG(3,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, "PCSX_INTX_REG(3,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "PCSX_INTX_REG(3,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, "PCSX_INTX_REG(3,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "PCSX_INTX_REG(3,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "PCSX_INTX_REG(3,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "PCSX_INTX_REG(3,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "PCSX_INTX_REG(3,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, 0, "PCSX_INTX_REG(3,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "PCSX_INTX_REG(3,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "PCSX_INTX_REG(3,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "PCSXX_INT_REG(1)[TXFLT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "PCSXX_INT_REG(1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSXX_INT_REG(1)[BITLCKLS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSXX_INT_REG(1)[SYNLOS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSXX_INT_REG(1)[ALGNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "PCSXX_INT_REG(1)[TXFLT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "PCSXX_INT_REG(1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSXX_INT_REG(1)[RXSYNBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSXX_INT_REG(1)[BITLCKLS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSXX_INT_REG(1)[SYNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSXX_INT_REG(1)[ALGNLOS]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asxpcs0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 4 /* key */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((0) & 0) * 0x10000000ull /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((0) & 0) * 0x10000000ull /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -3622,7 +3622,7 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -3632,149 +3632,149 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000107000000E000ull) /* CVMX_CIU_CIB_L2C_RAWX(0) */, CVMX_ADD_IO_SEG(0x000107000000E100ull) /* CVMX_CIU_CIB_L2C_ENX(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_NOWAY]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 9, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 10, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 11, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 12, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGRD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 13, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_WRDISLMC]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 14, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RDDISLMC]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 15, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 16, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 17, 0, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 18, 0, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 19, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 20, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 21, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 22, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_NOWAY]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 9, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 10, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 11, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 12, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 13, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_WRDISLMC]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 14, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RDDISLMC]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 15, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 16, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 17, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 18, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 19, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 20, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 21, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 22, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDDBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 50 /* pem2 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_INT_SUM(2) */, CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_INT_ENB(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 2, "PEMX_INT_SUM(2)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, "PEMX_INT_SUM(2)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, "PEMX_INT_SUM(2)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, "PEMX_INT_SUM(2)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, "PEMX_INT_SUM(2)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, "PEMX_INT_SUM(2)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, "PEMX_INT_SUM(2)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, "PEMX_INT_SUM(2)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, "PEMX_INT_SUM(2)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, "PEMX_INT_SUM(2)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 2, 0, "PEMX_INT_SUM(2)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, 0, "PEMX_INT_SUM(2)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, 0, "PEMX_INT_SUM(2)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, 0, "PEMX_INT_SUM(2)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, 0, "PEMX_INT_SUM(2)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, 0, "PEMX_INT_SUM(2)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, 0, "PEMX_INT_SUM(2)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, 0, "PEMX_INT_SUM(2)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, 0, "PEMX_INT_SUM(2)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, 0, "PEMX_INT_SUM(2)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(2) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(2) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 2, "PEMX_DBG_INFO(2)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 2, "PEMX_DBG_INFO(2)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 2, "PEMX_DBG_INFO(2)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, "PEMX_DBG_INFO(2)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, "PEMX_DBG_INFO(2)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, "PEMX_DBG_INFO(2)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, "PEMX_DBG_INFO(2)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, "PEMX_DBG_INFO(2)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, "PEMX_DBG_INFO(2)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 2, "PEMX_DBG_INFO(2)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, "PEMX_DBG_INFO(2)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, "PEMX_DBG_INFO(2)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, "PEMX_DBG_INFO(2)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 2, "PEMX_DBG_INFO(2)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 2, "PEMX_DBG_INFO(2)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 2, "PEMX_DBG_INFO(2)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 2, "PEMX_DBG_INFO(2)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 2, "PEMX_DBG_INFO(2)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 2, "PEMX_DBG_INFO(2)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 2, "PEMX_DBG_INFO(2)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 2, "PEMX_DBG_INFO(2)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 2, "PEMX_DBG_INFO(2)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 2, "PEMX_DBG_INFO(2)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 2, "PEMX_DBG_INFO(2)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 2, "PEMX_DBG_INFO(2)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 2, "PEMX_DBG_INFO(2)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 2, "PEMX_DBG_INFO(2)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 2, "PEMX_DBG_INFO(2)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 2, "PEMX_DBG_INFO(2)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 2, "PEMX_DBG_INFO(2)[ECRC_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 2, "PEMX_DBG_INFO(2)[RTRY_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 2, "PEMX_DBG_INFO(2)[HDRQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 2, "PEMX_DBG_INFO(2)[DATQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 2, "PEMX_DBG_INFO(2)[P_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 2, "PEMX_DBG_INFO(2)[P_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 2, "PEMX_DBG_INFO(2)[P_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 2, "PEMX_DBG_INFO(2)[P_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 2, "PEMX_DBG_INFO(2)[N_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 2, "PEMX_DBG_INFO(2)[N_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 2, "PEMX_DBG_INFO(2)[N_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 2, "PEMX_DBG_INFO(2)[N_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 2, "PEMX_DBG_INFO(2)[C_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 2, "PEMX_DBG_INFO(2)[C_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 2, "PEMX_DBG_INFO(2)[C_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 2, "PEMX_DBG_INFO(2)[C_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 2, 0, "PEMX_DBG_INFO(2)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 2, 0, "PEMX_DBG_INFO(2)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 2, 0, "PEMX_DBG_INFO(2)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, 0, "PEMX_DBG_INFO(2)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, 0, "PEMX_DBG_INFO(2)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, 0, "PEMX_DBG_INFO(2)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, 0, "PEMX_DBG_INFO(2)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, 0, "PEMX_DBG_INFO(2)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, 0, "PEMX_DBG_INFO(2)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 2, 0, "PEMX_DBG_INFO(2)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, 0, "PEMX_DBG_INFO(2)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, 0, "PEMX_DBG_INFO(2)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, 0, "PEMX_DBG_INFO(2)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 2, 0, "PEMX_DBG_INFO(2)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 2, 0, "PEMX_DBG_INFO(2)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 2, 0, "PEMX_DBG_INFO(2)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 2, 0, "PEMX_DBG_INFO(2)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 2, 0, "PEMX_DBG_INFO(2)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 2, 0, "PEMX_DBG_INFO(2)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 2, 0, "PEMX_DBG_INFO(2)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 2, 0, "PEMX_DBG_INFO(2)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 2, 0, "PEMX_DBG_INFO(2)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 2, 0, "PEMX_DBG_INFO(2)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 2, 0, "PEMX_DBG_INFO(2)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 2, 0, "PEMX_DBG_INFO(2)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 2, 0, "PEMX_DBG_INFO(2)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 2, 0, "PEMX_DBG_INFO(2)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 2, 0, "PEMX_DBG_INFO(2)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 2, 0, "PEMX_DBG_INFO(2)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 2, 0, "PEMX_DBG_INFO(2)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 2, 0, "PEMX_DBG_INFO(2)[RTRY_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 2, 0, "PEMX_DBG_INFO(2)[HDRQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 2, 0, "PEMX_DBG_INFO(2)[DATQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[P_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[P_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[P_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[P_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[N_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[N_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[N_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[N_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[C_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[C_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[C_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[C_C_DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -3784,65 +3784,65 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "PEMX_DBG_INFO(0)[RTRY_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "PEMX_DBG_INFO(0)[HDRQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "PEMX_DBG_INFO(0)[DATQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "PEMX_DBG_INFO(0)[P_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "PEMX_DBG_INFO(0)[P_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "PEMX_DBG_INFO(0)[P_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "PEMX_DBG_INFO(0)[P_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "PEMX_DBG_INFO(0)[N_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "PEMX_DBG_INFO(0)[N_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "PEMX_DBG_INFO(0)[N_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "PEMX_DBG_INFO(0)[N_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "PEMX_DBG_INFO(0)[C_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "PEMX_DBG_INFO(0)[C_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "PEMX_DBG_INFO(0)[C_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "PEMX_DBG_INFO(0)[C_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "PEMX_DBG_INFO(0)[RTRY_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "PEMX_DBG_INFO(0)[HDRQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "PEMX_DBG_INFO(0)[DATQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[P_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[P_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[P_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[P_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[N_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[N_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[N_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[N_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[C_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[C_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[C_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[C_C_DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -3852,65 +3852,65 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 1, "PEMX_DBG_INFO(1)[RTRY_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 1, "PEMX_DBG_INFO(1)[HDRQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 1, "PEMX_DBG_INFO(1)[DATQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 1, "PEMX_DBG_INFO(1)[P_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 1, "PEMX_DBG_INFO(1)[P_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 1, "PEMX_DBG_INFO(1)[P_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 1, "PEMX_DBG_INFO(1)[P_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 1, "PEMX_DBG_INFO(1)[N_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 1, "PEMX_DBG_INFO(1)[N_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 1, "PEMX_DBG_INFO(1)[N_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 1, "PEMX_DBG_INFO(1)[N_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 1, "PEMX_DBG_INFO(1)[C_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, "PEMX_DBG_INFO(1)[C_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, "PEMX_DBG_INFO(1)[C_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, "PEMX_DBG_INFO(1)[C_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 1, 0, "PEMX_DBG_INFO(1)[RTRY_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 1, 0, "PEMX_DBG_INFO(1)[HDRQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 1, 0, "PEMX_DBG_INFO(1)[DATQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[P_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[P_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[P_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[P_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[N_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[N_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[N_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[N_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[C_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[C_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[C_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[C_C_DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -3920,495 +3920,495 @@ static struct cvmx_error_muxchild error_tree_cn70xx =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "DFA_ERROR[DLC0_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DFA_ERROR[DFANXM]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DFA_ERROR[REPLERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "DFA_ERROR[DLC0_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DFA_ERROR[DFANXM]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DFA_ERROR[REPLERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000107000000E200ull) /* CVMX_CIU_CIB_LMCX_RAWX(0,0) */, CVMX_ADD_IO_SEG(0x000107000000E300ull) /* CVMX_CIU_CIB_LMCX_ENX(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_SEC_ERRX]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_DED_ERRX]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_LMCX_RAWX(0,0)[INT_SEC_ERRX]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_LMCX_RAWX(0,0)[INT_DED_ERRX]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_NXM_WR_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "KEY_INT_SUM[KEY_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "KEY_INT_SUM[KEY_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "KEY_INT_SUM[KEY_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "KEY_INT_SUM[KEY_DBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000107000000E400ull) /* CVMX_CIU_CIB_RST_RAWX(0) */, CVMX_ADD_IO_SEG(0x000107000000E500ull) /* CVMX_CIU_CIB_RST_ENX(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "CIU_CIB_RST_RAWX(0)[INT_LINKX]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "CIU_CIB_RST_RAWX(0)[INT_PERSTX]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "CIU_CIB_RST_RAWX(0)[INT_LINKX]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "CIU_CIB_RST_RAWX(0)[INT_PERSTX]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 46 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 0, "GMXX_RXX_INT_REG(0,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 0, 0, "GMXX_RXX_INT_REG(0,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 1, "GMXX_RXX_INT_REG(1,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 1, 0, "GMXX_RXX_INT_REG(1,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 2, "GMXX_RXX_INT_REG(2,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 2, 0, "GMXX_RXX_INT_REG(2,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 3, "GMXX_RXX_INT_REG(3,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 3, 0, "GMXX_RXX_INT_REG(3,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 37 /* agx1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 16, "GMXX_RXX_INT_REG(0,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 16, 0, "GMXX_RXX_INT_REG(0,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 17, "GMXX_RXX_INT_REG(1,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, 0, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, 0, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 17, 0, "GMXX_RXX_INT_REG(1,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 18, "GMXX_RXX_INT_REG(2,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, 0, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, 0, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 18, 0, "GMXX_RXX_INT_REG(2,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 19, "GMXX_RXX_INT_REG(3,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, 0, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, 0, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 19, 0, "GMXX_RXX_INT_REG(3,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSX_INTX_REG(0,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "PCSX_INTX_REG(0,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, 0, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "PCSX_INTX_REG(1,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, "PCSX_INTX_REG(1,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, "PCSX_INTX_REG(1,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "PCSX_INTX_REG(1,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, "PCSX_INTX_REG(1,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "PCSX_INTX_REG(1,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "PCSX_INTX_REG(1,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "PCSX_INTX_REG(1,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "PCSX_INTX_REG(1,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, 0, "PCSX_INTX_REG(1,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "PCSX_INTX_REG(1,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "PCSX_INTX_REG(1,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, 0, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "PCSX_INTX_REG(2,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, "PCSX_INTX_REG(2,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, "PCSX_INTX_REG(2,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "PCSX_INTX_REG(2,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, "PCSX_INTX_REG(2,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "PCSX_INTX_REG(2,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "PCSX_INTX_REG(2,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "PCSX_INTX_REG(2,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "PCSX_INTX_REG(2,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, 0, "PCSX_INTX_REG(2,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "PCSX_INTX_REG(2,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "PCSX_INTX_REG(2,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, 0, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "PCSX_INTX_REG(3,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, "PCSX_INTX_REG(3,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, "PCSX_INTX_REG(3,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "PCSX_INTX_REG(3,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, "PCSX_INTX_REG(3,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "PCSX_INTX_REG(3,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "PCSX_INTX_REG(3,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "PCSX_INTX_REG(3,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "PCSX_INTX_REG(3,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, 0, "PCSX_INTX_REG(3,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "PCSX_INTX_REG(3,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "PCSX_INTX_REG(3,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, 0, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DPI_INT_REG[SPRT2_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "DPI_INT_REG[SPRT3_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DPI_INT_REG[SPRT2_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "DPI_INT_REG[SPRT3_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -4426,336 +4426,336 @@ static struct cvmx_error_muxchild error_tree_cn52xxp1 =
 					{CVMX_ADD_IO_SEG(0x00011F0000008520ull) /* CVMX_PEXP_NPEI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800800000F8ull) /* CVMX_L2C_INT_STAT */, CVMX_ADD_IO_SEG(0x0001180080000100ull) /* CVMX_L2C_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_STAT[L2TSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_STAT[L2DSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_STAT[OOB1]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_STAT[OOB2]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_STAT[OOB3]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_STAT[L2TDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_STAT[L2DDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_STAT[LCK]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_INT_STAT[LCK2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2TSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2DSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_STAT[OOB1]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_STAT[OOB2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_STAT[OOB3]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2TDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2DDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_STAT[LCK]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_INT_STAT[LCK2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 28 /* agl */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, 0, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, 0, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 15 /* usb1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((1) & 1) * 0x10000000ull /* CVMX_USBNX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((1) & 1) * 0x10000000ull /* CVMX_USBNX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 1, "USBNX_INT_SUM(1)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 1, "USBNX_INT_SUM(1)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 1, "USBNX_INT_SUM(1)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 1, "USBNX_INT_SUM(1)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 1, "USBNX_INT_SUM(1)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 1, "USBNX_INT_SUM(1)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 1, "USBNX_INT_SUM(1)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 1, "USBNX_INT_SUM(1)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 1, "USBNX_INT_SUM(1)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 1, "USBNX_INT_SUM(1)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 1, "USBNX_INT_SUM(1)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 1, "USBNX_INT_SUM(1)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 1, "USBNX_INT_SUM(1)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 1, "USBNX_INT_SUM(1)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 1, "USBNX_INT_SUM(1)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 1, "USBNX_INT_SUM(1)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 1, "USBNX_INT_SUM(1)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 1, "USBNX_INT_SUM(1)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 1, "USBNX_INT_SUM(1)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 1, "USBNX_INT_SUM(1)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 1, "USBNX_INT_SUM(1)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 1, "USBNX_INT_SUM(1)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 1, "USBNX_INT_SUM(1)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 1, "USBNX_INT_SUM(1)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 1, "USBNX_INT_SUM(1)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 1, "USBNX_INT_SUM(1)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 1, "USBNX_INT_SUM(1)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 1, "USBNX_INT_SUM(1)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 1, "USBNX_INT_SUM(1)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 1, "USBNX_INT_SUM(1)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 1, "USBNX_INT_SUM(1)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 1, "USBNX_INT_SUM(1)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 1, 0, "USBNX_INT_SUM(1)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 1, 0, "USBNX_INT_SUM(1)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 1, 0, "USBNX_INT_SUM(1)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 1, 0, "USBNX_INT_SUM(1)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 1, 0, "USBNX_INT_SUM(1)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 1, 0, "USBNX_INT_SUM(1)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 1, 0, "USBNX_INT_SUM(1)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 1, 0, "USBNX_INT_SUM(1)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 1, 0, "USBNX_INT_SUM(1)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 1, 0, "USBNX_INT_SUM(1)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 1, 0, "USBNX_INT_SUM(1)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 1, 0, "USBNX_INT_SUM(1)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 1, 0, "USBNX_INT_SUM(1)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 1, 0, "USBNX_INT_SUM(1)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 1, 0, "USBNX_INT_SUM(1)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 1, 0, "USBNX_INT_SUM(1)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 1, 0, "USBNX_INT_SUM(1)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 1, 0, "USBNX_INT_SUM(1)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 1, 0, "USBNX_INT_SUM(1)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 1, 0, "USBNX_INT_SUM(1)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 1, 0, "USBNX_INT_SUM(1)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 1, 0, "USBNX_INT_SUM(1)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 1, 0, "USBNX_INT_SUM(1)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 1, 0, "USBNX_INT_SUM(1)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 1, 0, "USBNX_INT_SUM(1)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 1, 0, "USBNX_INT_SUM(1)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 1, 0, "USBNX_INT_SUM(1)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 1, 0, "USBNX_INT_SUM(1)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 1, 0, "USBNX_INT_SUM(1)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 1, 0, "USBNX_INT_SUM(1)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 1, 0, "USBNX_INT_SUM(1)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 1, 0, "USBNX_INT_SUM(1)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npei */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000008530ull) /* CVMX_PEXP_NPEI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F000000BCD0ull) /* CVMX_PEXP_NPEI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEXP_NPEI_INT_SUM[CRS0_DR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEXP_NPEI_INT_SUM[CRS0_ER]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEXP_NPEI_INT_SUM[C1_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEXP_NPEI_INT_SUM[CRS1_DR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEXP_NPEI_INT_SUM[CRS1_ER]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEXP_NPEI_INT_SUM[CRS0_DR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEXP_NPEI_INT_SUM[CRS0_ER]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEXP_NPEI_INT_SUM[C1_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEXP_NPEI_INT_SUM[CRS1_DR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEXP_NPEI_INT_SUM[CRS1_ER]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 57 /* c0_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PESCX_DBG_INFO(0)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PESCX_DBG_INFO(0)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PESCX_DBG_INFO(0)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PESCX_DBG_INFO(0)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PESCX_DBG_INFO(0)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PESCX_DBG_INFO(0)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PESCX_DBG_INFO(0)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PESCX_DBG_INFO(0)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PESCX_DBG_INFO(0)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PESCX_DBG_INFO(0)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PESCX_DBG_INFO(0)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PESCX_DBG_INFO(0)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PESCX_DBG_INFO(0)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PESCX_DBG_INFO(0)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PESCX_DBG_INFO(0)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PESCX_DBG_INFO(0)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PESCX_DBG_INFO(0)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PESCX_DBG_INFO(0)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PESCX_DBG_INFO(0)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PESCX_DBG_INFO(0)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PESCX_DBG_INFO(0)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PESCX_DBG_INFO(0)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PESCX_DBG_INFO(0)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PESCX_DBG_INFO(0)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
 									{0}}},
 								{1, 58 /* c1_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PESCX_DBG_INFO(1)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PESCX_DBG_INFO(1)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PESCX_DBG_INFO(1)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PESCX_DBG_INFO(1)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PESCX_DBG_INFO(1)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PESCX_DBG_INFO(1)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PESCX_DBG_INFO(1)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PESCX_DBG_INFO(1)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PESCX_DBG_INFO(1)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PESCX_DBG_INFO(1)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PESCX_DBG_INFO(1)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PESCX_DBG_INFO(1)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PESCX_DBG_INFO(1)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PESCX_DBG_INFO(1)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PESCX_DBG_INFO(1)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PESCX_DBG_INFO(1)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PESCX_DBG_INFO(1)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PESCX_DBG_INFO(1)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PESCX_DBG_INFO(1)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PESCX_DBG_INFO(1)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PESCX_DBG_INFO(1)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PESCX_DBG_INFO(1)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PESCX_DBG_INFO(1)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PESCX_DBG_INFO(1)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PESCX_DBG_INFO(1)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PESCX_DBG_INFO(1)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PESCX_DBG_INFO(1)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PESCX_DBG_INFO(1)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PESCX_DBG_INFO(1)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PESCX_DBG_INFO(1)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PESCX_DBG_INFO(1)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PESCX_DBG_INFO(1)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PESCX_DBG_INFO(1)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PESCX_DBG_INFO(1)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PESCX_DBG_INFO(1)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PESCX_DBG_INFO(1)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PESCX_DBG_INFO(1)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PESCX_DBG_INFO(1)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PESCX_DBG_INFO(1)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PESCX_DBG_INFO(1)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PESCX_DBG_INFO(1)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PESCX_DBG_INFO(1)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PESCX_DBG_INFO(1)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PESCX_DBG_INFO(1)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PESCX_DBG_INFO(1)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PESCX_DBG_INFO(1)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PESCX_DBG_INFO(1)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PESCX_DBG_INFO(1)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PESCX_DBG_INFO(1)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PESCX_DBG_INFO(1)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PESCX_DBG_INFO(1)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PESCX_DBG_INFO(1)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PESCX_DBG_INFO(1)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PESCX_DBG_INFO(1)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PESCX_DBG_INFO(1)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PESCX_DBG_INFO(1)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PESCX_DBG_INFO(1)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PESCX_DBG_INFO(1)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PESCX_DBG_INFO(1)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PESCX_DBG_INFO(1)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -4765,181 +4765,181 @@ static struct cvmx_error_muxchild error_tree_cn52xxp1 =
 							{0}}},
 						{1, 14 /* rad */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asxpcs0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 0) * 0x0ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0000858ull) /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((0) & 1) * 0x10000000ull /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((0) & 1) * 0x10000000ull /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -4960,106 +4960,106 @@ static struct cvmx_error_muxchild error_tree_cn38xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_INT_SUM[PO1_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_INT_SUM[PO2_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_INT_SUM[PO3_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_INT_SUM[I1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_INT_SUM[I2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_INT_SUM[I3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_INT_SUM[I1_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_INT_SUM[I2_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_INT_SUM[I3_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "NPI_INT_SUM[P1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "NPI_INT_SUM[P2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "NPI_INT_SUM[P3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "NPI_INT_SUM[P1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "NPI_INT_SUM[P2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "NPI_INT_SUM[P3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "NPI_INT_SUM[G1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "NPI_INT_SUM[G2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "NPI_INT_SUM[G3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "NPI_INT_SUM[P1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "NPI_INT_SUM[P2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "NPI_INT_SUM[P3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_INT_SUM[P1_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_INT_SUM[P2_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "NPI_INT_SUM[P3_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "NPI_INT_SUM[I1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "NPI_INT_SUM[I2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "NPI_INT_SUM[I3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "NPI_INT_SUM[FCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "NPI_INT_SUM[FCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "NPI_INT_SUM[PCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "NPI_INT_SUM[PCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, "NPI_INT_SUM[Q2_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, "NPI_INT_SUM[Q2_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, "NPI_INT_SUM[Q3_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, "NPI_INT_SUM[Q3_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, "NPI_INT_SUM[COM_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, "NPI_INT_SUM[COM_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, "NPI_INT_SUM[PNC_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "NPI_INT_SUM[PNC_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, "NPI_INT_SUM[RWX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "NPI_INT_SUM[RDX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, "NPI_INT_SUM[PCF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, "NPI_INT_SUM[PCF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, "NPI_INT_SUM[PDF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "NPI_INT_SUM[PDF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, "NPI_INT_SUM[Q1_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, "NPI_INT_SUM[Q1_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_INT_SUM[PO1_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_INT_SUM[PO2_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_INT_SUM[PO3_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_INT_SUM[I1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_INT_SUM[I2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_INT_SUM[I3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_INT_SUM[I1_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_INT_SUM[I2_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_INT_SUM[I3_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "NPI_INT_SUM[P1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "NPI_INT_SUM[P2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "NPI_INT_SUM[P3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "NPI_INT_SUM[P1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "NPI_INT_SUM[P2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "NPI_INT_SUM[P3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "NPI_INT_SUM[G1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "NPI_INT_SUM[G2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "NPI_INT_SUM[G3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "NPI_INT_SUM[P1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "NPI_INT_SUM[P2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "NPI_INT_SUM[P3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_INT_SUM[P1_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_INT_SUM[P2_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "NPI_INT_SUM[P3_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "NPI_INT_SUM[I1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "NPI_INT_SUM[I2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "NPI_INT_SUM[I3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "NPI_INT_SUM[FCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, 0, "NPI_INT_SUM[FCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, 0, "NPI_INT_SUM[PCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, 0, "NPI_INT_SUM[PCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, 0, "NPI_INT_SUM[Q2_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, 0, "NPI_INT_SUM[Q2_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, 0, "NPI_INT_SUM[Q3_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, 0, "NPI_INT_SUM[Q3_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, 0, "NPI_INT_SUM[COM_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, 0, "NPI_INT_SUM[COM_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, 0, "NPI_INT_SUM[PNC_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "NPI_INT_SUM[PNC_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, 0, "NPI_INT_SUM[RWX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "NPI_INT_SUM[RDX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, 0, "NPI_INT_SUM[PCF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, 0, "NPI_INT_SUM[PCF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, 0, "NPI_INT_SUM[PDF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "NPI_INT_SUM[PDF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, 0, "NPI_INT_SUM[Q1_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, 0, "NPI_INT_SUM[Q1_A_F]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -5069,343 +5069,343 @@ static struct cvmx_error_muxchild error_tree_cn38xx =
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, 0, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, 0, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, 0, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 2 /* gmx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_BAD_REG(1)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_BAD_REG(1)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_BAD_REG(1)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_BAD_REG(1)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, 0, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, 0, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, 0, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 18 /* spx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "SPXX_INT_REG(0)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "SPXX_INT_REG(0)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "SPXX_INT_REG(0)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "SPXX_INT_REG(0)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "SPXX_INT_REG(0)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "SPXX_INT_REG(0)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "SPXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "SPXX_INT_REG(0)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, "SPXX_INT_REG(0)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "SPXX_INT_REG(0)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "SPXX_INT_REG(0)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "SPXX_INT_REG(0)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "SPXX_INT_REG(0)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "SPXX_INT_REG(0)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "SPXX_INT_REG(0)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "SPXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "SPXX_INT_REG(0)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, 0, "SPXX_INT_REG(0)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "STXX_INT_REG(0)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "STXX_INT_REG(0)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "STXX_INT_REG(0)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "STXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "STXX_INT_REG(0)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "STXX_INT_REG(0)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "STXX_INT_REG(0)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "STXX_INT_REG(0)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "STXX_INT_REG(0)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "STXX_INT_REG(0)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "STXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "STXX_INT_REG(0)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "STXX_INT_REG(0)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "STXX_INT_REG(0)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 19 /* spx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "SPXX_INT_REG(1)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "SPXX_INT_REG(1)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "SPXX_INT_REG(1)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "SPXX_INT_REG(1)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "SPXX_INT_REG(1)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "SPXX_INT_REG(1)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "SPXX_INT_REG(1)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "SPXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "SPXX_INT_REG(1)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, "SPXX_INT_REG(1)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "SPXX_INT_REG(1)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "SPXX_INT_REG(1)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "SPXX_INT_REG(1)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "SPXX_INT_REG(1)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "SPXX_INT_REG(1)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "SPXX_INT_REG(1)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "SPXX_INT_REG(1)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "SPXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "SPXX_INT_REG(1)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, 0, "SPXX_INT_REG(1)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "STXX_INT_REG(1)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "STXX_INT_REG(1)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "STXX_INT_REG(1)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "STXX_INT_REG(1)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "STXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "STXX_INT_REG(1)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "STXX_INT_REG(1)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "STXX_INT_REG(1)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "STXX_INT_REG(1)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "STXX_INT_REG(1)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "STXX_INT_REG(1)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "STXX_INT_REG(1)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "STXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "STXX_INT_REG(1)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "STXX_INT_REG(1)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "STXX_INT_REG(1)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 23 /* asx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "ASXX_INT_REG(1)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "ASXX_INT_REG(1)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "ASXX_INT_REG(1)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "ASXX_INT_REG(1)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "ASXX_INT_REG(1)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "ASXX_INT_REG(1)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 4 /* key */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 6 /* dfa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180030000028ull) /* CVMX_DFA_ERR */, 0, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERR[CP2SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "DFA_ERR[CP2DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERR[DTESBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "DFA_ERR[DTEDBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DFA_ERR[DTEPERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "DFA_ERR[CP2PERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "DFA_ERR[DBLOVF]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[CP2SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[CP2DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[DTESBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[DTEDBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DFA_ERR[DTEPERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "DFA_ERR[CP2PERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "DFA_ERR[DBLOVF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -5426,88 +5426,88 @@ static struct cvmx_error_muxchild error_tree_cn31xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_INT_SUM[PO1_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_INT_SUM[I1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_INT_SUM[I1_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "NPI_INT_SUM[P1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "NPI_INT_SUM[P1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "NPI_INT_SUM[G1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "NPI_INT_SUM[P1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_INT_SUM[P1_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "NPI_INT_SUM[I1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "NPI_INT_SUM[FCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "NPI_INT_SUM[FCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "NPI_INT_SUM[PCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "NPI_INT_SUM[PCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, "NPI_INT_SUM[Q2_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, "NPI_INT_SUM[Q2_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, "NPI_INT_SUM[Q3_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, "NPI_INT_SUM[Q3_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, "NPI_INT_SUM[COM_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, "NPI_INT_SUM[COM_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, "NPI_INT_SUM[PNC_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "NPI_INT_SUM[PNC_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, "NPI_INT_SUM[RWX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "NPI_INT_SUM[RDX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, "NPI_INT_SUM[PCF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, "NPI_INT_SUM[PCF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, "NPI_INT_SUM[PDF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "NPI_INT_SUM[PDF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, "NPI_INT_SUM[Q1_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, "NPI_INT_SUM[Q1_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_INT_SUM[PO1_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_INT_SUM[I1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_INT_SUM[I1_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "NPI_INT_SUM[P1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "NPI_INT_SUM[P1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "NPI_INT_SUM[G1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "NPI_INT_SUM[P1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_INT_SUM[P1_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "NPI_INT_SUM[I1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "NPI_INT_SUM[FCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, 0, "NPI_INT_SUM[FCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, 0, "NPI_INT_SUM[PCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, 0, "NPI_INT_SUM[PCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, 0, "NPI_INT_SUM[Q2_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, 0, "NPI_INT_SUM[Q2_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, 0, "NPI_INT_SUM[Q3_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, 0, "NPI_INT_SUM[Q3_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, 0, "NPI_INT_SUM[COM_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, 0, "NPI_INT_SUM[COM_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, 0, "NPI_INT_SUM[PNC_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "NPI_INT_SUM[PNC_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, 0, "NPI_INT_SUM[RWX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "NPI_INT_SUM[RDX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, 0, "NPI_INT_SUM[PCF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, 0, "NPI_INT_SUM[PCF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, 0, "NPI_INT_SUM[PDF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "NPI_INT_SUM[PDF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, 0, "NPI_INT_SUM[Q1_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, 0, "NPI_INT_SUM[Q1_A_F]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -5517,229 +5517,229 @@ static struct cvmx_error_muxchild error_tree_cn31xx =
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x0ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x0ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x0ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x0ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, 0, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x0ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x0ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, 0, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 6 /* dfa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180030000028ull) /* CVMX_DFA_ERR */, 0, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERR[CP2SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "DFA_ERR[CP2DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERR[DTESBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "DFA_ERR[DTEDBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DFA_ERR[DTEPERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "DFA_ERR[CP2PERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "DFA_ERR[DBLOVF]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[CP2SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[CP2DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[DTESBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[DTEDBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DFA_ERR[DTEPERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "DFA_ERR[CP2PERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "DFA_ERR[DBLOVF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 26, 0, "USBNX_INT_SUM(0)[N2U_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 27, 0, "USBNX_INT_SUM(0)[N2U_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 28, 0, "USBNX_INT_SUM(0)[U2N_D_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 29, 0, "USBNX_INT_SUM(0)[U2N_D_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 30, 0, "USBNX_INT_SUM(0)[U2N_C_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 31, 0, "USBNX_INT_SUM(0)[U2N_C_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 26, 0, 0, "USBNX_INT_SUM(0)[N2U_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 27, 0, 0, "USBNX_INT_SUM(0)[N2U_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 28, 0, 0, "USBNX_INT_SUM(0)[U2N_D_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 29, 0, 0, "USBNX_INT_SUM(0)[U2N_D_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 30, 0, 0, "USBNX_INT_SUM(0)[U2N_C_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 31, 0, 0, "USBNX_INT_SUM(0)[U2N_C_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -5760,106 +5760,106 @@ static struct cvmx_error_muxchild error_tree_cn58xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_INT_SUM[PO1_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_INT_SUM[PO2_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_INT_SUM[PO3_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_INT_SUM[I1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_INT_SUM[I2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_INT_SUM[I3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_INT_SUM[I1_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_INT_SUM[I2_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_INT_SUM[I3_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "NPI_INT_SUM[P1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "NPI_INT_SUM[P2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "NPI_INT_SUM[P3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "NPI_INT_SUM[P1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "NPI_INT_SUM[P2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "NPI_INT_SUM[P3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "NPI_INT_SUM[G1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "NPI_INT_SUM[G2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "NPI_INT_SUM[G3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "NPI_INT_SUM[P1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "NPI_INT_SUM[P2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "NPI_INT_SUM[P3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_INT_SUM[P1_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_INT_SUM[P2_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "NPI_INT_SUM[P3_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "NPI_INT_SUM[I1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "NPI_INT_SUM[I2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "NPI_INT_SUM[I3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "NPI_INT_SUM[FCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "NPI_INT_SUM[FCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "NPI_INT_SUM[PCR_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "NPI_INT_SUM[PCR_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, "NPI_INT_SUM[Q2_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, "NPI_INT_SUM[Q2_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, "NPI_INT_SUM[Q3_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, "NPI_INT_SUM[Q3_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, "NPI_INT_SUM[COM_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, "NPI_INT_SUM[COM_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, "NPI_INT_SUM[PNC_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "NPI_INT_SUM[PNC_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, "NPI_INT_SUM[RWX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "NPI_INT_SUM[RDX_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, "NPI_INT_SUM[PCF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, "NPI_INT_SUM[PCF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, "NPI_INT_SUM[PDF_P_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "NPI_INT_SUM[PDF_P_F]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, "NPI_INT_SUM[Q1_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, "NPI_INT_SUM[Q1_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_INT_SUM[PO1_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_INT_SUM[PO2_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_INT_SUM[PO3_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_INT_SUM[I1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_INT_SUM[I2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_INT_SUM[I3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_INT_SUM[I1_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_INT_SUM[I2_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_INT_SUM[I3_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "NPI_INT_SUM[P1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "NPI_INT_SUM[P2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "NPI_INT_SUM[P3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "NPI_INT_SUM[P1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "NPI_INT_SUM[P2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "NPI_INT_SUM[P3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "NPI_INT_SUM[G1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "NPI_INT_SUM[G2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "NPI_INT_SUM[G3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "NPI_INT_SUM[P1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "NPI_INT_SUM[P2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "NPI_INT_SUM[P3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_INT_SUM[P1_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_INT_SUM[P2_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "NPI_INT_SUM[P3_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "NPI_INT_SUM[I1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "NPI_INT_SUM[I2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "NPI_INT_SUM[I3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "NPI_INT_SUM[FCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, 0, "NPI_INT_SUM[FCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, 0, "NPI_INT_SUM[PCR_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, 0, "NPI_INT_SUM[PCR_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 0, 0, "NPI_INT_SUM[Q2_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 0, 0, "NPI_INT_SUM[Q2_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 0, 0, "NPI_INT_SUM[Q3_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 0, 0, "NPI_INT_SUM[Q3_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 0, 0, "NPI_INT_SUM[COM_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 0, 0, "NPI_INT_SUM[COM_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 0, 0, "NPI_INT_SUM[PNC_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "NPI_INT_SUM[PNC_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 0, 0, "NPI_INT_SUM[RWX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "NPI_INT_SUM[RDX_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 0, 0, "NPI_INT_SUM[PCF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 57, 0, 0, "NPI_INT_SUM[PCF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 58, 0, 0, "NPI_INT_SUM[PDF_P_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "NPI_INT_SUM[PDF_P_F]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 0, 0, "NPI_INT_SUM[Q1_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 61, 0, 0, "NPI_INT_SUM[Q1_A_F]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -5869,347 +5869,347 @@ static struct cvmx_error_muxchild error_tree_cn58xx =
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, 0, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, 0, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, 0, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 2 /* gmx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_BAD_REG(1)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_BAD_REG(1)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_BAD_REG(1)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_BAD_REG(1)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, 0, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, 0, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, 0, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 18 /* spx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "SPXX_INT_REG(0)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "SPXX_INT_REG(0)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "SPXX_INT_REG(0)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "SPXX_INT_REG(0)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "SPXX_INT_REG(0)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "SPXX_INT_REG(0)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "SPXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "SPXX_INT_REG(0)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, "SPXX_INT_REG(0)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "SPXX_INT_REG(0)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "SPXX_INT_REG(0)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "SPXX_INT_REG(0)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "SPXX_INT_REG(0)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "SPXX_INT_REG(0)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "SPXX_INT_REG(0)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "SPXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "SPXX_INT_REG(0)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, 0, "SPXX_INT_REG(0)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "STXX_INT_REG(0)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "STXX_INT_REG(0)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "STXX_INT_REG(0)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "STXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "STXX_INT_REG(0)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "STXX_INT_REG(0)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "STXX_INT_REG(0)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "STXX_INT_REG(0)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "STXX_INT_REG(0)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "STXX_INT_REG(0)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "STXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "STXX_INT_REG(0)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "STXX_INT_REG(0)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "STXX_INT_REG(0)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 19 /* spx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "SPXX_INT_REG(1)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "SPXX_INT_REG(1)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "SPXX_INT_REG(1)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "SPXX_INT_REG(1)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "SPXX_INT_REG(1)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "SPXX_INT_REG(1)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "SPXX_INT_REG(1)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "SPXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "SPXX_INT_REG(1)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, "SPXX_INT_REG(1)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "SPXX_INT_REG(1)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "SPXX_INT_REG(1)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "SPXX_INT_REG(1)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "SPXX_INT_REG(1)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "SPXX_INT_REG(1)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "SPXX_INT_REG(1)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "SPXX_INT_REG(1)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "SPXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "SPXX_INT_REG(1)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, 0, "SPXX_INT_REG(1)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "STXX_INT_REG(1)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "STXX_INT_REG(1)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "STXX_INT_REG(1)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "STXX_INT_REG(1)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "STXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "STXX_INT_REG(1)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "STXX_INT_REG(1)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "STXX_INT_REG(1)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "STXX_INT_REG(1)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "STXX_INT_REG(1)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "STXX_INT_REG(1)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "STXX_INT_REG(1)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "STXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "STXX_INT_REG(1)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "STXX_INT_REG(1)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "STXX_INT_REG(1)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 23 /* asx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "ASXX_INT_REG(1)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "ASXX_INT_REG(1)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "ASXX_INT_REG(1)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "ASXX_INT_REG(1)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "ASXX_INT_REG(1)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "ASXX_INT_REG(1)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 4 /* key */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 0) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 0) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 6 /* dfa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180030000028ull) /* CVMX_DFA_ERR */, 0, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERR[CP2SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "DFA_ERR[CP2DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERR[DTESBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "DFA_ERR[DTEDBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DFA_ERR[DTEPERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "DFA_ERR[CP2PERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "DFA_ERR[DBLOVF]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[CP2SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[CP2DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[DTESBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[DTEDBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DFA_ERR[DTEPERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "DFA_ERR[CP2PERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "DFA_ERR[DBLOVF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -6230,353 +6230,353 @@ static struct cvmx_error_muxchild error_tree_cn56xxp1 =
 					{CVMX_ADD_IO_SEG(0x00011F0000008520ull) /* CVMX_PEXP_NPEI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800800000F8ull) /* CVMX_L2C_INT_STAT */, CVMX_ADD_IO_SEG(0x0001180080000100ull) /* CVMX_L2C_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_STAT[L2TSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_STAT[L2DSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_STAT[OOB1]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_STAT[OOB2]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_STAT[OOB3]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_STAT[L2TDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_STAT[L2DDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_STAT[LCK]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_INT_STAT[LCK2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2TSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2DSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_STAT[OOB1]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_STAT[OOB2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_STAT[OOB3]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2TDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2DDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_STAT[LCK]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_INT_STAT[LCK2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 28 /* agl */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 2 /* gmx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, 0, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, 0, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, 0, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, 0, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, 0, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, 0, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npei */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000008530ull) /* CVMX_PEXP_NPEI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F000000BCD0ull) /* CVMX_PEXP_NPEI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, "PEXP_NPEI_INT_SUM[C0_LDWN]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 1, "PEXP_NPEI_INT_SUM[C1_LDWN]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEXP_NPEI_INT_SUM[C1_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_NPEI_INT_SUM[DMA4DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 59, 0, 0, "PEXP_NPEI_INT_SUM[C0_LDWN]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 60, 1, 0, "PEXP_NPEI_INT_SUM[C1_LDWN]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEXP_NPEI_INT_SUM[C1_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_NPEI_INT_SUM[DMA4DBO]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 57 /* c0_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PESCX_DBG_INFO(0)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PESCX_DBG_INFO(0)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PESCX_DBG_INFO(0)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PESCX_DBG_INFO(0)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PESCX_DBG_INFO(0)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PESCX_DBG_INFO(0)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PESCX_DBG_INFO(0)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PESCX_DBG_INFO(0)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PESCX_DBG_INFO(0)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PESCX_DBG_INFO(0)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PESCX_DBG_INFO(0)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PESCX_DBG_INFO(0)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PESCX_DBG_INFO(0)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PESCX_DBG_INFO(0)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PESCX_DBG_INFO(0)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PESCX_DBG_INFO(0)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PESCX_DBG_INFO(0)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PESCX_DBG_INFO(0)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PESCX_DBG_INFO(0)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PESCX_DBG_INFO(0)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PESCX_DBG_INFO(0)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PESCX_DBG_INFO(0)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PESCX_DBG_INFO(0)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PESCX_DBG_INFO(0)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
 									{0}}},
 								{1, 58 /* c1_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PESCX_DBG_INFO(1)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PESCX_DBG_INFO(1)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PESCX_DBG_INFO(1)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PESCX_DBG_INFO(1)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PESCX_DBG_INFO(1)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PESCX_DBG_INFO(1)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PESCX_DBG_INFO(1)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PESCX_DBG_INFO(1)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PESCX_DBG_INFO(1)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PESCX_DBG_INFO(1)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PESCX_DBG_INFO(1)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PESCX_DBG_INFO(1)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PESCX_DBG_INFO(1)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PESCX_DBG_INFO(1)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PESCX_DBG_INFO(1)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PESCX_DBG_INFO(1)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PESCX_DBG_INFO(1)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PESCX_DBG_INFO(1)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PESCX_DBG_INFO(1)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PESCX_DBG_INFO(1)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PESCX_DBG_INFO(1)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PESCX_DBG_INFO(1)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PESCX_DBG_INFO(1)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PESCX_DBG_INFO(1)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PESCX_DBG_INFO(1)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PESCX_DBG_INFO(1)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PESCX_DBG_INFO(1)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PESCX_DBG_INFO(1)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PESCX_DBG_INFO(1)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PESCX_DBG_INFO(1)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PESCX_DBG_INFO(1)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PESCX_DBG_INFO(1)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PESCX_DBG_INFO(1)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PESCX_DBG_INFO(1)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PESCX_DBG_INFO(1)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PESCX_DBG_INFO(1)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PESCX_DBG_INFO(1)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PESCX_DBG_INFO(1)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PESCX_DBG_INFO(1)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PESCX_DBG_INFO(1)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PESCX_DBG_INFO(1)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PESCX_DBG_INFO(1)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PESCX_DBG_INFO(1)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PESCX_DBG_INFO(1)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PESCX_DBG_INFO(1)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PESCX_DBG_INFO(1)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PESCX_DBG_INFO(1)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PESCX_DBG_INFO(1)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PESCX_DBG_INFO(1)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PESCX_DBG_INFO(1)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PESCX_DBG_INFO(1)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PESCX_DBG_INFO(1)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PESCX_DBG_INFO(1)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PESCX_DBG_INFO(1)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PESCX_DBG_INFO(1)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PESCX_DBG_INFO(1)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PESCX_DBG_INFO(1)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PESCX_DBG_INFO(1)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PESCX_DBG_INFO(1)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PESCX_DBG_INFO(1)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -6586,264 +6586,264 @@ static struct cvmx_error_muxchild error_tree_cn56xxp1 =
 							{0}}},
 						{1, 14 /* rad */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 29 /* lmc1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((1) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(1) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((1) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(1) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 1, "LMCX_MEM_CFG0(1)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 1, "LMCX_MEM_CFG0(1)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 1, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(1)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 1, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(1)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 23 /* asxpcs1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSX_INTX_REG(0,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "PCSX_INTX_REG(0,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "PCSX_INTX_REG(1,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, "PCSX_INTX_REG(1,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, "PCSX_INTX_REG(1,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "PCSX_INTX_REG(1,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, "PCSX_INTX_REG(1,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "PCSX_INTX_REG(1,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "PCSX_INTX_REG(1,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "PCSX_INTX_REG(1,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "PCSX_INTX_REG(1,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, 0, "PCSX_INTX_REG(1,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "PCSX_INTX_REG(1,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "PCSX_INTX_REG(1,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "PCSX_INTX_REG(2,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, "PCSX_INTX_REG(2,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, "PCSX_INTX_REG(2,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "PCSX_INTX_REG(2,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, "PCSX_INTX_REG(2,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "PCSX_INTX_REG(2,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "PCSX_INTX_REG(2,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "PCSX_INTX_REG(2,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "PCSX_INTX_REG(2,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, 0, "PCSX_INTX_REG(2,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "PCSX_INTX_REG(2,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "PCSX_INTX_REG(2,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "PCSX_INTX_REG(3,1)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, "PCSX_INTX_REG(3,1)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, "PCSX_INTX_REG(3,1)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "PCSX_INTX_REG(3,1)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, "PCSX_INTX_REG(3,1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "PCSX_INTX_REG(3,1)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "PCSX_INTX_REG(3,1)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "PCSX_INTX_REG(3,1)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "PCSX_INTX_REG(3,1)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, 0, "PCSX_INTX_REG(3,1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "PCSX_INTX_REG(3,1)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "PCSX_INTX_REG(3,1)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "PCSXX_INT_REG(1)[TXFLT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "PCSXX_INT_REG(1)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSXX_INT_REG(1)[BITLCKLS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSXX_INT_REG(1)[SYNLOS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSXX_INT_REG(1)[ALGNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "PCSXX_INT_REG(1)[TXFLT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "PCSXX_INT_REG(1)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSXX_INT_REG(1)[RXSYNBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSXX_INT_REG(1)[BITLCKLS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSXX_INT_REG(1)[SYNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSXX_INT_REG(1)[ALGNLOS]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asxpcs0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 4 /* key */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((0) & 1) * 0x60000000ull /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((0) & 0) * 0x10000000ull /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((0) & 0) * 0x10000000ull /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -6864,86 +6864,86 @@ static struct cvmx_error_muxchild error_tree_cn38xxp2 =
 					{CVMX_ADD_IO_SEG(0x00011F0000000000ull) /* CVMX_NPI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npi */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000000018ull) /* CVMX_NPI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000000020ull) /* CVMX_NPI_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_INT_SUM[PO0_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_INT_SUM[PO1_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_INT_SUM[PO2_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_INT_SUM[PO3_2SML]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_INT_SUM[I0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_INT_SUM[I1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_INT_SUM[I2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_INT_SUM[I3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_INT_SUM[I0_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_INT_SUM[I1_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_INT_SUM[I2_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_INT_SUM[I3_OVERF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_INT_SUM[P0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "NPI_INT_SUM[P1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "NPI_INT_SUM[P2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "NPI_INT_SUM[P3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "NPI_INT_SUM[P0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "NPI_INT_SUM[P1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "NPI_INT_SUM[P2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "NPI_INT_SUM[P3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "NPI_INT_SUM[G0_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "NPI_INT_SUM[G1_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "NPI_INT_SUM[G2_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "NPI_INT_SUM[G3_RTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "NPI_INT_SUM[P0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "NPI_INT_SUM[P1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "NPI_INT_SUM[P2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "NPI_INT_SUM[P3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_INT_SUM[P0_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_INT_SUM[P1_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_INT_SUM[P2_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "NPI_INT_SUM[P3_PTOUT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "NPI_INT_SUM[I0_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "NPI_INT_SUM[I1_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "NPI_INT_SUM[I2_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "NPI_INT_SUM[I3_PPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "NPI_INT_SUM[WIN_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "NPI_INT_SUM[P_DPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "NPI_INT_SUM[IOBDMA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_INT_SUM[PO0_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_INT_SUM[PO1_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_INT_SUM[PO2_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_INT_SUM[PO3_2SML]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_INT_SUM[I0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_INT_SUM[I1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_INT_SUM[I2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_INT_SUM[I3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_INT_SUM[I0_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_INT_SUM[I1_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_INT_SUM[I2_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_INT_SUM[I3_OVERF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_INT_SUM[P0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "NPI_INT_SUM[P1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "NPI_INT_SUM[P2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "NPI_INT_SUM[P3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "NPI_INT_SUM[P0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "NPI_INT_SUM[P1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "NPI_INT_SUM[P2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "NPI_INT_SUM[P3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "NPI_INT_SUM[G0_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "NPI_INT_SUM[G1_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "NPI_INT_SUM[G2_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "NPI_INT_SUM[G3_RTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "NPI_INT_SUM[P0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "NPI_INT_SUM[P1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "NPI_INT_SUM[P2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "NPI_INT_SUM[P3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_INT_SUM[P0_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_INT_SUM[P1_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_INT_SUM[P2_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "NPI_INT_SUM[P3_PTOUT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "NPI_INT_SUM[I0_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "NPI_INT_SUM[I1_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "NPI_INT_SUM[I2_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "NPI_INT_SUM[I3_PPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "NPI_INT_SUM[WIN_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "NPI_INT_SUM[P_DPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "NPI_INT_SUM[IOBDMA]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 2 /* pci_rsl */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011F0000001198ull) /* CVMX_NPI_PCI_INT_SUM2 */, CVMX_ADD_IO_SEG(0x00011F00000011A0ull) /* CVMX_NPI_PCI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "NPI_PCI_INT_SUM2[SERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "NPI_PCI_INT_SUM2[APERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "NPI_PCI_INT_SUM2[DPERR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "NPI_PCI_INT_SUM2[TR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "NPI_PCI_INT_SUM2[MR_WABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "NPI_PCI_INT_SUM2[MR_WTTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "NPI_PCI_INT_SUM2[TR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "NPI_PCI_INT_SUM2[MR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "NPI_PCI_INT_SUM2[MR_TTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "NPI_PCI_INT_SUM2[MSI_PER]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "NPI_PCI_INT_SUM2[MSI_TABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "NPI_PCI_INT_SUM2[MSI_MABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "NPI_PCI_INT_SUM2[MSC_MSG]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "NPI_PCI_INT_SUM2[TSR_ABT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "NPI_PCI_INT_SUM2[SERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "NPI_PCI_INT_SUM2[APERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "NPI_PCI_INT_SUM2[DPERR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "NPI_PCI_INT_SUM2[ILL_RWR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "NPI_PCI_INT_SUM2[ILL_RRD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "NPI_PCI_INT_SUM2[WIN_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "NPI_PCI_INT_SUM2[ILL_WR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "NPI_PCI_INT_SUM2[ILL_RD]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -6953,337 +6953,337 @@ static struct cvmx_error_muxchild error_tree_cn38xxp2 =
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_BAD_REG(0)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_BAD_REG(0)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_RXX_INT_REG(0,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "GMXX_RXX_INT_REG(0,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "GMXX_RXX_INT_REG(0,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "GMXX_RXX_INT_REG(0,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "GMXX_RXX_INT_REG(1,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "GMXX_RXX_INT_REG(1,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 1, 0, "GMXX_RXX_INT_REG(1,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "GMXX_RXX_INT_REG(1,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "GMXX_RXX_INT_REG(2,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "GMXX_RXX_INT_REG(2,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2, 0, "GMXX_RXX_INT_REG(2,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "GMXX_RXX_INT_REG(2,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "GMXX_RXX_INT_REG(3,0)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "GMXX_RXX_INT_REG(3,0)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3, 0, "GMXX_RXX_INT_REG(3,0)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "GMXX_RXX_INT_REG(3,0)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_TX_INT_REG(0)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 2 /* gmx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_BAD_REG(1)[OUT_COL]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_BAD_REG(1)[NCB_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_BAD_REG(1)[OUT_COL]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_BAD_REG(1)[NCB_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_RXX_INT_REG(0,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "GMXX_RXX_INT_REG(0,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "GMXX_RXX_INT_REG(0,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "GMXX_RXX_INT_REG(0,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "GMXX_RXX_INT_REG(1,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "GMXX_RXX_INT_REG(1,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 17, 0, "GMXX_RXX_INT_REG(1,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "GMXX_RXX_INT_REG(1,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "GMXX_RXX_INT_REG(2,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "GMXX_RXX_INT_REG(2,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 18, 0, "GMXX_RXX_INT_REG(2,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "GMXX_RXX_INT_REG(2,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "GMXX_RXX_INT_REG(3,1)[MAXERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "GMXX_RXX_INT_REG(3,1)[ALNERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 19, 0, "GMXX_RXX_INT_REG(3,1)[LENERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "GMXX_RXX_INT_REG(3,1)[NIBERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_TX_INT_REG(1)[NCB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 18 /* spx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((0) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "SPXX_INT_REG(0)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "SPXX_INT_REG(0)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "SPXX_INT_REG(0)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "SPXX_INT_REG(0)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "SPXX_INT_REG(0)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "SPXX_INT_REG(0)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "SPXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "SPXX_INT_REG(0)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, "SPXX_INT_REG(0)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "SPXX_INT_REG(0)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "SPXX_INT_REG(0)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "SPXX_INT_REG(0)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "SPXX_INT_REG(0)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "SPXX_INT_REG(0)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "SPXX_INT_REG(0)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "SPXX_INT_REG(0)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "SPXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "SPXX_INT_REG(0)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 0, 0, "SPXX_INT_REG(0)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "STXX_INT_REG(0)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "STXX_INT_REG(0)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "STXX_INT_REG(0)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "STXX_INT_REG(0)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "STXX_INT_REG(0)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "STXX_INT_REG(0)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "STXX_INT_REG(0)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "STXX_INT_REG(0)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "STXX_INT_REG(0)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "STXX_INT_REG(0)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "STXX_INT_REG(0)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "STXX_INT_REG(0)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "STXX_INT_REG(0)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "STXX_INT_REG(0)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "STXX_INT_REG(0)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 19 /* spx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((1) & 1) * 0x8000000ull /* CVMX_SPXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "SPXX_INT_REG(1)[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "SPXX_INT_REG(1)[ABNORM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "SPXX_INT_REG(1)[SPIOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "SPXX_INT_REG(1)[CLSERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "SPXX_INT_REG(1)[DRWNNG]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "SPXX_INT_REG(1)[RSVERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "SPXX_INT_REG(1)[TPAOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "SPXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "SPXX_INT_REG(1)[SYNCERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, "SPXX_INT_REG(1)[CALERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "SPXX_INT_REG(1)[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "SPXX_INT_REG(1)[ABNORM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "SPXX_INT_REG(1)[SPIOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "SPXX_INT_REG(1)[CLSERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "SPXX_INT_REG(1)[DRWNNG]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "SPXX_INT_REG(1)[RSVERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "SPXX_INT_REG(1)[TPAOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "SPXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "SPXX_INT_REG(1)[SYNCERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 11, 16, 0, "SPXX_INT_REG(1)[CALERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_STXX_INT_MSK(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "STXX_INT_REG(1)[CALPAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "STXX_INT_REG(1)[CALPAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "STXX_INT_REG(1)[OVRBST]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "STXX_INT_REG(1)[DATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "STXX_INT_REG(1)[DIPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "STXX_INT_REG(1)[NOSYNC]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "STXX_INT_REG(1)[UNXFRM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "STXX_INT_REG(1)[FRMERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "STXX_INT_REG(1)[CALPAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "STXX_INT_REG(1)[CALPAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "STXX_INT_REG(1)[OVRBST]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "STXX_INT_REG(1)[DATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "STXX_INT_REG(1)[DIPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "STXX_INT_REG(1)[NOSYNC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "STXX_INT_REG(1)[UNXFRM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "STXX_INT_REG(1)[FRMERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((0) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "ASXX_INT_REG(0)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "ASXX_INT_REG(0)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "ASXX_INT_REG(0)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "ASXX_INT_REG(0)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "ASXX_INT_REG(0)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 23 /* asx1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((1) & 1) * 0x8000000ull /* CVMX_ASXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "ASXX_INT_REG(1)[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "ASXX_INT_REG(1)[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "ASXX_INT_REG(1)[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "ASXX_INT_REG(1)[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "ASXX_INT_REG(1)[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "ASXX_INT_REG(1)[OVRFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 4 /* key */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 6 /* dfa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180030000028ull) /* CVMX_DFA_ERR */, 0, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERR[CP2SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "DFA_ERR[CP2DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERR[DTESBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "DFA_ERR[DTEDBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DFA_ERR[DTEPERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "DFA_ERR[CP2PERR]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "DFA_ERR[DBLOVF]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[CP2SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[CP2DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 14, 0, CVMX_ERROR_TYPE_SBE, "DFA_ERR[DTESBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_DBE, "DFA_ERR[DTEDBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DFA_ERR[DTEPERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "DFA_ERR[CP2PERR]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "DFA_ERR[DBLOVF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 7 /* zip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -7302,7 +7302,7 @@ static struct cvmx_error_muxchild error_tree_cn66xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -7312,42 +7312,42 @@ static struct cvmx_error_muxchild error_tree_cn66xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_REG[BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_REG[BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_INT_REG[BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_REG[BIGRD]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) /* CVMX_L2C_TADX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) /* CVMX_L2C_TADX_IEN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_TADX_INT(0)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_TADX_INT(0)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_TADX_INT(0)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_TADX_INT(0)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_TADX_INT(0)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_TADX_INT(0)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_TADX_INT(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_TADX_INT(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) /* CVMX_L2C_ERR_TDTX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, "L2C_ERR_TDTX(0)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TDTX(0)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TDTX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TDTX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) /* CVMX_L2C_ERR_TTGX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TTGX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TTGX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -7357,105 +7357,105 @@ static struct cvmx_error_muxchild error_tree_cn66xx =
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -7465,50 +7465,50 @@ static struct cvmx_error_muxchild error_tree_cn66xx =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -7518,573 +7518,573 @@ static struct cvmx_error_muxchild error_tree_cn66xx =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* usb */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 19 /* nand */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "NDF_INT[WDOG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "NDF_INT[SM_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "NDF_INT[ECC_1BIT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "NDF_INT[ECC_MULT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "NDF_INT[OVRF]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 56 /* dfm */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800D4000408ull) /* CVMX_DFM_FNT_STAT */, CVMX_ADD_IO_SEG(0x00011800D4000410ull) /* CVMX_DFM_FNT_IENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_DFM, 0, 0, "DFM_FNT_STAT[SBE_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_DFM, 1, 0, "DFM_FNT_STAT[DBE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_DFM, 0, 0, CVMX_ERROR_TYPE_SBE, "DFM_FNT_STAT[SBE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_DFM, 1, 0, CVMX_ERROR_TYPE_DBE, "DFM_FNT_STAT[DBE_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "MIO_RST_INT[RST_LINK2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "MIO_RST_INT[RST_LINK3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "MIO_RST_INT[RST_LINK2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "MIO_RST_INT[RST_LINK3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 46 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, 0, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, 0, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 28 /* zip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 37 /* agx1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, 0, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, 0, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, 0, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, 0, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, 0, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, 0, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSX_INTX_REG(0,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "PCSX_INTX_REG(0,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, 0, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "PCSX_INTX_REG(1,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, "PCSX_INTX_REG(1,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, "PCSX_INTX_REG(1,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "PCSX_INTX_REG(1,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, "PCSX_INTX_REG(1,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "PCSX_INTX_REG(1,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "PCSX_INTX_REG(1,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "PCSX_INTX_REG(1,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "PCSX_INTX_REG(1,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, 0, "PCSX_INTX_REG(1,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "PCSX_INTX_REG(1,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "PCSX_INTX_REG(1,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, 0, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "PCSX_INTX_REG(2,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, "PCSX_INTX_REG(2,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, "PCSX_INTX_REG(2,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "PCSX_INTX_REG(2,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, "PCSX_INTX_REG(2,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "PCSX_INTX_REG(2,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "PCSX_INTX_REG(2,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "PCSX_INTX_REG(2,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "PCSX_INTX_REG(2,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, 0, "PCSX_INTX_REG(2,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "PCSX_INTX_REG(2,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "PCSX_INTX_REG(2,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, 0, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "PCSX_INTX_REG(3,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, "PCSX_INTX_REG(3,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, "PCSX_INTX_REG(3,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "PCSX_INTX_REG(3,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, "PCSX_INTX_REG(3,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "PCSX_INTX_REG(3,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "PCSX_INTX_REG(3,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "PCSX_INTX_REG(3,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "PCSX_INTX_REG(3,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, 0, "PCSX_INTX_REG(3,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "PCSX_INTX_REG(3,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "PCSX_INTX_REG(3,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, 0, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "PCSXX_INT_REG(1)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "PCSXX_INT_REG(1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSXX_INT_REG(1)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSXX_INT_REG(1)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSXX_INT_REG(1)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "PCSXX_INT_REG(1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "PCSXX_INT_REG(1)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "PCSXX_INT_REG(1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSXX_INT_REG(1)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSXX_INT_REG(1)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSXX_INT_REG(1)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSXX_INT_REG(1)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "PCSXX_INT_REG(1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 50 /* srio0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((0) & 3) * 0x1000000ull /* CVMX_SRIOX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((0) & 3) * 0x1000000ull /* CVMX_SRIOX_INT_ENABLE(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 0, "SRIOX_INT_REG(0)[BAR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 0, "SRIOX_INT_REG(0)[DENY_WR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 0, "SRIOX_INT_REG(0)[SLI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 0, "SRIOX_INT_REG(0)[MCE_RX]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 0, "SRIOX_INT_REG(0)[LOG_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 0, "SRIOX_INT_REG(0)[PHY_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 0, "SRIOX_INT_REG(0)[OMSG_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 0, "SRIOX_INT_REG(0)[PKO_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 0, "SRIOX_INT_REG(0)[RTRY_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 0, "SRIOX_INT_REG(0)[F_ERROR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 22, 0, "SRIOX_INT_REG(0)[MAC_BUF]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 23, 0, "SRIOX_INT_REG(0)[DEGRAD]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 24, 0, "SRIOX_INT_REG(0)[FAIL]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 25, 0, "SRIOX_INT_REG(0)[TTL_TOUT]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 26, 0, "SRIOX_INT_REG(0)[ZERO_PKT]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 0, 0, "SRIOX_INT_REG(0)[BAR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 0, 0, "SRIOX_INT_REG(0)[DENY_WR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 0, 0, "SRIOX_INT_REG(0)[SLI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 0, 0, "SRIOX_INT_REG(0)[MCE_RX]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 0, 0, "SRIOX_INT_REG(0)[LOG_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 0, 0, "SRIOX_INT_REG(0)[PHY_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 0, 0, "SRIOX_INT_REG(0)[OMSG_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 0, 0, "SRIOX_INT_REG(0)[PKO_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 0, 0, "SRIOX_INT_REG(0)[RTRY_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 0, 0, "SRIOX_INT_REG(0)[F_ERROR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 22, 0, 0, "SRIOX_INT_REG(0)[MAC_BUF]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 23, 0, 0, "SRIOX_INT_REG(0)[DEGRAD]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 24, 0, 0, "SRIOX_INT_REG(0)[FAIL]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 25, 0, 0, "SRIOX_INT_REG(0)[TTL_TOUT]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 26, 0, 0, "SRIOX_INT_REG(0)[ZERO_PKT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DPI_INT_REG[SPRT2_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "DPI_INT_REG[SPRT3_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DPI_INT_REG[SPRT2_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "DPI_INT_REG[SPRT3_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -8102,337 +8102,337 @@ static struct cvmx_error_muxchild error_tree_cn52xx =
 					{CVMX_ADD_IO_SEG(0x00011F0000008520ull) /* CVMX_PEXP_NPEI_RSL_INT_BLOCKS */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 						{1, 16 /* l2c */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800800000F8ull) /* CVMX_L2C_INT_STAT */, CVMX_ADD_IO_SEG(0x0001180080000100ull) /* CVMX_L2C_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_STAT[L2TSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_STAT[L2DSEC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_STAT[OOB1]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_STAT[OOB2]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_STAT[OOB3]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_STAT[L2TDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_STAT[L2DDED]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_STAT[LCK]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_INT_STAT[LCK2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2TSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_SBE, "L2C_INT_STAT[L2DSEC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_STAT[OOB1]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_STAT[OOB2]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_STAT[OOB3]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2TDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, CVMX_ERROR_TYPE_DBE, "L2C_INT_STAT[L2DDED]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_STAT[LCK]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_INT_STAT[LCK2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, CVMX_ADD_IO_SEG(0x0001180080000010ull) /* CVMX_L2D_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2D_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2D_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2D_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2D_ERR[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, CVMX_ADD_IO_SEG(0x0001180080000008ull) /* CVMX_L2T_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, "L2T_ERR[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, "L2T_ERR[DED_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, "L2T_ERR[LCKERR]"},
-									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, "L2T_ERR[LCKERR2]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_SBE, "L2T_ERR[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_DBE, "L2T_ERR[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 24, 0, 0, "L2T_ERR[LCKERR]"},
+									{1, 0, CVMX_ERROR_GROUP_L2C, 26, 0, 0, "L2T_ERR[LCKERR2]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 28 /* agl */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, 0, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, 0, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 1 /* gmx0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 0 /* mio */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 9 /* ipd */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 11 /* tim */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 12 /* pow */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+									{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 15 /* usb1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((1) & 1) * 0x10000000ull /* CVMX_USBNX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((1) & 1) * 0x10000000ull /* CVMX_USBNX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 1, "USBNX_INT_SUM(1)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 1, "USBNX_INT_SUM(1)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 1, "USBNX_INT_SUM(1)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 1, "USBNX_INT_SUM(1)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 1, "USBNX_INT_SUM(1)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 1, "USBNX_INT_SUM(1)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 1, "USBNX_INT_SUM(1)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 1, "USBNX_INT_SUM(1)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 1, "USBNX_INT_SUM(1)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 1, "USBNX_INT_SUM(1)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 1, "USBNX_INT_SUM(1)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 1, "USBNX_INT_SUM(1)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 1, "USBNX_INT_SUM(1)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 1, "USBNX_INT_SUM(1)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 1, "USBNX_INT_SUM(1)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 1, "USBNX_INT_SUM(1)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 1, "USBNX_INT_SUM(1)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 1, "USBNX_INT_SUM(1)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 1, "USBNX_INT_SUM(1)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 1, "USBNX_INT_SUM(1)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 1, "USBNX_INT_SUM(1)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 1, "USBNX_INT_SUM(1)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 1, "USBNX_INT_SUM(1)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 1, "USBNX_INT_SUM(1)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 1, "USBNX_INT_SUM(1)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 1, "USBNX_INT_SUM(1)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 1, "USBNX_INT_SUM(1)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 1, "USBNX_INT_SUM(1)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 1, "USBNX_INT_SUM(1)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 1, "USBNX_INT_SUM(1)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 1, "USBNX_INT_SUM(1)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 1, "USBNX_INT_SUM(1)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 1, 0, "USBNX_INT_SUM(1)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 1, 0, "USBNX_INT_SUM(1)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 1, 0, "USBNX_INT_SUM(1)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 1, 0, "USBNX_INT_SUM(1)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 1, 0, "USBNX_INT_SUM(1)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 1, 0, "USBNX_INT_SUM(1)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 1, 0, "USBNX_INT_SUM(1)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 1, 0, "USBNX_INT_SUM(1)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 1, 0, "USBNX_INT_SUM(1)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 1, 0, "USBNX_INT_SUM(1)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 1, 0, "USBNX_INT_SUM(1)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 1, 0, "USBNX_INT_SUM(1)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 1, 0, "USBNX_INT_SUM(1)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 1, 0, "USBNX_INT_SUM(1)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 1, 0, "USBNX_INT_SUM(1)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 1, 0, "USBNX_INT_SUM(1)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 1, 0, "USBNX_INT_SUM(1)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 1, 0, "USBNX_INT_SUM(1)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 1, 0, "USBNX_INT_SUM(1)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 1, 0, "USBNX_INT_SUM(1)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 1, 0, "USBNX_INT_SUM(1)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 1, 0, "USBNX_INT_SUM(1)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 1, 0, "USBNX_INT_SUM(1)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 1, 0, "USBNX_INT_SUM(1)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 1, 0, "USBNX_INT_SUM(1)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 1, 0, "USBNX_INT_SUM(1)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 1, 0, "USBNX_INT_SUM(1)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 1, 0, "USBNX_INT_SUM(1)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 1, 0, "USBNX_INT_SUM(1)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 1, 0, "USBNX_INT_SUM(1)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 1, 0, "USBNX_INT_SUM(1)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 1, 0, "USBNX_INT_SUM(1)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 3 /* npei */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011F0000008530ull) /* CVMX_PEXP_NPEI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F000000BCD0ull) /* CVMX_PEXP_NPEI_INT_ENB2 */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEXP_NPEI_INT_SUM[CRS0_DR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEXP_NPEI_INT_SUM[CRS0_ER]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEXP_NPEI_INT_SUM[C1_SE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEXP_NPEI_INT_SUM[CRS1_DR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEXP_NPEI_INT_SUM[CRS1_ER]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_NPEI_INT_SUM[DMA4DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEXP_NPEI_INT_SUM[C0_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 53, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, 0, "PEXP_NPEI_INT_SUM[C0_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 55, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, 0, "PEXP_NPEI_INT_SUM[C0_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEXP_NPEI_INT_SUM[C0_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEXP_NPEI_INT_SUM[CRS0_DR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEXP_NPEI_INT_SUM[CRS0_ER]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEXP_NPEI_INT_SUM[C1_SE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 48, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 49, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 50, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 52, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 54, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 51, 1, 0, "PEXP_NPEI_INT_SUM[C1_UN_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B0]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B1]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_B2]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 47, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_BX]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 56, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WF]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 46, 1, 0, "PEXP_NPEI_INT_SUM[C1_UP_WI]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEXP_NPEI_INT_SUM[C1_WAKE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEXP_NPEI_INT_SUM[CRS1_DR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEXP_NPEI_INT_SUM[CRS1_ER]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_NPEI_INT_SUM[BAR0_TO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PEXP_NPEI_INT_SUM[DMA0DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PEXP_NPEI_INT_SUM[DMA1DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PEXP_NPEI_INT_SUM[DMA2DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PEXP_NPEI_INT_SUM[DMA3DBO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_NPEI_INT_SUM[IOB2BIG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_NPEI_INT_SUM[RML_RTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PEXP_NPEI_INT_SUM[RML_WTO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_NPEI_INT_SUM[DMA4DBO]"},
 									{0}},
 								(struct cvmx_error_childbit[]){
 								{1, 57 /* c0_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((0) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PESCX_DBG_INFO(0)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PESCX_DBG_INFO(0)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PESCX_DBG_INFO(0)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PESCX_DBG_INFO(0)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PESCX_DBG_INFO(0)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PESCX_DBG_INFO(0)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PESCX_DBG_INFO(0)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PESCX_DBG_INFO(0)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PESCX_DBG_INFO(0)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PESCX_DBG_INFO(0)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PESCX_DBG_INFO(0)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PESCX_DBG_INFO(0)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PESCX_DBG_INFO(0)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PESCX_DBG_INFO(0)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PESCX_DBG_INFO(0)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PESCX_DBG_INFO(0)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PESCX_DBG_INFO(0)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PESCX_DBG_INFO(0)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PESCX_DBG_INFO(0)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PESCX_DBG_INFO(0)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PESCX_DBG_INFO(0)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PESCX_DBG_INFO(0)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PESCX_DBG_INFO(0)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PESCX_DBG_INFO(0)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PESCX_DBG_INFO(0)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PESCX_DBG_INFO(0)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PESCX_DBG_INFO(0)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PESCX_DBG_INFO(0)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PESCX_DBG_INFO(0)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PESCX_DBG_INFO(0)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PESCX_DBG_INFO(0)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PESCX_DBG_INFO(0)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PESCX_DBG_INFO(0)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PESCX_DBG_INFO(0)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PESCX_DBG_INFO(0)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PESCX_DBG_INFO(0)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PESCX_DBG_INFO(0)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PESCX_DBG_INFO(0)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PESCX_DBG_INFO(0)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PESCX_DBG_INFO(0)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PESCX_DBG_INFO(0)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PESCX_DBG_INFO(0)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
 									{0}}},
 								{1, 58 /* c1_exc */, (struct cvmx_error_muxchild[]){
 									{CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((1) & 1) * 0x8000000ull /* CVMX_PESCX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PESCX_DBG_INFO(1)[SPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PESCX_DBG_INFO(1)[RTLPLLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PESCX_DBG_INFO(1)[RECRCE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PESCX_DBG_INFO(1)[RPOISON]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PESCX_DBG_INFO(1)[RCEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PESCX_DBG_INFO(1)[RNFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PESCX_DBG_INFO(1)[RFEMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PESCX_DBG_INFO(1)[RPMERC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PESCX_DBG_INFO(1)[RPTAMRC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PESCX_DBG_INFO(1)[RUMEP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PESCX_DBG_INFO(1)[RVDM]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PESCX_DBG_INFO(1)[ACTO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PESCX_DBG_INFO(1)[RTE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PESCX_DBG_INFO(1)[MRE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PESCX_DBG_INFO(1)[RDWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PESCX_DBG_INFO(1)[RTWDLE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PESCX_DBG_INFO(1)[DPEOOSD]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PESCX_DBG_INFO(1)[FCPVWT]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PESCX_DBG_INFO(1)[RPE]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PESCX_DBG_INFO(1)[FCUV]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PESCX_DBG_INFO(1)[RQO]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PESCX_DBG_INFO(1)[RAUC]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PESCX_DBG_INFO(1)[RACUR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PESCX_DBG_INFO(1)[RACCA]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PESCX_DBG_INFO(1)[CAAR]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PESCX_DBG_INFO(1)[RARWDNS]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PESCX_DBG_INFO(1)[RAMTLP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PESCX_DBG_INFO(1)[RACPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PESCX_DBG_INFO(1)[RAWWPP]"},
-											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PESCX_DBG_INFO(1)[ECRC_E]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PESCX_DBG_INFO(1)[SPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PESCX_DBG_INFO(1)[RTLPLLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PESCX_DBG_INFO(1)[RECRCE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PESCX_DBG_INFO(1)[RPOISON]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PESCX_DBG_INFO(1)[RCEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PESCX_DBG_INFO(1)[RNFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PESCX_DBG_INFO(1)[RFEMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PESCX_DBG_INFO(1)[RPMERC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PESCX_DBG_INFO(1)[RPTAMRC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PESCX_DBG_INFO(1)[RUMEP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PESCX_DBG_INFO(1)[RVDM]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PESCX_DBG_INFO(1)[ACTO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PESCX_DBG_INFO(1)[RTE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PESCX_DBG_INFO(1)[MRE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PESCX_DBG_INFO(1)[RDWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PESCX_DBG_INFO(1)[RTWDLE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PESCX_DBG_INFO(1)[DPEOOSD]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PESCX_DBG_INFO(1)[FCPVWT]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PESCX_DBG_INFO(1)[RPE]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PESCX_DBG_INFO(1)[FCUV]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PESCX_DBG_INFO(1)[RQO]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PESCX_DBG_INFO(1)[RAUC]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PESCX_DBG_INFO(1)[RACUR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PESCX_DBG_INFO(1)[RACCA]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PESCX_DBG_INFO(1)[CAAR]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PESCX_DBG_INFO(1)[RARWDNS]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PESCX_DBG_INFO(1)[RAMTLP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PESCX_DBG_INFO(1)[RACPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PESCX_DBG_INFO(1)[RAWWPP]"},
+											{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PESCX_DBG_INFO(1)[ECRC_E]"},
 											{0}},
 										NULL /*cvmx_error_childbit*/
 									},
@@ -8442,181 +8442,181 @@ static struct cvmx_error_muxchild error_tree_cn52xx =
 							{0}}},
 						{1, 14 /* rad */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 10 /* pko */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 22 /* asxpcs0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+									{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 20 /* pip */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 5 /* fpa */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 17 /* lmc0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, CVMX_ADD_IO_SEG(0x0001180088000000ull) /* CVMX_LMCX_MEM_CFG0(0) */, (struct cvmx_error_regbit[]){
-									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
-									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, "LMCX_MEM_CFG0(0)[DED_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 21, 0, CVMX_ERROR_TYPE_SBE, "LMCX_MEM_CFG0(0)[SEC_ERR]"},
+									{1, 0, CVMX_ERROR_GROUP_LMC, 25, 0, CVMX_ERROR_TYPE_DBE, "LMCX_MEM_CFG0(0)[DED_ERR]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 30 /* iob */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+									{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 13 /* usb */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180068000000ull) + ((0) & 1) * 0x10000000ull /* CVMX_USBNX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x0001180068000008ull) + ((0) & 1) * 0x10000000ull /* CVMX_USBNX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
-									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "USBNX_INT_SUM(0)[PR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "USBNX_INT_SUM(0)[PR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "USBNX_INT_SUM(0)[NR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "USBNX_INT_SUM(0)[NR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "USBNX_INT_SUM(0)[LR_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "USBNX_INT_SUM(0)[LR_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "USBNX_INT_SUM(0)[PT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "USBNX_INT_SUM(0)[PT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 8, 0, 0, "USBNX_INT_SUM(0)[NT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 9, 0, 0, "USBNX_INT_SUM(0)[NT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 10, 0, 0, "USBNX_INT_SUM(0)[LT_PO_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 11, 0, 0, "USBNX_INT_SUM(0)[LT_PU_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 12, 0, 0, "USBNX_INT_SUM(0)[DCRED_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 13, 0, 0, "USBNX_INT_SUM(0)[DCRED_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 14, 0, 0, "USBNX_INT_SUM(0)[L2C_S_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 15, 0, 0, "USBNX_INT_SUM(0)[L2C_A_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 16, 0, 0, "USBNX_INT_SUM(0)[LT_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 17, 0, 0, "USBNX_INT_SUM(0)[LT_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 18, 0, 0, "USBNX_INT_SUM(0)[RG_FI_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 19, 0, 0, "USBNX_INT_SUM(0)[RG_FI_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 20, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 21, 0, 0, "USBNX_INT_SUM(0)[RQ_Q2_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 22, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_F]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 23, 0, 0, "USBNX_INT_SUM(0)[RQ_Q3_E]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 24, 0, 0, "USBNX_INT_SUM(0)[UOD_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 25, 0, 0, "USBNX_INT_SUM(0)[UOD_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 32, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 33, 0, 0, "USBNX_INT_SUM(0)[LTL_F_PF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 34, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 35, 0, 0, "USBNX_INT_SUM(0)[ND4O_RPF]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 36, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPE]"},
+									{1, 1, CVMX_ERROR_GROUP_USB, 37, 0, 0, "USBNX_INT_SUM(0)[ND4O_DPF]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -8629,11 +8629,11 @@ static struct cvmx_error_muxchild error_tree_cn52xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 19 /* nand */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "NDF_INT[WDOG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "NDF_INT[SM_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "NDF_INT[ECC_1BIT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "NDF_INT[ECC_MULT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "NDF_INT[OVRF]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -8649,7 +8649,7 @@ static struct cvmx_error_muxchild error_tree_cn61xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -8659,42 +8659,42 @@ static struct cvmx_error_muxchild error_tree_cn61xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_REG[BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_REG[BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_INT_REG[BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_REG[BIGRD]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_TADX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_TADX_IEN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_TADX_INT(0)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_TADX_INT(0)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_TADX_INT(0)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_TADX_INT(0)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_TADX_INT(0)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_TADX_INT(0)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_TADX_INT(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_TADX_INT(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_ERR_TDTX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, "L2C_ERR_TDTX(0)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TDTX(0)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TDTX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TDTX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_ERR_TTGX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TTGX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TTGX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -8704,105 +8704,105 @@ static struct cvmx_error_muxchild error_tree_cn61xx =
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -8812,50 +8812,50 @@ static struct cvmx_error_muxchild error_tree_cn61xx =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -8865,534 +8865,534 @@ static struct cvmx_error_muxchild error_tree_cn61xx =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* usb */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "DFA_ERROR[DLC0_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DFA_ERROR[DFANXM]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DFA_ERROR[REPLERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "DFA_ERROR[DLC0_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DFA_ERROR[DFANXM]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DFA_ERROR[REPLERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((0) & 0) * 0x1000000ull /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((0) & 0) * 0x1000000ull /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 46 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, 0, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, 0, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 28 /* zip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 37 /* agx1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, 0, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, 0, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, 0, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, 0, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, 0, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, 0, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSX_INTX_REG(0,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "PCSX_INTX_REG(0,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, 0, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "PCSX_INTX_REG(1,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, "PCSX_INTX_REG(1,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, "PCSX_INTX_REG(1,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "PCSX_INTX_REG(1,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, "PCSX_INTX_REG(1,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "PCSX_INTX_REG(1,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "PCSX_INTX_REG(1,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "PCSX_INTX_REG(1,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "PCSX_INTX_REG(1,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, 0, "PCSX_INTX_REG(1,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "PCSX_INTX_REG(1,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "PCSX_INTX_REG(1,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, 0, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "PCSX_INTX_REG(2,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, "PCSX_INTX_REG(2,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, "PCSX_INTX_REG(2,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "PCSX_INTX_REG(2,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, "PCSX_INTX_REG(2,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "PCSX_INTX_REG(2,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "PCSX_INTX_REG(2,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "PCSX_INTX_REG(2,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "PCSX_INTX_REG(2,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, 0, "PCSX_INTX_REG(2,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "PCSX_INTX_REG(2,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "PCSX_INTX_REG(2,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, 0, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "PCSX_INTX_REG(3,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, "PCSX_INTX_REG(3,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, "PCSX_INTX_REG(3,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "PCSX_INTX_REG(3,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, "PCSX_INTX_REG(3,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "PCSX_INTX_REG(3,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "PCSX_INTX_REG(3,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "PCSX_INTX_REG(3,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "PCSX_INTX_REG(3,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, 0, "PCSX_INTX_REG(3,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "PCSX_INTX_REG(3,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "PCSX_INTX_REG(3,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, 0, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 1) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "PCSXX_INT_REG(1)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "PCSXX_INT_REG(1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSXX_INT_REG(1)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSXX_INT_REG(1)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSXX_INT_REG(1)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, "PCSXX_INT_REG(1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "PCSXX_INT_REG(1)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "PCSXX_INT_REG(1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSXX_INT_REG(1)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSXX_INT_REG(1)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSXX_INT_REG(1)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSXX_INT_REG(1)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 16, 0, "PCSXX_INT_REG(1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DPI_INT_REG[SPRT2_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "DPI_INT_REG[SPRT3_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DPI_INT_REG[SPRT2_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "DPI_INT_REG[SPRT3_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -9408,7 +9408,7 @@ static struct cvmx_error_muxchild error_tree_cnf71xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -9418,42 +9418,42 @@ static struct cvmx_error_muxchild error_tree_cnf71xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_REG[BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_REG[BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_INT_REG[BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_REG[BIGRD]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_TADX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_TADX_IEN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_TADX_INT(0)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_TADX_INT(0)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_TADX_INT(0)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_TADX_INT(0)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_TADX_INT(0)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_TADX_INT(0)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_TADX_INT(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_TADX_INT(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_ERR_TDTX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, "L2C_ERR_TDTX(0)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TDTX(0)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TDTX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TDTX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((0) & 0) * 0x40000ull /* CVMX_L2C_ERR_TTGX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TTGX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TTGX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -9463,50 +9463,50 @@ static struct cvmx_error_muxchild error_tree_cnf71xx =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -9516,217 +9516,217 @@ static struct cvmx_error_muxchild error_tree_cnf71xx =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 1) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 1) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 1) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 1) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 1) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 1) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 1) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 1) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -9736,159 +9736,159 @@ static struct cvmx_error_muxchild error_tree_cnf71xx =
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* usb */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((0) & 0) * 0x1000000ull /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((0) & 0) * 0x1000000ull /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DPI_INT_REG[SPRT2_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "DPI_INT_REG[SPRT3_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DPI_INT_REG[SPRT2_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "DPI_INT_REG[SPRT3_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -9904,7 +9904,7 @@ static struct cvmx_error_muxchild error_tree_cn70xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -9914,149 +9914,149 @@ static struct cvmx_error_muxchild error_tree_cn70xxp1 =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000107000000E000ull) /* CVMX_CIU_CIB_L2C_RAWX(0) */, CVMX_ADD_IO_SEG(0x000107000000E100ull) /* CVMX_CIU_CIB_L2C_ENX(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_NOWAY]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 9, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 10, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 11, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 12, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGRD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 13, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_WRDISLMC]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 14, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RDDISLMC]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 15, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 16, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 17, 0, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 18, 0, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 19, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 20, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 21, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 22, 0, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_L2DDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_SBFDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_FBFDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_TAGDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_NOWAY]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 9, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 10, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 11, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 12, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 13, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_WRDISLMC]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 14, 0, 0, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RDDISLMC]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 15, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 16, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[TADX_INT_RTGDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 17, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 18, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[MCIX_INT_VBFDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 19, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 20, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_RSDDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 21, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 22, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_L2C_RAWX(0)[CBCX_INT_IOCCMDDBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 50 /* pem2 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_INT_SUM(2) */, CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_INT_ENB(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 2, "PEMX_INT_SUM(2)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, "PEMX_INT_SUM(2)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, "PEMX_INT_SUM(2)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, "PEMX_INT_SUM(2)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, "PEMX_INT_SUM(2)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, "PEMX_INT_SUM(2)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, "PEMX_INT_SUM(2)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, "PEMX_INT_SUM(2)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, "PEMX_INT_SUM(2)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, "PEMX_INT_SUM(2)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 2, 0, "PEMX_INT_SUM(2)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, 0, "PEMX_INT_SUM(2)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, 0, "PEMX_INT_SUM(2)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, 0, "PEMX_INT_SUM(2)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, 0, "PEMX_INT_SUM(2)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, 0, "PEMX_INT_SUM(2)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, 0, "PEMX_INT_SUM(2)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, 0, "PEMX_INT_SUM(2)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, 0, "PEMX_INT_SUM(2)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, 0, "PEMX_INT_SUM(2)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(2) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((2) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(2) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 2, "PEMX_DBG_INFO(2)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 2, "PEMX_DBG_INFO(2)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 2, "PEMX_DBG_INFO(2)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, "PEMX_DBG_INFO(2)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, "PEMX_DBG_INFO(2)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, "PEMX_DBG_INFO(2)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, "PEMX_DBG_INFO(2)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, "PEMX_DBG_INFO(2)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, "PEMX_DBG_INFO(2)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 2, "PEMX_DBG_INFO(2)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, "PEMX_DBG_INFO(2)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, "PEMX_DBG_INFO(2)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, "PEMX_DBG_INFO(2)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 2, "PEMX_DBG_INFO(2)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 2, "PEMX_DBG_INFO(2)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 2, "PEMX_DBG_INFO(2)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 2, "PEMX_DBG_INFO(2)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 2, "PEMX_DBG_INFO(2)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 2, "PEMX_DBG_INFO(2)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 2, "PEMX_DBG_INFO(2)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 2, "PEMX_DBG_INFO(2)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 2, "PEMX_DBG_INFO(2)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 2, "PEMX_DBG_INFO(2)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 2, "PEMX_DBG_INFO(2)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 2, "PEMX_DBG_INFO(2)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 2, "PEMX_DBG_INFO(2)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 2, "PEMX_DBG_INFO(2)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 2, "PEMX_DBG_INFO(2)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 2, "PEMX_DBG_INFO(2)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 2, "PEMX_DBG_INFO(2)[ECRC_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 2, "PEMX_DBG_INFO(2)[RTRY_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 2, "PEMX_DBG_INFO(2)[HDRQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 2, "PEMX_DBG_INFO(2)[DATQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 2, "PEMX_DBG_INFO(2)[P_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 2, "PEMX_DBG_INFO(2)[P_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 2, "PEMX_DBG_INFO(2)[P_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 2, "PEMX_DBG_INFO(2)[P_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 2, "PEMX_DBG_INFO(2)[N_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 2, "PEMX_DBG_INFO(2)[N_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 2, "PEMX_DBG_INFO(2)[N_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 2, "PEMX_DBG_INFO(2)[N_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 2, "PEMX_DBG_INFO(2)[C_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 2, "PEMX_DBG_INFO(2)[C_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 2, "PEMX_DBG_INFO(2)[C_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 2, "PEMX_DBG_INFO(2)[C_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 2, 0, "PEMX_DBG_INFO(2)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 2, 0, "PEMX_DBG_INFO(2)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 2, 0, "PEMX_DBG_INFO(2)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 2, 0, "PEMX_DBG_INFO(2)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 2, 0, "PEMX_DBG_INFO(2)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 2, 0, "PEMX_DBG_INFO(2)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 2, 0, "PEMX_DBG_INFO(2)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 2, 0, "PEMX_DBG_INFO(2)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 2, 0, "PEMX_DBG_INFO(2)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 2, 0, "PEMX_DBG_INFO(2)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 2, 0, "PEMX_DBG_INFO(2)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 2, 0, "PEMX_DBG_INFO(2)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 2, 0, "PEMX_DBG_INFO(2)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 2, 0, "PEMX_DBG_INFO(2)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 2, 0, "PEMX_DBG_INFO(2)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 2, 0, "PEMX_DBG_INFO(2)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 2, 0, "PEMX_DBG_INFO(2)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 2, 0, "PEMX_DBG_INFO(2)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 2, 0, "PEMX_DBG_INFO(2)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 2, 0, "PEMX_DBG_INFO(2)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 2, 0, "PEMX_DBG_INFO(2)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 2, 0, "PEMX_DBG_INFO(2)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 2, 0, "PEMX_DBG_INFO(2)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 2, 0, "PEMX_DBG_INFO(2)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 2, 0, "PEMX_DBG_INFO(2)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 2, 0, "PEMX_DBG_INFO(2)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 2, 0, "PEMX_DBG_INFO(2)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 2, 0, "PEMX_DBG_INFO(2)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 2, 0, "PEMX_DBG_INFO(2)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 2, 0, "PEMX_DBG_INFO(2)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 2, 0, "PEMX_DBG_INFO(2)[RTRY_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 2, 0, "PEMX_DBG_INFO(2)[HDRQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 2, 0, "PEMX_DBG_INFO(2)[DATQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[P_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[P_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[P_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[P_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[N_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[N_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[N_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[N_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[C_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[C_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 2, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(2)[C_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 2, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(2)[C_C_DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -10066,65 +10066,65 @@ static struct cvmx_error_muxchild error_tree_cn70xxp1 =
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, "PEMX_DBG_INFO(0)[RTRY_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, "PEMX_DBG_INFO(0)[HDRQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, "PEMX_DBG_INFO(0)[DATQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, "PEMX_DBG_INFO(0)[P_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, "PEMX_DBG_INFO(0)[P_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, "PEMX_DBG_INFO(0)[P_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, "PEMX_DBG_INFO(0)[P_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, "PEMX_DBG_INFO(0)[N_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, "PEMX_DBG_INFO(0)[N_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, "PEMX_DBG_INFO(0)[N_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, "PEMX_DBG_INFO(0)[N_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, "PEMX_DBG_INFO(0)[C_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, "PEMX_DBG_INFO(0)[C_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, "PEMX_DBG_INFO(0)[C_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, "PEMX_DBG_INFO(0)[C_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 0, 0, "PEMX_DBG_INFO(0)[RTRY_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 0, 0, "PEMX_DBG_INFO(0)[HDRQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 0, 0, "PEMX_DBG_INFO(0)[DATQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[P_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[P_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[P_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[P_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[N_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[N_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[N_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[N_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[C_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[C_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 0, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(0)[C_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 0, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(0)[C_C_DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -10134,65 +10134,65 @@ static struct cvmx_error_muxchild error_tree_cn70xxp1 =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000430ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 3) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 1, "PEMX_DBG_INFO(1)[RTRY_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 1, "PEMX_DBG_INFO(1)[HDRQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 1, "PEMX_DBG_INFO(1)[DATQ_PE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 1, "PEMX_DBG_INFO(1)[P_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 1, "PEMX_DBG_INFO(1)[P_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 1, "PEMX_DBG_INFO(1)[P_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 1, "PEMX_DBG_INFO(1)[P_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 1, "PEMX_DBG_INFO(1)[N_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 1, "PEMX_DBG_INFO(1)[N_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 1, "PEMX_DBG_INFO(1)[N_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 1, "PEMX_DBG_INFO(1)[N_C_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 1, "PEMX_DBG_INFO(1)[C_D_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, "PEMX_DBG_INFO(1)[C_D_DBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, "PEMX_DBG_INFO(1)[C_C_SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, "PEMX_DBG_INFO(1)[C_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 31, 1, 0, "PEMX_DBG_INFO(1)[RTRY_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 32, 1, 0, "PEMX_DBG_INFO(1)[HDRQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 33, 1, 0, "PEMX_DBG_INFO(1)[DATQ_PE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 34, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[P_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 35, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[P_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 36, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[P_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 37, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[P_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 38, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[N_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 39, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[N_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 40, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[N_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 41, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[N_C_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 42, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[C_D_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 43, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[C_D_DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 44, 1, CVMX_ERROR_TYPE_SBE, "PEMX_DBG_INFO(1)[C_C_SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 45, 1, CVMX_ERROR_TYPE_DBE, "PEMX_DBG_INFO(1)[C_C_DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -10202,495 +10202,495 @@ static struct cvmx_error_muxchild error_tree_cn70xxp1 =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "DFA_ERROR[DLC0_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DFA_ERROR[DFANXM]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DFA_ERROR[REPLERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "DFA_ERROR[DLC0_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DFA_ERROR[DFANXM]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DFA_ERROR[REPLERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000107000000E200ull) /* CVMX_CIU_CIB_LMCX_RAWX(0,0) */, CVMX_ADD_IO_SEG(0x000107000000E300ull) /* CVMX_CIU_CIB_LMCX_ENX(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_SEC_ERRX]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_DED_ERRX]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "CIU_CIB_LMCX_RAWX(0,0)[INT_SEC_ERRX]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "CIU_CIB_LMCX_RAWX(0,0)[INT_DED_ERRX]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "CIU_CIB_LMCX_RAWX(0,0)[INT_NXM_WR_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "KEY_INT_SUM[KEY_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "KEY_INT_SUM[KEY_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "KEY_INT_SUM[KEY_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "KEY_INT_SUM[KEY_DBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000107000000E400ull) /* CVMX_CIU_CIB_RST_RAWX(0) */, CVMX_ADD_IO_SEG(0x000107000000E500ull) /* CVMX_CIU_CIB_RST_ENX(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "CIU_CIB_RST_RAWX(0)[INT_LINKX]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "CIU_CIB_RST_RAWX(0)[INT_PERSTX]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "CIU_CIB_RST_RAWX(0)[INT_LINKX]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "CIU_CIB_RST_RAWX(0)[INT_PERSTX]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 46 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 0, "GMXX_RXX_INT_REG(0,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 0, 0, "GMXX_RXX_INT_REG(0,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 1, "GMXX_RXX_INT_REG(1,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 1, 0, "GMXX_RXX_INT_REG(1,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 2, "GMXX_RXX_INT_REG(2,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 2, 0, "GMXX_RXX_INT_REG(2,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 3, "GMXX_RXX_INT_REG(3,0)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 3, 0, "GMXX_RXX_INT_REG(3,0)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 37 /* agx1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_BAD_REG(1) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_BAD_REG(1)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_BAD_REG(1)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_BAD_REG(1)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_BAD_REG(1)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_BAD_REG(1)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_BAD_REG(1)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_BAD_REG(1)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_BAD_REG(1)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 16, "GMXX_RXX_INT_REG(0,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 16, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 16, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 16, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 16, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 16, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 16, 0, "GMXX_RXX_INT_REG(0,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 17, "GMXX_RXX_INT_REG(1,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 17, 0, "GMXX_RXX_INT_REG(1,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "GMXX_RXX_INT_REG(1,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "GMXX_RXX_INT_REG(1,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 17, 0, "GMXX_RXX_INT_REG(1,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 17, 0, "GMXX_RXX_INT_REG(1,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 17, 0, "GMXX_RXX_INT_REG(1,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 17, 0, "GMXX_RXX_INT_REG(1,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 17, 0, "GMXX_RXX_INT_REG(1,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 17, 0, "GMXX_RXX_INT_REG(1,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 18, "GMXX_RXX_INT_REG(2,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 18, 0, "GMXX_RXX_INT_REG(2,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "GMXX_RXX_INT_REG(2,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "GMXX_RXX_INT_REG(2,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 18, 0, "GMXX_RXX_INT_REG(2,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 18, 0, "GMXX_RXX_INT_REG(2,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 18, 0, "GMXX_RXX_INT_REG(2,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 18, 0, "GMXX_RXX_INT_REG(2,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 18, 0, "GMXX_RXX_INT_REG(2,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 18, 0, "GMXX_RXX_INT_REG(2,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((1) & 1) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 19, "GMXX_RXX_INT_REG(3,1)[WOL]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 19, 0, "GMXX_RXX_INT_REG(3,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "GMXX_RXX_INT_REG(3,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "GMXX_RXX_INT_REG(3,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 19, 0, "GMXX_RXX_INT_REG(3,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 19, 0, "GMXX_RXX_INT_REG(3,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 19, 0, "GMXX_RXX_INT_REG(3,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 19, 0, "GMXX_RXX_INT_REG(3,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 19, 0, "GMXX_RXX_INT_REG(3,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 29, 19, 0, "GMXX_RXX_INT_REG(3,1)[WOL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 1) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "GMXX_TX_INT_REG(1)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 16, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 16, 0, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, "PCSX_INTX_REG(0,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, "PCSX_INTX_REG(0,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 16, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 16, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 16, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 16, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 16, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 16, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 16, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 16, 0, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, "PCSX_INTX_REG(1,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, "PCSX_INTX_REG(1,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, "PCSX_INTX_REG(1,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, "PCSX_INTX_REG(1,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, "PCSX_INTX_REG(1,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, "PCSX_INTX_REG(1,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, "PCSX_INTX_REG(1,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 17, 0, "PCSX_INTX_REG(1,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 17, 0, "PCSX_INTX_REG(1,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 17, 0, "PCSX_INTX_REG(1,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 17, 0, "PCSX_INTX_REG(1,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 17, 0, "PCSX_INTX_REG(1,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 17, 0, "PCSX_INTX_REG(1,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 17, 0, "PCSX_INTX_REG(1,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 17, 0, "PCSX_INTX_REG(1,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, "PCSX_INTX_REG(2,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, "PCSX_INTX_REG(2,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, "PCSX_INTX_REG(2,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, "PCSX_INTX_REG(2,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, "PCSX_INTX_REG(2,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, "PCSX_INTX_REG(2,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, "PCSX_INTX_REG(2,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 18, 0, "PCSX_INTX_REG(2,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 18, 0, "PCSX_INTX_REG(2,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 18, 0, "PCSX_INTX_REG(2,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 18, 0, "PCSX_INTX_REG(2,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 18, 0, "PCSX_INTX_REG(2,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 18, 0, "PCSX_INTX_REG(2,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 18, 0, "PCSX_INTX_REG(2,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 18, 0, "PCSX_INTX_REG(2,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((1) & 1) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, "PCSX_INTX_REG(3,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, "PCSX_INTX_REG(3,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, "PCSX_INTX_REG(3,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, "PCSX_INTX_REG(3,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, "PCSX_INTX_REG(3,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, "PCSX_INTX_REG(3,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, "PCSX_INTX_REG(3,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 19, 0, "PCSX_INTX_REG(3,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 19, 0, "PCSX_INTX_REG(3,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 19, 0, "PCSX_INTX_REG(3,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 19, 0, "PCSX_INTX_REG(3,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 19, 0, "PCSX_INTX_REG(3,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 19, 0, "PCSX_INTX_REG(3,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 19, 0, "PCSX_INTX_REG(3,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 19, 0, "PCSX_INTX_REG(3,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "PEXP_SLI_INT_SUM[M2_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "PEXP_SLI_INT_SUM[M2_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "PEXP_SLI_INT_SUM[M3_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "PEXP_SLI_INT_SUM[M3_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 58, 0, 0, "PEXP_SLI_INT_SUM[SPRT2_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 59, 0, 0, "PEXP_SLI_INT_SUM[SPRT3_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "DPI_INT_REG[SPRT2_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "DPI_INT_REG[SPRT3_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "DPI_INT_REG[SPRT2_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "DPI_INT_REG[SPRT3_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -10706,7 +10706,7 @@ static struct cvmx_error_muxchild error_tree_cn63xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "POW_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -10716,27 +10716,27 @@ static struct cvmx_error_muxchild error_tree_cn63xx =
 			{CVMX_ADD_IO_SEG(0x0001070000000108ull) /* CVMX_CIU_INT_SUM1 */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 24 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_REG[BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_REG[BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_INT_REG[BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_REG[BIGRD]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) /* CVMX_L2C_TADX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) /* CVMX_L2C_TADX_IEN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_TADX_INT(0)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_TADX_INT(0)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_TADX_INT(0)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_TADX_INT(0)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_TADX_INT(0)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_TADX_INT(0)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_TADX_INT(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_TADX_INT(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -10746,105 +10746,105 @@ static struct cvmx_error_muxchild error_tree_cn63xx =
 					{0}}},
 				{1, 25 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 23 /* pow */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, CVMX_ADD_IO_SEG(0x0001670000000218ull) /* CVMX_POW_ECC_ERR */, (struct cvmx_error_regbit[]){
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_ECC_ERR[SBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "POW_ECC_ERR[DBE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "POW_ECC_ERR[RPE]"},
-							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "POW_ECC_ERR[IOP]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "POW_ECC_ERR[SBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "POW_ECC_ERR[DBE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "POW_ECC_ERR[RPE]"},
+							{1, 0, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "POW_ECC_ERR[IOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 26 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 27 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* pem0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(0) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, "PEMX_INT_SUM(0)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_INT_SUM(0)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_INT_SUM(0)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_INT_SUM(0)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_INT_SUM(0)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_INT_SUM(0)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_INT_SUM(0)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_INT_SUM(0)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 0, 0, "PEMX_INT_SUM(0)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_INT_SUM(0)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_INT_SUM(0)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_INT_SUM(0)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_INT_SUM(0)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_INT_SUM(0)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_INT_SUM(0)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_INT_SUM(0)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_INT_SUM(0)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_INT_SUM(0)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(0) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((0) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, "PEMX_DBG_INFO(0)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, "PEMX_DBG_INFO(0)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, "PEMX_DBG_INFO(0)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, "PEMX_DBG_INFO(0)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, "PEMX_DBG_INFO(0)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, "PEMX_DBG_INFO(0)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, "PEMX_DBG_INFO(0)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, "PEMX_DBG_INFO(0)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, "PEMX_DBG_INFO(0)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, "PEMX_DBG_INFO(0)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, "PEMX_DBG_INFO(0)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, "PEMX_DBG_INFO(0)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 0, 0, "PEMX_DBG_INFO(0)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 0, 0, "PEMX_DBG_INFO(0)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 0, 0, "PEMX_DBG_INFO(0)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 0, 0, "PEMX_DBG_INFO(0)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 0, 0, "PEMX_DBG_INFO(0)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 0, 0, "PEMX_DBG_INFO(0)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 0, 0, "PEMX_DBG_INFO(0)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 0, 0, "PEMX_DBG_INFO(0)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 0, 0, "PEMX_DBG_INFO(0)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 0, 0, "PEMX_DBG_INFO(0)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 0, 0, "PEMX_DBG_INFO(0)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 0, 0, "PEMX_DBG_INFO(0)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 0, 0, "PEMX_DBG_INFO(0)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 0, 0, "PEMX_DBG_INFO(0)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 0, 0, "PEMX_DBG_INFO(0)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 0, 0, "PEMX_DBG_INFO(0)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 0, 0, "PEMX_DBG_INFO(0)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 0, 0, "PEMX_DBG_INFO(0)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 0, 0, "PEMX_DBG_INFO(0)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 0, 0, "PEMX_DBG_INFO(0)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 0, 0, "PEMX_DBG_INFO(0)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 0, 0, "PEMX_DBG_INFO(0)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 0, 0, "PEMX_DBG_INFO(0)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 0, 0, "PEMX_DBG_INFO(0)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 0, 0, "PEMX_DBG_INFO(0)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 0, 0, "PEMX_DBG_INFO(0)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 0, 0, "PEMX_DBG_INFO(0)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 0, 0, "PEMX_DBG_INFO(0)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 0, 0, "PEMX_DBG_INFO(0)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 0, 0, "PEMX_DBG_INFO(0)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -10854,50 +10854,50 @@ static struct cvmx_error_muxchild error_tree_cn63xx =
 					{0}}},
 				{1, 49 /* pem1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_SUM(1) */, CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_INT_ENB(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, "PEMX_INT_SUM(1)[SE]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_INT_SUM(1)[UP_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_INT_SUM(1)[UP_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_INT_SUM(1)[UP_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_INT_SUM(1)[UN_B1]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_INT_SUM(1)[UN_B2]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_INT_SUM(1)[UN_BX]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_INT_SUM(1)[RDLK]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_INT_SUM(1)[CRS_ER]"},
-							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_INT_SUM(1)[CRS_DR]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 1, 1, 0, "PEMX_INT_SUM(1)[SE]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_INT_SUM(1)[UP_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_INT_SUM(1)[UP_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_INT_SUM(1)[UP_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_INT_SUM(1)[UN_B1]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_INT_SUM(1)[UN_B2]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_INT_SUM(1)[UN_BX]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_INT_SUM(1)[RDLK]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_INT_SUM(1)[CRS_ER]"},
+							{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_INT_SUM(1)[CRS_DR]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 10 /* exc */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO(1) */, CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((1) & 1) * 0x1000000ull /* CVMX_PEMX_DBG_INFO_EN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, "PEMX_DBG_INFO(1)[SPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, "PEMX_DBG_INFO(1)[RTLPLLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, "PEMX_DBG_INFO(1)[RECRCE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, "PEMX_DBG_INFO(1)[RPOISON]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, "PEMX_DBG_INFO(1)[RCEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, "PEMX_DBG_INFO(1)[RNFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, "PEMX_DBG_INFO(1)[RFEMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, "PEMX_DBG_INFO(1)[RPMERC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, "PEMX_DBG_INFO(1)[RPTAMRC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, "PEMX_DBG_INFO(1)[RUMEP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, "PEMX_DBG_INFO(1)[RVDM]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, "PEMX_DBG_INFO(1)[ACTO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, "PEMX_DBG_INFO(1)[RTE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, "PEMX_DBG_INFO(1)[MRE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, "PEMX_DBG_INFO(1)[RDWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, "PEMX_DBG_INFO(1)[RTWDLE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, "PEMX_DBG_INFO(1)[DPEOOSD]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, "PEMX_DBG_INFO(1)[FCPVWT]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, "PEMX_DBG_INFO(1)[RPE]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, "PEMX_DBG_INFO(1)[FCUV]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, "PEMX_DBG_INFO(1)[RQO]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, "PEMX_DBG_INFO(1)[RAUC]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, "PEMX_DBG_INFO(1)[RACUR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, "PEMX_DBG_INFO(1)[RACCA]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, "PEMX_DBG_INFO(1)[CAAR]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, "PEMX_DBG_INFO(1)[RARWDNS]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, "PEMX_DBG_INFO(1)[RAMTLP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, "PEMX_DBG_INFO(1)[RACPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, "PEMX_DBG_INFO(1)[RAWWPP]"},
-									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, "PEMX_DBG_INFO(1)[ECRC_E]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 0, 1, 0, "PEMX_DBG_INFO(1)[SPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 2, 1, 0, "PEMX_DBG_INFO(1)[RTLPLLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 3, 1, 0, "PEMX_DBG_INFO(1)[RECRCE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 4, 1, 0, "PEMX_DBG_INFO(1)[RPOISON]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 5, 1, 0, "PEMX_DBG_INFO(1)[RCEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 6, 1, 0, "PEMX_DBG_INFO(1)[RNFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 7, 1, 0, "PEMX_DBG_INFO(1)[RFEMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 8, 1, 0, "PEMX_DBG_INFO(1)[RPMERC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 9, 1, 0, "PEMX_DBG_INFO(1)[RPTAMRC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 10, 1, 0, "PEMX_DBG_INFO(1)[RUMEP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 11, 1, 0, "PEMX_DBG_INFO(1)[RVDM]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 12, 1, 0, "PEMX_DBG_INFO(1)[ACTO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 13, 1, 0, "PEMX_DBG_INFO(1)[RTE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 14, 1, 0, "PEMX_DBG_INFO(1)[MRE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 15, 1, 0, "PEMX_DBG_INFO(1)[RDWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 16, 1, 0, "PEMX_DBG_INFO(1)[RTWDLE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 17, 1, 0, "PEMX_DBG_INFO(1)[DPEOOSD]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 18, 1, 0, "PEMX_DBG_INFO(1)[FCPVWT]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 19, 1, 0, "PEMX_DBG_INFO(1)[RPE]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 20, 1, 0, "PEMX_DBG_INFO(1)[FCUV]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 21, 1, 0, "PEMX_DBG_INFO(1)[RQO]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 22, 1, 0, "PEMX_DBG_INFO(1)[RAUC]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 23, 1, 0, "PEMX_DBG_INFO(1)[RACUR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 24, 1, 0, "PEMX_DBG_INFO(1)[RACCA]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 25, 1, 0, "PEMX_DBG_INFO(1)[CAAR]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 26, 1, 0, "PEMX_DBG_INFO(1)[RARWDNS]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 27, 1, 0, "PEMX_DBG_INFO(1)[RAMTLP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 28, 1, 0, "PEMX_DBG_INFO(1)[RACPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 29, 1, 0, "PEMX_DBG_INFO(1)[RAWWPP]"},
+									{1, 1, CVMX_ERROR_GROUP_PCI, 30, 1, 0, "PEMX_DBG_INFO(1)[ECRC_E]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -10907,435 +10907,435 @@ static struct cvmx_error_muxchild error_tree_cn63xx =
 					{0}}},
 				{1, 22 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* usb */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 20 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 19 /* nand */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "NDF_INT[WDOG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "NDF_INT[SM_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "NDF_INT[ECC_1BIT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "NDF_INT[ECC_MULT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "NDF_INT[OVRF]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 56 /* dfm */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800D4000408ull) /* CVMX_DFM_FNT_STAT */, CVMX_ADD_IO_SEG(0x00011800D4000410ull) /* CVMX_DFM_FNT_IENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_DFM, 0, 0, "DFM_FNT_STAT[SBE_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_DFM, 1, 0, "DFM_FNT_STAT[DBE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_DFM, 0, 0, CVMX_ERROR_TYPE_SBE, "DFM_FNT_STAT[SBE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_DFM, 1, 0, CVMX_ERROR_TYPE_DBE, "DFM_FNT_STAT[DBE_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000088ull) /* CVMX_TIM_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180058000090ull) /* CVMX_TIM_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_REG_ERROR[MASK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_REG_ERROR[MASK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 52 /* lmc0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 31 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 21 /* iob */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800F0000058ull) /* CVMX_IOB_INT_SUM */, CVMX_ADD_IO_SEG(0x00011800F0000060ull) /* CVMX_IOB_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IOB_INT_SUM[NP_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IOB_INT_SUM[NP_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IOB_INT_SUM[P_SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IOB_INT_SUM[P_EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IOB_INT_SUM[NP_DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IOB_INT_SUM[P_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IOB_INT_SUM[NP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IOB_INT_SUM[NP_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IOB_INT_SUM[P_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IOB_INT_SUM[P_EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IOB_INT_SUM[NP_DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IOB_INT_SUM[P_DAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 46 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((1) & 1) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 1, 0, "AGL_GMX_RXX_INT_REG(1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 1, 0, "AGL_GMX_RXX_INT_REG(1)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 28 /* zip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 36 /* agx0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000518ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_BAD_REG(0) */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_BAD_REG(0)[STATOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_BAD_REG(0)[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_BAD_REG(0)[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_BAD_REG(0)[STATOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_BAD_REG(0)[INB_NXA]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 0, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 0, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 0, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 0, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 1, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 1, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 1, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 1, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 1, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 1, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 0) * 0x10000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 0) * 0x8000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 0, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 0, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 0, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 0, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 0, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 0, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 1, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 1, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 1, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 1, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 1, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 1, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 1, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 1, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 0) * 0x20000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 0) * 0x8000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 0, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 0, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 0, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 0, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 0, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 0, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 0, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 50 /* srio0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((0) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((0) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_ENABLE(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 0, "SRIOX_INT_REG(0)[BAR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 0, "SRIOX_INT_REG(0)[DENY_WR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 0, "SRIOX_INT_REG(0)[SLI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 0, "SRIOX_INT_REG(0)[MCE_RX]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 0, "SRIOX_INT_REG(0)[LOG_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 0, "SRIOX_INT_REG(0)[PHY_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 0, "SRIOX_INT_REG(0)[OMSG_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 0, "SRIOX_INT_REG(0)[PKO_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 0, "SRIOX_INT_REG(0)[RTRY_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 0, "SRIOX_INT_REG(0)[F_ERROR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 22, 0, "SRIOX_INT_REG(0)[MAC_BUF]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 23, 0, "SRIOX_INT_REG(0)[DEGRAD]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 24, 0, "SRIOX_INT_REG(0)[FAIL]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 25, 0, "SRIOX_INT_REG(0)[TTL_TOUT]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 26, 0, "SRIOX_INT_REG(0)[ZERO_PKT]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 0, 0, "SRIOX_INT_REG(0)[BAR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 0, 0, "SRIOX_INT_REG(0)[DENY_WR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 0, 0, "SRIOX_INT_REG(0)[SLI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 0, 0, "SRIOX_INT_REG(0)[MCE_RX]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 0, 0, "SRIOX_INT_REG(0)[LOG_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 0, 0, "SRIOX_INT_REG(0)[PHY_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 0, 0, "SRIOX_INT_REG(0)[OMSG_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 0, 0, "SRIOX_INT_REG(0)[PKO_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 0, 0, "SRIOX_INT_REG(0)[RTRY_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 0, 0, "SRIOX_INT_REG(0)[F_ERROR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 22, 0, 0, "SRIOX_INT_REG(0)[MAC_BUF]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 23, 0, 0, "SRIOX_INT_REG(0)[DEGRAD]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 24, 0, 0, "SRIOX_INT_REG(0)[FAIL]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 25, 0, 0, "SRIOX_INT_REG(0)[TTL_TOUT]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 26, 0, 0, "SRIOX_INT_REG(0)[ZERO_PKT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 51 /* srio1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800C8000118ull) + ((1) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800C8000110ull) + ((1) & 1) * 0x1000000ull /* CVMX_SRIOX_INT_ENABLE(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 1, "SRIOX_INT_REG(1)[BAR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 1, "SRIOX_INT_REG(1)[DENY_WR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 1, "SRIOX_INT_REG(1)[SLI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 1, "SRIOX_INT_REG(1)[MCE_RX]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 1, "SRIOX_INT_REG(1)[LOG_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 1, "SRIOX_INT_REG(1)[PHY_ERB]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 1, "SRIOX_INT_REG(1)[OMSG_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 1, "SRIOX_INT_REG(1)[PKO_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 1, "SRIOX_INT_REG(1)[RTRY_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 1, "SRIOX_INT_REG(1)[F_ERROR]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 22, 1, "SRIOX_INT_REG(1)[MAC_BUF]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 23, 1, "SRIOX_INT_REG(1)[DEGRAD]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 24, 1, "SRIOX_INT_REG(1)[FAIL]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 25, 1, "SRIOX_INT_REG(1)[TTL_TOUT]"},
-							{1, 1, CVMX_ERROR_GROUP_SRIO, 26, 1, "SRIOX_INT_REG(1)[ZERO_PKT]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 4, 1, 0, "SRIOX_INT_REG(1)[BAR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 5, 1, 0, "SRIOX_INT_REG(1)[DENY_WR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 6, 1, 0, "SRIOX_INT_REG(1)[SLI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 9, 1, 0, "SRIOX_INT_REG(1)[MCE_RX]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 12, 1, 0, "SRIOX_INT_REG(1)[LOG_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 13, 1, 0, "SRIOX_INT_REG(1)[PHY_ERB]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 18, 1, 0, "SRIOX_INT_REG(1)[OMSG_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 19, 1, 0, "SRIOX_INT_REG(1)[PKO_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 20, 1, 0, "SRIOX_INT_REG(1)[RTRY_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 21, 1, 0, "SRIOX_INT_REG(1)[F_ERROR]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 22, 1, 0, "SRIOX_INT_REG(1)[MAC_BUF]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 23, 1, 0, "SRIOX_INT_REG(1)[DEGRAD]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 24, 1, 0, "SRIOX_INT_REG(1)[FAIL]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 25, 1, 0, "SRIOX_INT_REG(1)[TTL_TOUT]"},
+							{1, 1, CVMX_ERROR_GROUP_SRIO, 26, 1, 0, "SRIOX_INT_REG(1)[ZERO_PKT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 34 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 51, 0, 0, "PEXP_SLI_INT_SUM[PIN_BP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 35 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -11351,768 +11351,768 @@ static struct cvmx_error_muxchild error_tree_cn68xx =
 			{CVMX_ADD_IO_SEG(0x0001070100086000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_PKT(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 4 /* agx:4 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, "GMXX_RXX_INT_REG(0,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, "GMXX_RXX_INT_REG(0,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, "GMXX_RXX_INT_REG(0,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, "GMXX_RXX_INT_REG(0,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3072, "GMXX_RXX_INT_REG(0,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3072, "GMXX_RXX_INT_REG(0,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3072, "GMXX_RXX_INT_REG(0,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3072, "GMXX_RXX_INT_REG(0,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3072, "GMXX_RXX_INT_REG(0,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3072, "GMXX_RXX_INT_REG(0,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3072, "GMXX_RXX_INT_REG(0,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3072, "GMXX_RXX_INT_REG(0,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, 0, "GMXX_RXX_INT_REG(0,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, 0, "GMXX_RXX_INT_REG(0,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, 0, "GMXX_RXX_INT_REG(0,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, 0, "GMXX_RXX_INT_REG(0,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3072, 0, "GMXX_RXX_INT_REG(0,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3072, 0, "GMXX_RXX_INT_REG(0,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3072, 0, "GMXX_RXX_INT_REG(0,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3072, 0, "GMXX_RXX_INT_REG(0,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3072, 0, "GMXX_RXX_INT_REG(0,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3072, 0, "GMXX_RXX_INT_REG(0,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3072, 0, "GMXX_RXX_INT_REG(0,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3072, 0, "GMXX_RXX_INT_REG(0,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3088, "GMXX_RXX_INT_REG(1,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, "GMXX_RXX_INT_REG(1,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, "GMXX_RXX_INT_REG(1,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3088, "GMXX_RXX_INT_REG(1,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3088, "GMXX_RXX_INT_REG(1,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3088, "GMXX_RXX_INT_REG(1,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3088, "GMXX_RXX_INT_REG(1,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3088, "GMXX_RXX_INT_REG(1,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3088, "GMXX_RXX_INT_REG(1,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3088, "GMXX_RXX_INT_REG(1,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3088, "GMXX_RXX_INT_REG(1,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3088, "GMXX_RXX_INT_REG(1,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3088, 0, "GMXX_RXX_INT_REG(1,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, 0, "GMXX_RXX_INT_REG(1,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, 0, "GMXX_RXX_INT_REG(1,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3088, 0, "GMXX_RXX_INT_REG(1,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3088, 0, "GMXX_RXX_INT_REG(1,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3088, 0, "GMXX_RXX_INT_REG(1,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3088, 0, "GMXX_RXX_INT_REG(1,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3088, 0, "GMXX_RXX_INT_REG(1,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3088, 0, "GMXX_RXX_INT_REG(1,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3088, 0, "GMXX_RXX_INT_REG(1,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3088, 0, "GMXX_RXX_INT_REG(1,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3088, 0, "GMXX_RXX_INT_REG(1,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3104, "GMXX_RXX_INT_REG(2,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, "GMXX_RXX_INT_REG(2,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, "GMXX_RXX_INT_REG(2,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3104, "GMXX_RXX_INT_REG(2,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3104, "GMXX_RXX_INT_REG(2,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3104, "GMXX_RXX_INT_REG(2,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3104, "GMXX_RXX_INT_REG(2,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3104, "GMXX_RXX_INT_REG(2,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3104, "GMXX_RXX_INT_REG(2,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3104, "GMXX_RXX_INT_REG(2,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3104, "GMXX_RXX_INT_REG(2,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3104, "GMXX_RXX_INT_REG(2,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3104, 0, "GMXX_RXX_INT_REG(2,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, 0, "GMXX_RXX_INT_REG(2,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, 0, "GMXX_RXX_INT_REG(2,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3104, 0, "GMXX_RXX_INT_REG(2,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3104, 0, "GMXX_RXX_INT_REG(2,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3104, 0, "GMXX_RXX_INT_REG(2,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3104, 0, "GMXX_RXX_INT_REG(2,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3104, 0, "GMXX_RXX_INT_REG(2,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3104, 0, "GMXX_RXX_INT_REG(2,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3104, 0, "GMXX_RXX_INT_REG(2,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3104, 0, "GMXX_RXX_INT_REG(2,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3104, 0, "GMXX_RXX_INT_REG(2,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,4) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((4) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3120, "GMXX_RXX_INT_REG(3,4)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, "GMXX_RXX_INT_REG(3,4)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, "GMXX_RXX_INT_REG(3,4)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3120, "GMXX_RXX_INT_REG(3,4)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3120, "GMXX_RXX_INT_REG(3,4)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3120, "GMXX_RXX_INT_REG(3,4)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3120, "GMXX_RXX_INT_REG(3,4)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3120, "GMXX_RXX_INT_REG(3,4)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3120, "GMXX_RXX_INT_REG(3,4)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3120, "GMXX_RXX_INT_REG(3,4)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3120, "GMXX_RXX_INT_REG(3,4)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3120, "GMXX_RXX_INT_REG(3,4)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3120, 0, "GMXX_RXX_INT_REG(3,4)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, 0, "GMXX_RXX_INT_REG(3,4)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, 0, "GMXX_RXX_INT_REG(3,4)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3120, 0, "GMXX_RXX_INT_REG(3,4)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 3120, 0, "GMXX_RXX_INT_REG(3,4)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 3120, 0, "GMXX_RXX_INT_REG(3,4)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 3120, 0, "GMXX_RXX_INT_REG(3,4)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 3120, 0, "GMXX_RXX_INT_REG(3,4)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 3120, 0, "GMXX_RXX_INT_REG(3,4)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 3120, 0, "GMXX_RXX_INT_REG(3,4)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 3120, 0, "GMXX_RXX_INT_REG(3,4)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 3120, 0, "GMXX_RXX_INT_REG(3,4)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((4) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(4) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((4) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, "GMXX_TX_INT_REG(4)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, "GMXX_TX_INT_REG(4)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, "GMXX_TX_INT_REG(4)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, 0, "GMXX_TX_INT_REG(4)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, 0, "GMXX_TX_INT_REG(4)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 3072, 0, "GMXX_TX_INT_REG(4)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, "PCSX_INTX_REG(0,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, "PCSX_INTX_REG(0,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, "PCSX_INTX_REG(0,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, "PCSX_INTX_REG(0,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3072, "PCSX_INTX_REG(0,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, "PCSX_INTX_REG(0,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3072, "PCSX_INTX_REG(0,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, "PCSX_INTX_REG(0,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3072, "PCSX_INTX_REG(0,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, 0, "PCSX_INTX_REG(0,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, 0, "PCSX_INTX_REG(0,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, 0, "PCSX_INTX_REG(0,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, 0, "PCSX_INTX_REG(0,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3072, 0, "PCSX_INTX_REG(0,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3072, 0, "PCSX_INTX_REG(0,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3072, 0, "PCSX_INTX_REG(0,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3072, 0, "PCSX_INTX_REG(0,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3072, 0, "PCSX_INTX_REG(0,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3088, "PCSX_INTX_REG(1,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3088, "PCSX_INTX_REG(1,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3088, "PCSX_INTX_REG(1,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3088, "PCSX_INTX_REG(1,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3088, "PCSX_INTX_REG(1,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, "PCSX_INTX_REG(1,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3088, "PCSX_INTX_REG(1,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, "PCSX_INTX_REG(1,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3088, "PCSX_INTX_REG(1,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3088, 0, "PCSX_INTX_REG(1,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3088, 0, "PCSX_INTX_REG(1,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3088, 0, "PCSX_INTX_REG(1,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3088, 0, "PCSX_INTX_REG(1,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3088, 0, "PCSX_INTX_REG(1,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3088, 0, "PCSX_INTX_REG(1,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3088, 0, "PCSX_INTX_REG(1,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3088, 0, "PCSX_INTX_REG(1,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3088, 0, "PCSX_INTX_REG(1,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3104, "PCSX_INTX_REG(2,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3104, "PCSX_INTX_REG(2,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3104, "PCSX_INTX_REG(2,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3104, "PCSX_INTX_REG(2,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3104, "PCSX_INTX_REG(2,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, "PCSX_INTX_REG(2,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3104, "PCSX_INTX_REG(2,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, "PCSX_INTX_REG(2,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3104, "PCSX_INTX_REG(2,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3104, 0, "PCSX_INTX_REG(2,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3104, 0, "PCSX_INTX_REG(2,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3104, 0, "PCSX_INTX_REG(2,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3104, 0, "PCSX_INTX_REG(2,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3104, 0, "PCSX_INTX_REG(2,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3104, 0, "PCSX_INTX_REG(2,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3104, 0, "PCSX_INTX_REG(2,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3104, 0, "PCSX_INTX_REG(2,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3104, 0, "PCSX_INTX_REG(2,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,4) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((4) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3120, "PCSX_INTX_REG(3,4)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3120, "PCSX_INTX_REG(3,4)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3120, "PCSX_INTX_REG(3,4)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3120, "PCSX_INTX_REG(3,4)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3120, "PCSX_INTX_REG(3,4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, "PCSX_INTX_REG(3,4)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3120, "PCSX_INTX_REG(3,4)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, "PCSX_INTX_REG(3,4)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3120, "PCSX_INTX_REG(3,4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3120, 0, "PCSX_INTX_REG(3,4)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3120, 0, "PCSX_INTX_REG(3,4)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3120, 0, "PCSX_INTX_REG(3,4)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3120, 0, "PCSX_INTX_REG(3,4)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 3120, 0, "PCSX_INTX_REG(3,4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 3120, 0, "PCSX_INTX_REG(3,4)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 3120, 0, "PCSX_INTX_REG(3,4)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 3120, 0, "PCSX_INTX_REG(3,4)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 3120, 0, "PCSX_INTX_REG(3,4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((4) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(4) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((4) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, "PCSXX_INT_REG(4)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, "PCSXX_INT_REG(4)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, "PCSXX_INT_REG(4)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, "PCSXX_INT_REG(4)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, "PCSXX_INT_REG(4)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, "PCSXX_INT_REG(4)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3072, "PCSXX_INT_REG(4)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 3072, 0, "PCSXX_INT_REG(4)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 3072, 0, "PCSXX_INT_REG(4)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 3072, 0, "PCSXX_INT_REG(4)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 3072, 0, "PCSXX_INT_REG(4)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 3072, 0, "PCSXX_INT_REG(4)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 3072, 0, "PCSXX_INT_REG(4)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 3072, 0, "PCSXX_INT_REG(4)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 3 /* agx:3 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, "GMXX_RXX_INT_REG(0,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, "GMXX_RXX_INT_REG(0,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, "GMXX_RXX_INT_REG(0,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, "GMXX_RXX_INT_REG(0,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2816, "GMXX_RXX_INT_REG(0,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2816, "GMXX_RXX_INT_REG(0,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2816, "GMXX_RXX_INT_REG(0,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2816, "GMXX_RXX_INT_REG(0,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2816, "GMXX_RXX_INT_REG(0,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2816, "GMXX_RXX_INT_REG(0,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2816, "GMXX_RXX_INT_REG(0,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2816, "GMXX_RXX_INT_REG(0,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, 0, "GMXX_RXX_INT_REG(0,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, 0, "GMXX_RXX_INT_REG(0,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, 0, "GMXX_RXX_INT_REG(0,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, 0, "GMXX_RXX_INT_REG(0,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2816, 0, "GMXX_RXX_INT_REG(0,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2816, 0, "GMXX_RXX_INT_REG(0,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2816, 0, "GMXX_RXX_INT_REG(0,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2816, 0, "GMXX_RXX_INT_REG(0,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2816, 0, "GMXX_RXX_INT_REG(0,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2816, 0, "GMXX_RXX_INT_REG(0,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2816, 0, "GMXX_RXX_INT_REG(0,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2816, 0, "GMXX_RXX_INT_REG(0,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2832, "GMXX_RXX_INT_REG(1,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, "GMXX_RXX_INT_REG(1,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, "GMXX_RXX_INT_REG(1,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2832, "GMXX_RXX_INT_REG(1,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2832, "GMXX_RXX_INT_REG(1,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2832, "GMXX_RXX_INT_REG(1,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2832, "GMXX_RXX_INT_REG(1,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2832, "GMXX_RXX_INT_REG(1,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2832, "GMXX_RXX_INT_REG(1,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2832, "GMXX_RXX_INT_REG(1,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2832, "GMXX_RXX_INT_REG(1,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2832, "GMXX_RXX_INT_REG(1,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2832, 0, "GMXX_RXX_INT_REG(1,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, 0, "GMXX_RXX_INT_REG(1,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, 0, "GMXX_RXX_INT_REG(1,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2832, 0, "GMXX_RXX_INT_REG(1,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2832, 0, "GMXX_RXX_INT_REG(1,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2832, 0, "GMXX_RXX_INT_REG(1,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2832, 0, "GMXX_RXX_INT_REG(1,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2832, 0, "GMXX_RXX_INT_REG(1,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2832, 0, "GMXX_RXX_INT_REG(1,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2832, 0, "GMXX_RXX_INT_REG(1,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2832, 0, "GMXX_RXX_INT_REG(1,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2832, 0, "GMXX_RXX_INT_REG(1,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2848, "GMXX_RXX_INT_REG(2,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, "GMXX_RXX_INT_REG(2,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, "GMXX_RXX_INT_REG(2,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2848, "GMXX_RXX_INT_REG(2,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2848, "GMXX_RXX_INT_REG(2,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2848, "GMXX_RXX_INT_REG(2,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2848, "GMXX_RXX_INT_REG(2,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2848, "GMXX_RXX_INT_REG(2,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2848, "GMXX_RXX_INT_REG(2,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2848, "GMXX_RXX_INT_REG(2,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2848, "GMXX_RXX_INT_REG(2,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2848, "GMXX_RXX_INT_REG(2,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2848, 0, "GMXX_RXX_INT_REG(2,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, 0, "GMXX_RXX_INT_REG(2,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, 0, "GMXX_RXX_INT_REG(2,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2848, 0, "GMXX_RXX_INT_REG(2,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2848, 0, "GMXX_RXX_INT_REG(2,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2848, 0, "GMXX_RXX_INT_REG(2,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2848, 0, "GMXX_RXX_INT_REG(2,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2848, 0, "GMXX_RXX_INT_REG(2,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2848, 0, "GMXX_RXX_INT_REG(2,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2848, 0, "GMXX_RXX_INT_REG(2,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2848, 0, "GMXX_RXX_INT_REG(2,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2848, 0, "GMXX_RXX_INT_REG(2,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,3) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((3) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2864, "GMXX_RXX_INT_REG(3,3)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2864, "GMXX_RXX_INT_REG(3,3)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2864, "GMXX_RXX_INT_REG(3,3)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2864, "GMXX_RXX_INT_REG(3,3)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2864, "GMXX_RXX_INT_REG(3,3)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2864, "GMXX_RXX_INT_REG(3,3)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2864, "GMXX_RXX_INT_REG(3,3)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2864, "GMXX_RXX_INT_REG(3,3)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2864, "GMXX_RXX_INT_REG(3,3)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2864, "GMXX_RXX_INT_REG(3,3)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2864, "GMXX_RXX_INT_REG(3,3)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2864, "GMXX_RXX_INT_REG(3,3)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2864, 0, "GMXX_RXX_INT_REG(3,3)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2864, 0, "GMXX_RXX_INT_REG(3,3)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2864, 0, "GMXX_RXX_INT_REG(3,3)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2864, 0, "GMXX_RXX_INT_REG(3,3)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2864, 0, "GMXX_RXX_INT_REG(3,3)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2864, 0, "GMXX_RXX_INT_REG(3,3)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2864, 0, "GMXX_RXX_INT_REG(3,3)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2864, 0, "GMXX_RXX_INT_REG(3,3)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2864, 0, "GMXX_RXX_INT_REG(3,3)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2864, 0, "GMXX_RXX_INT_REG(3,3)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2864, 0, "GMXX_RXX_INT_REG(3,3)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2864, 0, "GMXX_RXX_INT_REG(3,3)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((3) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(3) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((3) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, "GMXX_TX_INT_REG(3)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, "GMXX_TX_INT_REG(3)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, "GMXX_TX_INT_REG(3)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, 0, "GMXX_TX_INT_REG(3)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, 0, "GMXX_TX_INT_REG(3)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2816, 0, "GMXX_TX_INT_REG(3)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, "PCSX_INTX_REG(0,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, "PCSX_INTX_REG(0,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, "PCSX_INTX_REG(0,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, "PCSX_INTX_REG(0,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2816, "PCSX_INTX_REG(0,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, "PCSX_INTX_REG(0,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2816, "PCSX_INTX_REG(0,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, "PCSX_INTX_REG(0,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2816, "PCSX_INTX_REG(0,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, 0, "PCSX_INTX_REG(0,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, 0, "PCSX_INTX_REG(0,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, 0, "PCSX_INTX_REG(0,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, 0, "PCSX_INTX_REG(0,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2816, 0, "PCSX_INTX_REG(0,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2816, 0, "PCSX_INTX_REG(0,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2816, 0, "PCSX_INTX_REG(0,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2816, 0, "PCSX_INTX_REG(0,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2816, 0, "PCSX_INTX_REG(0,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2832, "PCSX_INTX_REG(1,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2832, "PCSX_INTX_REG(1,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2832, "PCSX_INTX_REG(1,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2832, "PCSX_INTX_REG(1,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2832, "PCSX_INTX_REG(1,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, "PCSX_INTX_REG(1,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2832, "PCSX_INTX_REG(1,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, "PCSX_INTX_REG(1,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2832, "PCSX_INTX_REG(1,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2832, 0, "PCSX_INTX_REG(1,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2832, 0, "PCSX_INTX_REG(1,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2832, 0, "PCSX_INTX_REG(1,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2832, 0, "PCSX_INTX_REG(1,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2832, 0, "PCSX_INTX_REG(1,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2832, 0, "PCSX_INTX_REG(1,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2832, 0, "PCSX_INTX_REG(1,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2832, 0, "PCSX_INTX_REG(1,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2832, 0, "PCSX_INTX_REG(1,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2848, "PCSX_INTX_REG(2,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2848, "PCSX_INTX_REG(2,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2848, "PCSX_INTX_REG(2,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2848, "PCSX_INTX_REG(2,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2848, "PCSX_INTX_REG(2,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, "PCSX_INTX_REG(2,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2848, "PCSX_INTX_REG(2,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, "PCSX_INTX_REG(2,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2848, "PCSX_INTX_REG(2,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2848, 0, "PCSX_INTX_REG(2,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2848, 0, "PCSX_INTX_REG(2,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2848, 0, "PCSX_INTX_REG(2,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2848, 0, "PCSX_INTX_REG(2,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2848, 0, "PCSX_INTX_REG(2,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2848, 0, "PCSX_INTX_REG(2,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2848, 0, "PCSX_INTX_REG(2,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2848, 0, "PCSX_INTX_REG(2,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2848, 0, "PCSX_INTX_REG(2,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,3) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((3) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2664, "PCSX_INTX_REG(3,3)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2664, "PCSX_INTX_REG(3,3)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2664, "PCSX_INTX_REG(3,3)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2664, "PCSX_INTX_REG(3,3)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2664, "PCSX_INTX_REG(3,3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2664, "PCSX_INTX_REG(3,3)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2664, "PCSX_INTX_REG(3,3)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2664, "PCSX_INTX_REG(3,3)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2664, "PCSX_INTX_REG(3,3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2664, 0, "PCSX_INTX_REG(3,3)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2664, 0, "PCSX_INTX_REG(3,3)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2664, 0, "PCSX_INTX_REG(3,3)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2664, 0, "PCSX_INTX_REG(3,3)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2664, 0, "PCSX_INTX_REG(3,3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2664, 0, "PCSX_INTX_REG(3,3)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2664, 0, "PCSX_INTX_REG(3,3)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2664, 0, "PCSX_INTX_REG(3,3)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2664, 0, "PCSX_INTX_REG(3,3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((3) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(3) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((3) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, "PCSXX_INT_REG(3)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, "PCSXX_INT_REG(3)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, "PCSXX_INT_REG(3)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, "PCSXX_INT_REG(3)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, "PCSXX_INT_REG(3)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, "PCSXX_INT_REG(3)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2816, "PCSXX_INT_REG(3)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2816, 0, "PCSXX_INT_REG(3)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2816, 0, "PCSXX_INT_REG(3)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2816, 0, "PCSXX_INT_REG(3)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2816, 0, "PCSXX_INT_REG(3)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2816, 0, "PCSXX_INT_REG(3)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2816, 0, "PCSXX_INT_REG(3)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2816, 0, "PCSXX_INT_REG(3)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 2 /* agx:2 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, "GMXX_RXX_INT_REG(0,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, "GMXX_RXX_INT_REG(0,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, "GMXX_RXX_INT_REG(0,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, "GMXX_RXX_INT_REG(0,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2560, "GMXX_RXX_INT_REG(0,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2560, "GMXX_RXX_INT_REG(0,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2560, "GMXX_RXX_INT_REG(0,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2560, "GMXX_RXX_INT_REG(0,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2560, "GMXX_RXX_INT_REG(0,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2560, "GMXX_RXX_INT_REG(0,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2560, "GMXX_RXX_INT_REG(0,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2560, "GMXX_RXX_INT_REG(0,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, 0, "GMXX_RXX_INT_REG(0,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, 0, "GMXX_RXX_INT_REG(0,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, 0, "GMXX_RXX_INT_REG(0,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, 0, "GMXX_RXX_INT_REG(0,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2560, 0, "GMXX_RXX_INT_REG(0,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2560, 0, "GMXX_RXX_INT_REG(0,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2560, 0, "GMXX_RXX_INT_REG(0,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2560, 0, "GMXX_RXX_INT_REG(0,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2560, 0, "GMXX_RXX_INT_REG(0,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2560, 0, "GMXX_RXX_INT_REG(0,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2560, 0, "GMXX_RXX_INT_REG(0,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2560, 0, "GMXX_RXX_INT_REG(0,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2576, "GMXX_RXX_INT_REG(1,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, "GMXX_RXX_INT_REG(1,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, "GMXX_RXX_INT_REG(1,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2576, "GMXX_RXX_INT_REG(1,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2576, "GMXX_RXX_INT_REG(1,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2576, "GMXX_RXX_INT_REG(1,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2576, "GMXX_RXX_INT_REG(1,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2576, "GMXX_RXX_INT_REG(1,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2576, "GMXX_RXX_INT_REG(1,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2576, "GMXX_RXX_INT_REG(1,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2576, "GMXX_RXX_INT_REG(1,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2576, "GMXX_RXX_INT_REG(1,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2576, 0, "GMXX_RXX_INT_REG(1,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, 0, "GMXX_RXX_INT_REG(1,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, 0, "GMXX_RXX_INT_REG(1,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2576, 0, "GMXX_RXX_INT_REG(1,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2576, 0, "GMXX_RXX_INT_REG(1,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2576, 0, "GMXX_RXX_INT_REG(1,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2576, 0, "GMXX_RXX_INT_REG(1,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2576, 0, "GMXX_RXX_INT_REG(1,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2576, 0, "GMXX_RXX_INT_REG(1,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2576, 0, "GMXX_RXX_INT_REG(1,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2576, 0, "GMXX_RXX_INT_REG(1,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2576, 0, "GMXX_RXX_INT_REG(1,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2592, "GMXX_RXX_INT_REG(2,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, "GMXX_RXX_INT_REG(2,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, "GMXX_RXX_INT_REG(2,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2592, "GMXX_RXX_INT_REG(2,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2592, "GMXX_RXX_INT_REG(2,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2592, "GMXX_RXX_INT_REG(2,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2592, "GMXX_RXX_INT_REG(2,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2592, "GMXX_RXX_INT_REG(2,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2592, "GMXX_RXX_INT_REG(2,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2592, "GMXX_RXX_INT_REG(2,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2592, "GMXX_RXX_INT_REG(2,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2592, "GMXX_RXX_INT_REG(2,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2592, 0, "GMXX_RXX_INT_REG(2,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, 0, "GMXX_RXX_INT_REG(2,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, 0, "GMXX_RXX_INT_REG(2,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2592, 0, "GMXX_RXX_INT_REG(2,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2592, 0, "GMXX_RXX_INT_REG(2,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2592, 0, "GMXX_RXX_INT_REG(2,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2592, 0, "GMXX_RXX_INT_REG(2,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2592, 0, "GMXX_RXX_INT_REG(2,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2592, 0, "GMXX_RXX_INT_REG(2,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2592, 0, "GMXX_RXX_INT_REG(2,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2592, 0, "GMXX_RXX_INT_REG(2,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2592, 0, "GMXX_RXX_INT_REG(2,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,2) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((2) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2608, "GMXX_RXX_INT_REG(3,2)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, "GMXX_RXX_INT_REG(3,2)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, "GMXX_RXX_INT_REG(3,2)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2608, "GMXX_RXX_INT_REG(3,2)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2608, "GMXX_RXX_INT_REG(3,2)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2608, "GMXX_RXX_INT_REG(3,2)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2608, "GMXX_RXX_INT_REG(3,2)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2608, "GMXX_RXX_INT_REG(3,2)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2608, "GMXX_RXX_INT_REG(3,2)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2608, "GMXX_RXX_INT_REG(3,2)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2608, "GMXX_RXX_INT_REG(3,2)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2608, "GMXX_RXX_INT_REG(3,2)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2608, 0, "GMXX_RXX_INT_REG(3,2)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, 0, "GMXX_RXX_INT_REG(3,2)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, 0, "GMXX_RXX_INT_REG(3,2)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2608, 0, "GMXX_RXX_INT_REG(3,2)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2608, 0, "GMXX_RXX_INT_REG(3,2)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2608, 0, "GMXX_RXX_INT_REG(3,2)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2608, 0, "GMXX_RXX_INT_REG(3,2)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2608, 0, "GMXX_RXX_INT_REG(3,2)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2608, 0, "GMXX_RXX_INT_REG(3,2)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2608, 0, "GMXX_RXX_INT_REG(3,2)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2608, 0, "GMXX_RXX_INT_REG(3,2)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2608, 0, "GMXX_RXX_INT_REG(3,2)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((2) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(2) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((2) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, "GMXX_TX_INT_REG(2)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, "GMXX_TX_INT_REG(2)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, "GMXX_TX_INT_REG(2)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, 0, "GMXX_TX_INT_REG(2)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, 0, "GMXX_TX_INT_REG(2)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2560, 0, "GMXX_TX_INT_REG(2)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, "PCSX_INTX_REG(0,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, "PCSX_INTX_REG(0,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, "PCSX_INTX_REG(0,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, "PCSX_INTX_REG(0,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2560, "PCSX_INTX_REG(0,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, "PCSX_INTX_REG(0,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2560, "PCSX_INTX_REG(0,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, "PCSX_INTX_REG(0,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2560, "PCSX_INTX_REG(0,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, 0, "PCSX_INTX_REG(0,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, 0, "PCSX_INTX_REG(0,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, 0, "PCSX_INTX_REG(0,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, 0, "PCSX_INTX_REG(0,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2560, 0, "PCSX_INTX_REG(0,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2560, 0, "PCSX_INTX_REG(0,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2560, 0, "PCSX_INTX_REG(0,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2560, 0, "PCSX_INTX_REG(0,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2560, 0, "PCSX_INTX_REG(0,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2576, "PCSX_INTX_REG(1,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2576, "PCSX_INTX_REG(1,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2576, "PCSX_INTX_REG(1,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2576, "PCSX_INTX_REG(1,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2576, "PCSX_INTX_REG(1,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, "PCSX_INTX_REG(1,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2576, "PCSX_INTX_REG(1,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, "PCSX_INTX_REG(1,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2576, "PCSX_INTX_REG(1,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2576, 0, "PCSX_INTX_REG(1,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2576, 0, "PCSX_INTX_REG(1,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2576, 0, "PCSX_INTX_REG(1,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2576, 0, "PCSX_INTX_REG(1,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2576, 0, "PCSX_INTX_REG(1,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2576, 0, "PCSX_INTX_REG(1,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2576, 0, "PCSX_INTX_REG(1,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2576, 0, "PCSX_INTX_REG(1,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2576, 0, "PCSX_INTX_REG(1,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2592, "PCSX_INTX_REG(2,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2592, "PCSX_INTX_REG(2,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2592, "PCSX_INTX_REG(2,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2592, "PCSX_INTX_REG(2,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2592, "PCSX_INTX_REG(2,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, "PCSX_INTX_REG(2,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2592, "PCSX_INTX_REG(2,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, "PCSX_INTX_REG(2,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2592, "PCSX_INTX_REG(2,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2592, 0, "PCSX_INTX_REG(2,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2592, 0, "PCSX_INTX_REG(2,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2592, 0, "PCSX_INTX_REG(2,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2592, 0, "PCSX_INTX_REG(2,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2592, 0, "PCSX_INTX_REG(2,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2592, 0, "PCSX_INTX_REG(2,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2592, 0, "PCSX_INTX_REG(2,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2592, 0, "PCSX_INTX_REG(2,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2592, 0, "PCSX_INTX_REG(2,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,2) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((2) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2608, "PCSX_INTX_REG(3,2)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2608, "PCSX_INTX_REG(3,2)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2608, "PCSX_INTX_REG(3,2)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2608, "PCSX_INTX_REG(3,2)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2608, "PCSX_INTX_REG(3,2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, "PCSX_INTX_REG(3,2)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2608, "PCSX_INTX_REG(3,2)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, "PCSX_INTX_REG(3,2)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2608, "PCSX_INTX_REG(3,2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2608, 0, "PCSX_INTX_REG(3,2)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2608, 0, "PCSX_INTX_REG(3,2)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2608, 0, "PCSX_INTX_REG(3,2)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2608, 0, "PCSX_INTX_REG(3,2)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2608, 0, "PCSX_INTX_REG(3,2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2608, 0, "PCSX_INTX_REG(3,2)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2608, 0, "PCSX_INTX_REG(3,2)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2608, 0, "PCSX_INTX_REG(3,2)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2608, 0, "PCSX_INTX_REG(3,2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((2) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(2) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((2) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, "PCSXX_INT_REG(2)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, "PCSXX_INT_REG(2)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, "PCSXX_INT_REG(2)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, "PCSXX_INT_REG(2)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, "PCSXX_INT_REG(2)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, "PCSXX_INT_REG(2)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2560, "PCSXX_INT_REG(2)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2560, 0, "PCSXX_INT_REG(2)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2560, 0, "PCSXX_INT_REG(2)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2560, 0, "PCSXX_INT_REG(2)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2560, 0, "PCSXX_INT_REG(2)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2560, 0, "PCSXX_INT_REG(2)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2560, 0, "PCSXX_INT_REG(2)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2560, 0, "PCSXX_INT_REG(2)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 1 /* agx:1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((1) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,1) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((1) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2368, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2368, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2368, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2368, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2368, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2368, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2368, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2368, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, 0, "GMXX_RXX_INT_REG(0,1)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, 0, "GMXX_RXX_INT_REG(0,1)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, 0, "GMXX_RXX_INT_REG(0,1)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, 0, "GMXX_RXX_INT_REG(0,1)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2368, 0, "GMXX_RXX_INT_REG(0,1)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2368, 0, "GMXX_RXX_INT_REG(0,1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2368, 0, "GMXX_RXX_INT_REG(0,1)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2368, 0, "GMXX_RXX_INT_REG(0,1)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2368, 0, "GMXX_RXX_INT_REG(0,1)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2368, 0, "GMXX_RXX_INT_REG(0,1)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2368, 0, "GMXX_RXX_INT_REG(0,1)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2368, 0, "GMXX_RXX_INT_REG(0,1)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((1) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((1) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, "GMXX_TX_INT_REG(1)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, 0, "GMXX_TX_INT_REG(1)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, 0, "GMXX_TX_INT_REG(1)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2368, 0, "GMXX_TX_INT_REG(1)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((1) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,1) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((1) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, "PCSX_INTX_REG(0,1)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, "PCSX_INTX_REG(0,1)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, "PCSX_INTX_REG(0,1)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, "PCSX_INTX_REG(0,1)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2368, "PCSX_INTX_REG(0,1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, "PCSX_INTX_REG(0,1)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2368, "PCSX_INTX_REG(0,1)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2368, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, 0, "PCSX_INTX_REG(0,1)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, 0, "PCSX_INTX_REG(0,1)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, 0, "PCSX_INTX_REG(0,1)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, 0, "PCSX_INTX_REG(0,1)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2368, 0, "PCSX_INTX_REG(0,1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2368, 0, "PCSX_INTX_REG(0,1)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2368, 0, "PCSX_INTX_REG(0,1)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2368, 0, "PCSX_INTX_REG(0,1)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2368, 0, "PCSX_INTX_REG(0,1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((1) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(1) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((1) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, "PCSXX_INT_REG(1)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, "PCSXX_INT_REG(1)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, "PCSXX_INT_REG(1)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, "PCSXX_INT_REG(1)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, "PCSXX_INT_REG(1)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, "PCSXX_INT_REG(1)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2368, "PCSXX_INT_REG(1)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2368, 0, "PCSXX_INT_REG(1)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2368, 0, "PCSXX_INT_REG(1)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2368, 0, "PCSXX_INT_REG(1)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2368, 0, "PCSXX_INT_REG(1)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2368, 0, "PCSXX_INT_REG(1)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2368, 0, "PCSXX_INT_REG(1)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2368, 0, "PCSXX_INT_REG(1)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 0 /* agx:0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((0) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(0,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((0) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2048, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2048, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2048, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2048, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2048, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2048, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2048, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2048, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, 0, "GMXX_RXX_INT_REG(0,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, 0, "GMXX_RXX_INT_REG(0,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, 0, "GMXX_RXX_INT_REG(0,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, 0, "GMXX_RXX_INT_REG(0,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2048, 0, "GMXX_RXX_INT_REG(0,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2048, 0, "GMXX_RXX_INT_REG(0,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2048, 0, "GMXX_RXX_INT_REG(0,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2048, 0, "GMXX_RXX_INT_REG(0,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2048, 0, "GMXX_RXX_INT_REG(0,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2048, 0, "GMXX_RXX_INT_REG(0,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2048, 0, "GMXX_RXX_INT_REG(0,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2048, 0, "GMXX_RXX_INT_REG(0,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((1) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(1,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((1) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2064, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2064, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2064, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2064, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2064, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2064, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2064, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2064, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2064, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2064, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2064, 0, "GMXX_RXX_INT_REG(1,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, 0, "GMXX_RXX_INT_REG(1,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, 0, "GMXX_RXX_INT_REG(1,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2064, 0, "GMXX_RXX_INT_REG(1,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2064, 0, "GMXX_RXX_INT_REG(1,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2064, 0, "GMXX_RXX_INT_REG(1,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2064, 0, "GMXX_RXX_INT_REG(1,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2064, 0, "GMXX_RXX_INT_REG(1,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2064, 0, "GMXX_RXX_INT_REG(1,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2064, 0, "GMXX_RXX_INT_REG(1,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2064, 0, "GMXX_RXX_INT_REG(1,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2064, 0, "GMXX_RXX_INT_REG(1,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((2) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(2,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((2) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2080, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2080, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2080, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2080, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2080, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2080, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2080, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2080, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2080, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2080, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2080, 0, "GMXX_RXX_INT_REG(2,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, 0, "GMXX_RXX_INT_REG(2,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, 0, "GMXX_RXX_INT_REG(2,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2080, 0, "GMXX_RXX_INT_REG(2,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2080, 0, "GMXX_RXX_INT_REG(2,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2080, 0, "GMXX_RXX_INT_REG(2,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2080, 0, "GMXX_RXX_INT_REG(2,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2080, 0, "GMXX_RXX_INT_REG(2,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2080, 0, "GMXX_RXX_INT_REG(2,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2080, 0, "GMXX_RXX_INT_REG(2,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2080, 0, "GMXX_RXX_INT_REG(2,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2080, 0, "GMXX_RXX_INT_REG(2,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000000ull) + (((3) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_REG(3,0) */, CVMX_ADD_IO_SEG(0x0001180008000008ull) + (((3) & 3) + ((0) & 7) * 0x2000ull) * 2048 /* CVMX_GMXX_RXX_INT_EN(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2096, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2096, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2096, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2096, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2096, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2096, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2096, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2096, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2096, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2096, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2096, 0, "GMXX_RXX_INT_REG(3,0)[CAREXT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, 0, "GMXX_RXX_INT_REG(3,0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, 0, "GMXX_RXX_INT_REG(3,0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2096, 0, "GMXX_RXX_INT_REG(3,0)[LOC_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 21, 2096, 0, "GMXX_RXX_INT_REG(3,0)[REM_FAULT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 22, 2096, 0, "GMXX_RXX_INT_REG(3,0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 23, 2096, 0, "GMXX_RXX_INT_REG(3,0)[BAD_TERM]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 24, 2096, 0, "GMXX_RXX_INT_REG(3,0)[UNSOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 25, 2096, 0, "GMXX_RXX_INT_REG(3,0)[UNEOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 26, 2096, 0, "GMXX_RXX_INT_REG(3,0)[UNDAT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 27, 2096, 0, "GMXX_RXX_INT_REG(3,0)[HG2FLD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 28, 2096, 0, "GMXX_RXX_INT_REG(3,0)[HG2CC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180008000500ull) + ((0) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x0001180008000508ull) + ((0) & 7) * 0x1000000ull /* CVMX_GMXX_TX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, "GMXX_TX_INT_REG(0)[UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, 0, "GMXX_TX_INT_REG(0)[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, 0, "GMXX_TX_INT_REG(0)[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 20, 2048, 0, "GMXX_TX_INT_REG(0)[PTP_LOST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((0) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(0,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((0) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(0,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, "PCSX_INTX_REG(0,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, "PCSX_INTX_REG(0,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, "PCSX_INTX_REG(0,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, "PCSX_INTX_REG(0,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2048, "PCSX_INTX_REG(0,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, "PCSX_INTX_REG(0,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2048, "PCSX_INTX_REG(0,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2048, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, 0, "PCSX_INTX_REG(0,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, 0, "PCSX_INTX_REG(0,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, 0, "PCSX_INTX_REG(0,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, 0, "PCSX_INTX_REG(0,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2048, 0, "PCSX_INTX_REG(0,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2048, 0, "PCSX_INTX_REG(0,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2048, 0, "PCSX_INTX_REG(0,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2048, 0, "PCSX_INTX_REG(0,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2048, 0, "PCSX_INTX_REG(0,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((1) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(1,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((1) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(1,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2064, "PCSX_INTX_REG(1,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2064, "PCSX_INTX_REG(1,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2064, "PCSX_INTX_REG(1,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2064, "PCSX_INTX_REG(1,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2064, "PCSX_INTX_REG(1,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, "PCSX_INTX_REG(1,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2064, "PCSX_INTX_REG(1,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2064, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2064, 0, "PCSX_INTX_REG(1,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2064, 0, "PCSX_INTX_REG(1,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2064, 0, "PCSX_INTX_REG(1,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2064, 0, "PCSX_INTX_REG(1,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2064, 0, "PCSX_INTX_REG(1,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2064, 0, "PCSX_INTX_REG(1,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2064, 0, "PCSX_INTX_REG(1,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2064, 0, "PCSX_INTX_REG(1,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2064, 0, "PCSX_INTX_REG(1,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((2) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(2,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((2) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(2,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2080, "PCSX_INTX_REG(2,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2080, "PCSX_INTX_REG(2,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2080, "PCSX_INTX_REG(2,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2080, "PCSX_INTX_REG(2,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2080, "PCSX_INTX_REG(2,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, "PCSX_INTX_REG(2,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2080, "PCSX_INTX_REG(2,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2080, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2080, 0, "PCSX_INTX_REG(2,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2080, 0, "PCSX_INTX_REG(2,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2080, 0, "PCSX_INTX_REG(2,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2080, 0, "PCSX_INTX_REG(2,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2080, 0, "PCSX_INTX_REG(2,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2080, 0, "PCSX_INTX_REG(2,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2080, 0, "PCSX_INTX_REG(2,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2080, 0, "PCSX_INTX_REG(2,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2080, 0, "PCSX_INTX_REG(2,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0001080ull) + (((3) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_REG(3,0) */, CVMX_ADD_IO_SEG(0x00011800B0001088ull) + (((3) & 3) + ((0) & 7) * 0x4000ull) * 1024 /* CVMX_PCSX_INTX_EN_REG(3,0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2096, "PCSX_INTX_REG(3,0)[AN_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2096, "PCSX_INTX_REG(3,0)[TXFIFU]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2096, "PCSX_INTX_REG(3,0)[TXFIFO]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2096, "PCSX_INTX_REG(3,0)[TXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2096, "PCSX_INTX_REG(3,0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, "PCSX_INTX_REG(3,0)[RXLOCK]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2096, "PCSX_INTX_REG(3,0)[AN_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2096, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2096, 0, "PCSX_INTX_REG(3,0)[AN_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2096, 0, "PCSX_INTX_REG(3,0)[TXFIFU]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2096, 0, "PCSX_INTX_REG(3,0)[TXFIFO]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2096, 0, "PCSX_INTX_REG(3,0)[TXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 7, 2096, 0, "PCSX_INTX_REG(3,0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 8, 2096, 0, "PCSX_INTX_REG(3,0)[RXLOCK]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 9, 2096, 0, "PCSX_INTX_REG(3,0)[AN_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 10, 2096, 0, "PCSX_INTX_REG(3,0)[SYNC_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 12, 2096, 0, "PCSX_INTX_REG(3,0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800B0000858ull) + ((0) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800B0000860ull) + ((0) & 7) * 0x1000000ull /* CVMX_PCSXX_INT_EN_REG(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, "PCSXX_INT_REG(0)[TXFLT]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, "PCSXX_INT_REG(0)[RXBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, "PCSXX_INT_REG(0)[RXSYNBAD]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, "PCSXX_INT_REG(0)[BITLCKLS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, "PCSXX_INT_REG(0)[SYNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, "PCSXX_INT_REG(0)[ALGNLOS]"},
-							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2048, "PCSXX_INT_REG(0)[DBG_SYNC]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 0, 2048, 0, "PCSXX_INT_REG(0)[TXFLT]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 1, 2048, 0, "PCSXX_INT_REG(0)[RXBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 2, 2048, 0, "PCSXX_INT_REG(0)[RXSYNBAD]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 3, 2048, 0, "PCSXX_INT_REG(0)[BITLCKLS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 4, 2048, 0, "PCSXX_INT_REG(0)[SYNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 5, 2048, 0, "PCSXX_INT_REG(0)[ALGNLOS]"},
+							{1, 1, CVMX_ERROR_GROUP_ETHERNET, 6, 2048, 0, "PCSXX_INT_REG(0)[DBG_SYNC]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 48 /* ilk */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180014000008ull) /* CVMX_ILK_GBL_INT */, CVMX_ADD_IO_SEG(0x0001180014000010ull) /* CVMX_ILK_GBL_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, "ILK_GBL_INT[RXF_LNK0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_GBL_INT[RXF_LNK1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, "ILK_GBL_INT[RXF_CTL_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, "ILK_GBL_INT[RXF_POP_EMPTY]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, "ILK_GBL_INT[RXF_PUSH_FULL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, 0, "ILK_GBL_INT[RXF_LNK0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_GBL_INT[RXF_LNK1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, 0, "ILK_GBL_INT[RXF_CTL_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, 0, "ILK_GBL_INT[RXF_POP_EMPTY]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, 0, "ILK_GBL_INT[RXF_PUSH_FULL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014010078ull) + ((0) & 1) * 16384 /* CVMX_ILK_TXX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180014010080ull) + ((0) & 1) * 16384 /* CVMX_ILK_TXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_TXX_INT(0)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, "ILK_TXX_INT(0)[BAD_PIPE]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, "ILK_TXX_INT(0)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_TXX_INT(0)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, 0, "ILK_TXX_INT(0)[BAD_PIPE]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, 0, "ILK_TXX_INT(0)[STAT_CNT_OVFL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014010078ull) + ((1) & 1) * 16384 /* CVMX_ILK_TXX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180014010080ull) + ((1) & 1) * 16384 /* CVMX_ILK_TXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, "ILK_TXX_INT(1)[BAD_SEQ]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, "ILK_TXX_INT(1)[BAD_PIPE]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, "ILK_TXX_INT(1)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, 0, "ILK_TXX_INT(1)[BAD_SEQ]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, 0, "ILK_TXX_INT(1)[BAD_PIPE]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, 0, "ILK_TXX_INT(1)[STAT_CNT_OVFL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014020010ull) + ((0) & 1) * 16384 /* CVMX_ILK_RXX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180014020018ull) + ((0) & 1) * 16384 /* CVMX_ILK_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_RXX_INT(0)[CRC24_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, "ILK_RXX_INT(0)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, "ILK_RXX_INT(0)[LANE_BAD_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, "ILK_RXX_INT(0)[PKT_DROP_RXF]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, "ILK_RXX_INT(0)[PKT_DROP_RID]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 0, "ILK_RXX_INT(0)[PKT_DROP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_RXX_INT(0)[CRC24_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, 0, "ILK_RXX_INT(0)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, 0, "ILK_RXX_INT(0)[LANE_BAD_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, 0, "ILK_RXX_INT(0)[PKT_DROP_RXF]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, 0, "ILK_RXX_INT(0)[PKT_DROP_RID]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 0, 0, "ILK_RXX_INT(0)[PKT_DROP_SOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014020010ull) + ((1) & 1) * 16384 /* CVMX_ILK_RXX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180014020018ull) + ((1) & 1) * 16384 /* CVMX_ILK_RXX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, "ILK_RXX_INT(1)[CRC24_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, "ILK_RXX_INT(1)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, "ILK_RXX_INT(1)[LANE_BAD_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, "ILK_RXX_INT(1)[PKT_DROP_RXF]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, "ILK_RXX_INT(1)[PKT_DROP_RID]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 1, "ILK_RXX_INT(1)[PKT_DROP_SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, 0, "ILK_RXX_INT(1)[CRC24_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, 0, "ILK_RXX_INT(1)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, 0, "ILK_RXX_INT(1)[LANE_BAD_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, 0, "ILK_RXX_INT(1)[PKT_DROP_RXF]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, 0, "ILK_RXX_INT(1)[PKT_DROP_RID]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 1, 0, "ILK_RXX_INT(1)[PKT_DROP_SOP]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((0) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((0) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, "ILK_RX_LNEX_INT(0)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, "ILK_RX_LNEX_INT(0)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, "ILK_RX_LNEX_INT(0)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, "ILK_RX_LNEX_INT(0)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, "ILK_RX_LNEX_INT(0)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, "ILK_RX_LNEX_INT(0)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, "ILK_RX_LNEX_INT(0)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, "ILK_RX_LNEX_INT(0)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 0, "ILK_RX_LNEX_INT(0)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 0, 0, "ILK_RX_LNEX_INT(0)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 0, 0, "ILK_RX_LNEX_INT(0)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 0, 0, "ILK_RX_LNEX_INT(0)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 0, 0, "ILK_RX_LNEX_INT(0)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 0, 0, "ILK_RX_LNEX_INT(0)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 0, 0, "ILK_RX_LNEX_INT(0)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 0, 0, "ILK_RX_LNEX_INT(0)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 0, 0, "ILK_RX_LNEX_INT(0)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 0, 0, "ILK_RX_LNEX_INT(0)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((1) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((1) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 1, "ILK_RX_LNEX_INT(1)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, "ILK_RX_LNEX_INT(1)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, "ILK_RX_LNEX_INT(1)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, "ILK_RX_LNEX_INT(1)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, "ILK_RX_LNEX_INT(1)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, "ILK_RX_LNEX_INT(1)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, "ILK_RX_LNEX_INT(1)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, "ILK_RX_LNEX_INT(1)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 1, "ILK_RX_LNEX_INT(1)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 1, 0, "ILK_RX_LNEX_INT(1)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 1, 0, "ILK_RX_LNEX_INT(1)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 1, 0, "ILK_RX_LNEX_INT(1)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 1, 0, "ILK_RX_LNEX_INT(1)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 1, 0, "ILK_RX_LNEX_INT(1)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 1, 0, "ILK_RX_LNEX_INT(1)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 1, 0, "ILK_RX_LNEX_INT(1)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 1, 0, "ILK_RX_LNEX_INT(1)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 1, 0, "ILK_RX_LNEX_INT(1)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((2) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(2) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((2) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 2, "ILK_RX_LNEX_INT(2)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 2, "ILK_RX_LNEX_INT(2)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 2, "ILK_RX_LNEX_INT(2)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 2, "ILK_RX_LNEX_INT(2)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 2, "ILK_RX_LNEX_INT(2)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 2, "ILK_RX_LNEX_INT(2)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 2, "ILK_RX_LNEX_INT(2)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 2, "ILK_RX_LNEX_INT(2)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 2, "ILK_RX_LNEX_INT(2)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 2, 0, "ILK_RX_LNEX_INT(2)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 2, 0, "ILK_RX_LNEX_INT(2)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 2, 0, "ILK_RX_LNEX_INT(2)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 2, 0, "ILK_RX_LNEX_INT(2)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 2, 0, "ILK_RX_LNEX_INT(2)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 2, 0, "ILK_RX_LNEX_INT(2)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 2, 0, "ILK_RX_LNEX_INT(2)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 2, 0, "ILK_RX_LNEX_INT(2)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 2, 0, "ILK_RX_LNEX_INT(2)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((3) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(3) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((3) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 3, "ILK_RX_LNEX_INT(3)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 3, "ILK_RX_LNEX_INT(3)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 3, "ILK_RX_LNEX_INT(3)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 3, "ILK_RX_LNEX_INT(3)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 3, "ILK_RX_LNEX_INT(3)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 3, "ILK_RX_LNEX_INT(3)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 3, "ILK_RX_LNEX_INT(3)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 3, "ILK_RX_LNEX_INT(3)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 3, "ILK_RX_LNEX_INT(3)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 3, 0, "ILK_RX_LNEX_INT(3)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 3, 0, "ILK_RX_LNEX_INT(3)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 3, 0, "ILK_RX_LNEX_INT(3)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 3, 0, "ILK_RX_LNEX_INT(3)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 3, 0, "ILK_RX_LNEX_INT(3)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 3, 0, "ILK_RX_LNEX_INT(3)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 3, 0, "ILK_RX_LNEX_INT(3)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 3, 0, "ILK_RX_LNEX_INT(3)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 3, 0, "ILK_RX_LNEX_INT(3)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((4) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(4) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((4) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(4) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 4, "ILK_RX_LNEX_INT(4)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 4, "ILK_RX_LNEX_INT(4)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 4, "ILK_RX_LNEX_INT(4)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 4, "ILK_RX_LNEX_INT(4)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 4, "ILK_RX_LNEX_INT(4)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 4, "ILK_RX_LNEX_INT(4)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 4, "ILK_RX_LNEX_INT(4)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 4, "ILK_RX_LNEX_INT(4)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 4, "ILK_RX_LNEX_INT(4)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 4, 0, "ILK_RX_LNEX_INT(4)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 4, 0, "ILK_RX_LNEX_INT(4)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 4, 0, "ILK_RX_LNEX_INT(4)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 4, 0, "ILK_RX_LNEX_INT(4)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 4, 0, "ILK_RX_LNEX_INT(4)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 4, 0, "ILK_RX_LNEX_INT(4)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 4, 0, "ILK_RX_LNEX_INT(4)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 4, 0, "ILK_RX_LNEX_INT(4)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 4, 0, "ILK_RX_LNEX_INT(4)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((5) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(5) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((5) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(5) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 5, "ILK_RX_LNEX_INT(5)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 5, "ILK_RX_LNEX_INT(5)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 5, "ILK_RX_LNEX_INT(5)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 5, "ILK_RX_LNEX_INT(5)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 5, "ILK_RX_LNEX_INT(5)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 5, "ILK_RX_LNEX_INT(5)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 5, "ILK_RX_LNEX_INT(5)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 5, "ILK_RX_LNEX_INT(5)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 5, "ILK_RX_LNEX_INT(5)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 5, 0, "ILK_RX_LNEX_INT(5)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 5, 0, "ILK_RX_LNEX_INT(5)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 5, 0, "ILK_RX_LNEX_INT(5)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 5, 0, "ILK_RX_LNEX_INT(5)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 5, 0, "ILK_RX_LNEX_INT(5)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 5, 0, "ILK_RX_LNEX_INT(5)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 5, 0, "ILK_RX_LNEX_INT(5)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 5, 0, "ILK_RX_LNEX_INT(5)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 5, 0, "ILK_RX_LNEX_INT(5)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((6) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(6) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((6) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(6) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 6, "ILK_RX_LNEX_INT(6)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 6, "ILK_RX_LNEX_INT(6)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 6, "ILK_RX_LNEX_INT(6)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 6, "ILK_RX_LNEX_INT(6)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 6, "ILK_RX_LNEX_INT(6)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 6, "ILK_RX_LNEX_INT(6)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 6, "ILK_RX_LNEX_INT(6)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 6, "ILK_RX_LNEX_INT(6)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 6, "ILK_RX_LNEX_INT(6)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 6, 0, "ILK_RX_LNEX_INT(6)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 6, 0, "ILK_RX_LNEX_INT(6)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 6, 0, "ILK_RX_LNEX_INT(6)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 6, 0, "ILK_RX_LNEX_INT(6)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 6, 0, "ILK_RX_LNEX_INT(6)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 6, 0, "ILK_RX_LNEX_INT(6)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 6, 0, "ILK_RX_LNEX_INT(6)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 6, 0, "ILK_RX_LNEX_INT(6)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 6, 0, "ILK_RX_LNEX_INT(6)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((7) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT(7) */, CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((7) & 7) * 1024 /* CVMX_ILK_RX_LNEX_INT_EN(7) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 7, "ILK_RX_LNEX_INT(7)[SERDES_LOCK_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 7, "ILK_RX_LNEX_INT(7)[BDRY_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 7, "ILK_RX_LNEX_INT(7)[CRC32_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 7, "ILK_RX_LNEX_INT(7)[UKWN_CNTL_WORD]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 7, "ILK_RX_LNEX_INT(7)[SCRM_SYNC_LOSS]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 7, "ILK_RX_LNEX_INT(7)[DSKEW_FIFO_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 7, "ILK_RX_LNEX_INT(7)[STAT_MSG]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 7, "ILK_RX_LNEX_INT(7)[STAT_CNT_OVFL]"},
-							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 7, "ILK_RX_LNEX_INT(7)[BAD_64B67B]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 0, 7, 0, "ILK_RX_LNEX_INT(7)[SERDES_LOCK_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 1, 7, 0, "ILK_RX_LNEX_INT(7)[BDRY_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 2, 7, 0, "ILK_RX_LNEX_INT(7)[CRC32_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 3, 7, 0, "ILK_RX_LNEX_INT(7)[UKWN_CNTL_WORD]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 4, 7, 0, "ILK_RX_LNEX_INT(7)[SCRM_SYNC_LOSS]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 5, 7, 0, "ILK_RX_LNEX_INT(7)[DSKEW_FIFO_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 6, 7, 0, "ILK_RX_LNEX_INT(7)[STAT_MSG]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 7, 7, 0, "ILK_RX_LNEX_INT(7)[STAT_CNT_OVFL]"},
+							{1, 1, CVMX_ERROR_GROUP_ILK, 8, 7, 0, "ILK_RX_LNEX_INT(7)[BAD_64B67B]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* agl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800E0000518ull) /* CVMX_AGL_GMX_BAD_REG */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, "AGL_GMX_BAD_REG[TXPOP]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, "AGL_GMX_BAD_REG[TXPSH]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 32, 0, 0, "AGL_GMX_BAD_REG[OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 33, 0, 0, "AGL_GMX_BAD_REG[TXPOP]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 34, 0, 0, "AGL_GMX_BAD_REG[TXPSH]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 35, 0, 0, "AGL_GMX_BAD_REG[OVRFLW1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 36, 0, 0, "AGL_GMX_BAD_REG[TXPOP1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 37, 0, 0, "AGL_GMX_BAD_REG[TXPSH1]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_BAD_REG[OUT_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 22, 0, 0, "AGL_GMX_BAD_REG[LOSTSTAT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((0) & 0) * 2048 /* CVMX_AGL_GMX_RXX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 8, 0, 0, "AGL_GMX_RXX_INT_REG(0)[SKPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 10, 0, 0, "AGL_GMX_RXX_INT_REG(0)[OVRERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x00011800E0000500ull) /* CVMX_AGL_GMX_TX_INT_REG */, CVMX_ADD_IO_SEG(0x00011800E0000508ull) /* CVMX_AGL_GMX_TX_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
-							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 0, 0, 0, "AGL_GMX_TX_INT_REG[PKO_NXA]"},
+							{1, 1, CVMX_ERROR_GROUP_MGMT_PORT, 2, 0, 0, "AGL_GMX_TX_INT_REG[UNDFLW]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -12122,36 +12122,36 @@ static struct cvmx_error_muxchild error_tree_cn68xx =
 			{CVMX_ADD_IO_SEG(0x0001070100085000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_MEM(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 3 /* lmc:3 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((3) & 3) * 0x1000000ull /* CVMX_LMCX_INT(3) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((3) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(3) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 3, "LMCX_INT(3)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 3, "LMCX_INT(3)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 3, "LMCX_INT(3)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 3, CVMX_ERROR_TYPE_SBE, "LMCX_INT(3)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 3, 0, "LMCX_INT(3)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 3, CVMX_ERROR_TYPE_DBE, "LMCX_INT(3)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 2 /* lmc:2 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((2) & 3) * 0x1000000ull /* CVMX_LMCX_INT(2) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((2) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(2) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 2, "LMCX_INT(2)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 2, "LMCX_INT(2)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 2, "LMCX_INT(2)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 2, CVMX_ERROR_TYPE_SBE, "LMCX_INT(2)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 2, 0, "LMCX_INT(2)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 2, CVMX_ERROR_TYPE_DBE, "LMCX_INT(2)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 1 /* lmc:1 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((1) & 3) * 0x1000000ull /* CVMX_LMCX_INT(1) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((1) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(1) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 1, "LMCX_INT(1)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 1, "LMCX_INT(1)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 1, "LMCX_INT(1)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 1, CVMX_ERROR_TYPE_SBE, "LMCX_INT(1)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 1, 0, "LMCX_INT(1)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 1, CVMX_ERROR_TYPE_DBE, "LMCX_INT(1)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 0 /* lmc:0 */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800880001F0ull) + ((0) & 3) * 0x1000000ull /* CVMX_LMCX_INT(0) */, CVMX_ADD_IO_SEG(0x00011800880001E8ull) + ((0) & 3) * 0x1000000ull /* CVMX_LMCX_INT_EN(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, "LMCX_INT(0)[SEC_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, "LMCX_INT(0)[DED_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 1, 0, CVMX_ERROR_TYPE_SBE, "LMCX_INT(0)[SEC_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 0, 0, 0, "LMCX_INT(0)[NXM_WR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_LMC, 5, 0, CVMX_ERROR_TYPE_DBE, "LMCX_INT(0)[DED_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -12161,132 +12161,132 @@ static struct cvmx_error_muxchild error_tree_cn68xx =
 			{CVMX_ADD_IO_SEG(0x0001070100082000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_RML(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 48 /* l2c */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180080800018ull) /* CVMX_L2C_INT_REG */, CVMX_ADD_IO_SEG(0x0001180080800020ull) /* CVMX_L2C_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_INT_REG[HOLERD]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_INT_REG[HOLEWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_INT_REG[VRTWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_INT_REG[VRTIDRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_INT_REG[VRTADRNG]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_INT_REG[VRTPE]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_INT_REG[BIGWR]"},
-							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_INT_REG[BIGRD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, 0, "L2C_INT_REG[HOLERD]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, 0, "L2C_INT_REG[HOLEWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, 0, "L2C_INT_REG[VRTWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, 0, "L2C_INT_REG[VRTIDRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, 0, "L2C_INT_REG[VRTADRNG]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, 0, "L2C_INT_REG[VRTPE]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_INT_REG[BIGWR]"},
+							{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_INT_REG[BIGRD]"},
 							{0}},
 						(struct cvmx_error_childbit[]){
 						{1, 17 /* tad1 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(1) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(1) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 1, "L2C_TADX_INT(1)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 1, "L2C_TADX_INT(1)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 1, "L2C_TADX_INT(1)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 1, "L2C_TADX_INT(1)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 1, "L2C_TADX_INT(1)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 1, "L2C_TADX_INT(1)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 1, "L2C_TADX_INT(1)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 1, "L2C_TADX_INT(1)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 1, "L2C_TADX_INT(1)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 1, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(1)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 1, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(1)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 1, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(1)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 1, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(1)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 1, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(1)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 1, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(1)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 1, 0, "L2C_TADX_INT(1)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 1, 0, "L2C_TADX_INT(1)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 1, 0, "L2C_TADX_INT(1)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 1, "L2C_ERR_TDTX(1)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, "L2C_ERR_TDTX(1)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, "L2C_ERR_TDTX(1)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, "L2C_ERR_TDTX(1)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 1, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(1)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(1)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(1)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(1)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((1) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(1) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, "L2C_ERR_TTGX(1)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, "L2C_ERR_TTGX(1)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, "L2C_ERR_TTGX(1)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 1, 0, "L2C_ERR_TTGX(1)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 1, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(1)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 1, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(1)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 16 /* tad0 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(0) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(0) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, "L2C_TADX_INT(0)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, "L2C_TADX_INT(0)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, "L2C_TADX_INT(0)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, "L2C_TADX_INT(0)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, "L2C_TADX_INT(0)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, "L2C_TADX_INT(0)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, "L2C_TADX_INT(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 0, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(0)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 0, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(0)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 0, 0, "L2C_TADX_INT(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 0, 0, "L2C_TADX_INT(0)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 0, 0, "L2C_TADX_INT(0)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, "L2C_ERR_TDTX(0)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TDTX(0)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TDTX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TDTX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((0) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(0) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, "L2C_ERR_TTGX(0)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, "L2C_ERR_TTGX(0)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 0, 0, "L2C_ERR_TTGX(0)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 0, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(0)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 0, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(0)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 19 /* tad3 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(3) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(3) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 3, "L2C_TADX_INT(3)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 3, "L2C_TADX_INT(3)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 3, "L2C_TADX_INT(3)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 3, "L2C_TADX_INT(3)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 3, "L2C_TADX_INT(3)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 3, "L2C_TADX_INT(3)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 3, "L2C_TADX_INT(3)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 3, "L2C_TADX_INT(3)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 3, "L2C_TADX_INT(3)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 3, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(3)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 3, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(3)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 3, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(3)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 3, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(3)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 3, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(3)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 3, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(3)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 3, 0, "L2C_TADX_INT(3)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 3, 0, "L2C_TADX_INT(3)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 3, 0, "L2C_TADX_INT(3)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(3) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 3, "L2C_ERR_TDTX(3)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, "L2C_ERR_TDTX(3)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, "L2C_ERR_TDTX(3)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, "L2C_ERR_TDTX(3)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 3, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(3)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(3)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(3)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(3)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((3) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(3) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, "L2C_ERR_TTGX(3)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, "L2C_ERR_TTGX(3)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, "L2C_ERR_TTGX(3)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 3, 0, "L2C_ERR_TTGX(3)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 3, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(3)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 3, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(3)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{0}}},
 						{1, 18 /* tad2 */, (struct cvmx_error_muxchild[]){
 							{CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_TADX_INT(2) */, CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_TADX_IEN(2) */, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 2, "L2C_TADX_INT(2)[L2DSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 2, "L2C_TADX_INT(2)[L2DDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 2, "L2C_TADX_INT(2)[TAGSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 2, "L2C_TADX_INT(2)[TAGDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 2, "L2C_TADX_INT(2)[VBFSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 2, "L2C_TADX_INT(2)[VBFDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 2, "L2C_TADX_INT(2)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 2, "L2C_TADX_INT(2)[RDDISLMC]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 2, "L2C_TADX_INT(2)[WRDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 0, 2, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(2)[L2DSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 1, 2, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(2)[L2DDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 2, 2, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(2)[TAGSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 3, 2, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(2)[TAGDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 4, 2, CVMX_ERROR_TYPE_SBE, "L2C_TADX_INT(2)[VBFSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 5, 2, CVMX_ERROR_TYPE_DBE, "L2C_TADX_INT(2)[VBFDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 6, 2, 0, "L2C_TADX_INT(2)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 7, 2, 0, "L2C_TADX_INT(2)[RDDISLMC]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 8, 2, 0, "L2C_TADX_INT(2)[WRDISLMC]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_ERR_TDTX(2) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 2, "L2C_ERR_TDTX(2)[VSBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, "L2C_ERR_TDTX(2)[VDBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, "L2C_ERR_TDTX(2)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, "L2C_ERR_TDTX(2)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 60, 2, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(2)[VSBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(2)[VDBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TDTX(2)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TDTX(2)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
 							{CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((2) & 3) * 0x40000ull /* CVMX_L2C_ERR_TTGX(2) */, 0, (struct cvmx_error_regbit[]){
-									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, "L2C_ERR_TTGX(2)[NOWAY]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, "L2C_ERR_TTGX(2)[SBE]"},
-									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, "L2C_ERR_TTGX(2)[DBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 61, 2, 0, "L2C_ERR_TTGX(2)[NOWAY]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 62, 2, CVMX_ERROR_TYPE_SBE, "L2C_ERR_TTGX(2)[SBE]"},
+									{1, 1, CVMX_ERROR_GROUP_L2C, 63, 2, CVMX_ERROR_TYPE_DBE, "L2C_ERR_TTGX(2)[DBE]"},
 									{0}},
 								NULL /*cvmx_error_childbit*/
 							},
@@ -12296,250 +12296,250 @@ static struct cvmx_error_muxchild error_tree_cn68xx =
 					{0}}},
 				{1, 4 /* fpa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180028000040ull) /* CVMX_FPA_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180028000048ull) /* CVMX_FPA_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "FPA_INT_SUM[FED0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "FPA_INT_SUM[FED0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "FPA_INT_SUM[FED1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "FPA_INT_SUM[FED1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "FPA_INT_SUM[Q0_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "FPA_INT_SUM[Q0_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "FPA_INT_SUM[Q0_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "FPA_INT_SUM[Q1_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "FPA_INT_SUM[Q1_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "FPA_INT_SUM[Q1_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "FPA_INT_SUM[Q2_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "FPA_INT_SUM[Q2_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "FPA_INT_SUM[Q2_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "FPA_INT_SUM[Q3_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "FPA_INT_SUM[Q3_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "FPA_INT_SUM[Q3_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "FPA_INT_SUM[Q4_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "FPA_INT_SUM[Q4_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "FPA_INT_SUM[Q4_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "FPA_INT_SUM[Q5_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "FPA_INT_SUM[Q5_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "FPA_INT_SUM[Q5_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "FPA_INT_SUM[Q6_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, "FPA_INT_SUM[Q6_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "FPA_INT_SUM[Q6_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "FPA_INT_SUM[Q7_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, "FPA_INT_SUM[Q7_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, "FPA_INT_SUM[Q7_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, "FPA_INT_SUM[POOL0TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, "FPA_INT_SUM[POOL1TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, "FPA_INT_SUM[POOL2TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, "FPA_INT_SUM[POOL3TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "FPA_INT_SUM[POOL4TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, "FPA_INT_SUM[POOL5TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, "FPA_INT_SUM[POOL6TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, "FPA_INT_SUM[POOL7TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, "FPA_INT_SUM[FREE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, "FPA_INT_SUM[FREE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, "FPA_INT_SUM[FREE2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, "FPA_INT_SUM[FREE3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, "FPA_INT_SUM[FREE4]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, "FPA_INT_SUM[FREE5]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, "FPA_INT_SUM[FREE6]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, "FPA_INT_SUM[FREE7]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 44, 0, "FPA_INT_SUM[FREE8]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, "FPA_INT_SUM[Q8_UND]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, "FPA_INT_SUM[Q8_COFF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, "FPA_INT_SUM[Q8_PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "FPA_INT_SUM[POOL8TH]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "FPA_INT_SUM[PADDR_E]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "FPA_INT_SUM[FED1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "FPA_INT_SUM[FED1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "FPA_INT_SUM[Q0_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "FPA_INT_SUM[Q0_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "FPA_INT_SUM[Q0_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "FPA_INT_SUM[Q1_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "FPA_INT_SUM[Q1_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "FPA_INT_SUM[Q1_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "FPA_INT_SUM[Q2_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "FPA_INT_SUM[Q2_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "FPA_INT_SUM[Q2_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "FPA_INT_SUM[Q3_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "FPA_INT_SUM[Q3_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "FPA_INT_SUM[Q3_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "FPA_INT_SUM[Q4_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "FPA_INT_SUM[Q4_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "FPA_INT_SUM[Q4_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "FPA_INT_SUM[Q5_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "FPA_INT_SUM[Q5_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "FPA_INT_SUM[Q5_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "FPA_INT_SUM[Q6_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 23, 0, 0, "FPA_INT_SUM[Q6_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "FPA_INT_SUM[Q6_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "FPA_INT_SUM[Q7_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 26, 0, 0, "FPA_INT_SUM[Q7_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 27, 0, 0, "FPA_INT_SUM[Q7_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 28, 0, 0, "FPA_INT_SUM[POOL0TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 29, 0, 0, "FPA_INT_SUM[POOL1TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 30, 0, 0, "FPA_INT_SUM[POOL2TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 31, 0, 0, "FPA_INT_SUM[POOL3TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "FPA_INT_SUM[POOL4TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 33, 0, 0, "FPA_INT_SUM[POOL5TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 34, 0, 0, "FPA_INT_SUM[POOL6TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 35, 0, 0, "FPA_INT_SUM[POOL7TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 36, 0, 0, "FPA_INT_SUM[FREE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 37, 0, 0, "FPA_INT_SUM[FREE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 38, 0, 0, "FPA_INT_SUM[FREE2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 39, 0, 0, "FPA_INT_SUM[FREE3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 40, 0, 0, "FPA_INT_SUM[FREE4]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 41, 0, 0, "FPA_INT_SUM[FREE5]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 42, 0, 0, "FPA_INT_SUM[FREE6]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 43, 0, 0, "FPA_INT_SUM[FREE7]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 44, 0, 0, "FPA_INT_SUM[FREE8]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, 0, "FPA_INT_SUM[Q8_UND]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, 0, "FPA_INT_SUM[Q8_COFF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, 0, "FPA_INT_SUM[Q8_PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "FPA_INT_SUM[POOL8TH]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "FPA_INT_SUM[PADDR_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 24 /* zip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180038000088ull) /* CVMX_ZIP_ERROR */, CVMX_ADD_IO_SEG(0x0001180038000090ull) /* CVMX_ZIP_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "ZIP_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "ZIP_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180038000570ull) /* CVMX_ZIP_INT_REG */, CVMX_ADD_IO_SEG(0x0001180038000580ull) /* CVMX_ZIP_INT_ENA */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "ZIP_INT_REG[IBSBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "ZIP_INT_REG[IBDBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "ZIP_INT_REG[DOORBELL0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "ZIP_INT_REG[DOORBELL1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_SBE, "ZIP_INT_REG[IBSBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_DBE, "ZIP_INT_REG[IBDBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "ZIP_INT_REG[DOORBELL0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "ZIP_INT_REG[DOORBELL1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 5 /* ipd */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00014F0000000168ull) /* CVMX_IPD_INT_SUM */, CVMX_ADD_IO_SEG(0x00014F0000000160ull) /* CVMX_IPD_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "IPD_INT_SUM[PRC_PAR1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "IPD_INT_SUM[PRC_PAR2]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "IPD_INT_SUM[PRC_PAR3]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "IPD_INT_SUM[BP_SUB]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "IPD_INT_SUM[DC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "IPD_INT_SUM[CC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "IPD_INT_SUM[C_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "IPD_INT_SUM[D_COLL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "IPD_INT_SUM[BC_OVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "IPD_INT_SUM[SOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "IPD_INT_SUM[EOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "IPD_INT_SUM[DAT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "IPD_INT_SUM[PW0_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "IPD_INT_SUM[PW0_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "IPD_INT_SUM[PW1_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "IPD_INT_SUM[PW1_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "IPD_INT_SUM[PW2_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "IPD_INT_SUM[PW2_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "IPD_INT_SUM[PW3_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "IPD_INT_SUM[PW3_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "IPD_INT_SUM[PRC_PAR0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "IPD_INT_SUM[PRC_PAR1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "IPD_INT_SUM[PRC_PAR2]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "IPD_INT_SUM[PRC_PAR3]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "IPD_INT_SUM[BP_SUB]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "IPD_INT_SUM[DC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "IPD_INT_SUM[CC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "IPD_INT_SUM[C_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "IPD_INT_SUM[D_COLL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "IPD_INT_SUM[BC_OVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "IPD_INT_SUM[SOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "IPD_INT_SUM[EOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "IPD_INT_SUM[DAT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW0_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW0_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW1_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW1_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW2_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW2_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, CVMX_ERROR_TYPE_SBE, "IPD_INT_SUM[PW3_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, CVMX_ERROR_TYPE_DBE, "IPD_INT_SUM[PW3_DBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 29 /* rad */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180070000088ull) /* CVMX_RAD_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180070000090ull) /* CVMX_RAD_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "RAD_REG_ERROR[DOORBELL]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 28 /* tim */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180058000030ull) /* CVMX_TIM_INT0 */, CVMX_ADD_IO_SEG(0x0001180058000038ull) /* CVMX_TIM_INT0_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_INT0[INT0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "TIM_INT0[INT0]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001180058000060ull) /* CVMX_TIM_INT_ECCERR */, CVMX_ADD_IO_SEG(0x0001180058000068ull) /* CVMX_TIM_INT_ECCERR_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "TIM_INT_ECCERR[SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "TIM_INT_ECCERR[DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "TIM_INT_ECCERR[SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "TIM_INT_ECCERR[DBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 16 /* sso */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000001038ull) /* CVMX_SSO_ERR */, CVMX_ADD_IO_SEG(0x0001670000001030ull) /* CVMX_SSO_ERR_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, "SSO_ERR[IOP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "SSO_ERR[FIDX_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "SSO_ERR[IDX_SBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "SSO_ERR[PND_DBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "SSO_ERR[OTH_SBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "SSO_ERR[OTH_DBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "SSO_ERR[OTH_SBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "SSO_ERR[OTH_DBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "SSO_ERR[PND_SBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "SSO_ERR[PND_DBE1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "SSO_ERR[PND_SBE0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, "SSO_ERR[FPE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, "SSO_ERR[AWE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, "SSO_ERR[BFP]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "SSO_ERR[IDX_DBE]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "SSO_ERR[FIDX_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 32, 0, 0, "SSO_ERR[IOP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[FIDX_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[IDX_SBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[PND_DBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[OTH_SBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[OTH_DBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[OTH_SBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[OTH_DBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[PND_SBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[PND_DBE1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[PND_SBE0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 45, 0, 0, "SSO_ERR[FPE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 46, 0, 0, "SSO_ERR[AWE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 47, 0, 0, "SSO_ERR[BFP]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, "SSO_ERR[IDX_DBE]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, "SSO_ERR[FIDX_SBE]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 32 /* sli */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011F0000010330ull) /* CVMX_PEXP_SLI_INT_SUM */, CVMX_ADD_IO_SEG(0x00011F0000013CD0ull) /* CVMX_PEXP_SLI_INT_ENB_CIU */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 61, 0, "PEXP_SLI_INT_SUM[PIPE_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PEXP_SLI_INT_SUM[RML_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PEXP_SLI_INT_SUM[BAR0_TO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PEXP_SLI_INT_SUM[IOB2BIG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "PEXP_SLI_INT_SUM[M0_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 10, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 11, 0, 0, "PEXP_SLI_INT_SUM[M0_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "PEXP_SLI_INT_SUM[M1_UP_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_B0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 15, 0, 0, "PEXP_SLI_INT_SUM[M1_UN_WI]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 48, 0, 0, "PEXP_SLI_INT_SUM[PIDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 49, 0, 0, "PEXP_SLI_INT_SUM[PSLDBOF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 50, 0, 0, "PEXP_SLI_INT_SUM[POUT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 52, 0, 0, "PEXP_SLI_INT_SUM[PGL_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 53, 0, 0, "PEXP_SLI_INT_SUM[PDI_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 54, 0, 0, "PEXP_SLI_INT_SUM[POP_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 55, 0, 0, "PEXP_SLI_INT_SUM[PINS_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 56, 0, 0, "PEXP_SLI_INT_SUM[SPRT0_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 57, 0, 0, "PEXP_SLI_INT_SUM[SPRT1_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 60, 0, 0, "PEXP_SLI_INT_SUM[ILL_PAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 61, 0, 0, "PEXP_SLI_INT_SUM[PIPE_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 30 /* key */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180020000000ull) /* CVMX_KEY_INT_SUM */, CVMX_ADD_IO_SEG(0x0001180020000008ull) /* CVMX_KEY_INT_ENB */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, NULL},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, CVMX_ERROR_TYPE_DBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, CVMX_ERROR_TYPE_SBE, NULL},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, CVMX_ERROR_TYPE_DBE, NULL},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 6 /* pip */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800A0000008ull) /* CVMX_PIP_INT_REG */, CVMX_ADD_IO_SEG(0x00011800A0000010ull) /* CVMX_PIP_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PIP_INT_REG[PRTNXA]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "PIP_INT_REG[BADTAG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "PIP_INT_REG[SKPRUNT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "PIP_INT_REG[TODOOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "PIP_INT_REG[FEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "PIP_INT_REG[BEPERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, "PIP_INT_REG[PUNYERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PIP_INT_REG[PRTNXA]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "PIP_INT_REG[BADTAG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "PIP_INT_REG[SKPRUNT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "PIP_INT_REG[TODOOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "PIP_INT_REG[FEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "PIP_INT_REG[BEPERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 12, 0, 0, "PIP_INT_REG[PUNYERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 40 /* dfa */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180037000028ull) /* CVMX_DFA_ERROR */, CVMX_ADD_IO_SEG(0x0001180037000030ull) /* CVMX_DFA_INTMSK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DFA_ERROR[DBLOVF]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DFA_ERROR[DC0PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "DFA_ERROR[DC1PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, "DFA_ERROR[DC2PERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, "DFA_ERROR[DLC0_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, "DFA_ERROR[DLC1_OVFERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DFA_ERROR[DFANXM]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DFA_ERROR[REPLERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DFA_ERROR[DBLOVF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DFA_ERROR[DC0PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "DFA_ERROR[DC1PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 7, 0, 0, "DFA_ERROR[DC2PERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 13, 0, 0, "DFA_ERROR[DLC0_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 14, 0, 0, "DFA_ERROR[DLC1_OVFERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DFA_ERROR[DFANXM]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DFA_ERROR[REPLERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 7 /* pko */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180050000088ull) /* CVMX_PKO_REG_ERROR */, CVMX_ADD_IO_SEG(0x0001180050000090ull) /* CVMX_PKO_REG_INT_MASK */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "PKO_REG_ERROR[PARITY]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "PKO_REG_ERROR[DOORBELL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "PKO_REG_ERROR[CURRZERO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "PKO_REG_ERROR[LOOPBACK]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "PKO_REG_ERROR[PARITY]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "PKO_REG_ERROR[DOORBELL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "PKO_REG_ERROR[CURRZERO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "PKO_REG_ERROR[LOOPBACK]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 33 /* dpi */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001DF0000000008ull) /* CVMX_DPI_INT_REG */, CVMX_ADD_IO_SEG(0x0001DF0000000010ull) /* CVMX_DPI_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_INT_REG[NDERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "DPI_INT_REG[NFOVR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "DPI_INT_REG[DMADBO]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "DPI_INT_REG[REQ_BADADR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, "DPI_INT_REG[REQ_BADLEN]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, "DPI_INT_REG[REQ_OVRFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, "DPI_INT_REG[REQ_UNDFLW]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, "DPI_INT_REG[REQ_ANULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, "DPI_INT_REG[REQ_INULL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, "DPI_INT_REG[REQ_BADFIL]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, "DPI_INT_REG[SPRT0_RST]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, "DPI_INT_REG[SPRT1_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_INT_REG[NDERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "DPI_INT_REG[NFOVR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "DPI_INT_REG[DMADBO]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, 0, "DPI_INT_REG[REQ_BADADR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 17, 0, 0, "DPI_INT_REG[REQ_BADLEN]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 18, 0, 0, "DPI_INT_REG[REQ_OVRFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 19, 0, 0, "DPI_INT_REG[REQ_UNDFLW]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 20, 0, 0, "DPI_INT_REG[REQ_ANULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 21, 0, 0, "DPI_INT_REG[REQ_INULL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 22, 0, 0, "DPI_INT_REG[REQ_BADFIL]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 24, 0, 0, "DPI_INT_REG[SPRT0_RST]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 25, 0, 0, "DPI_INT_REG[SPRT1_RST]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000078ull) /* CVMX_DPI_PKT_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_PKT_ERR_RSP[PKTERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000058ull) /* CVMX_DPI_REQ_ERR_RSP */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RSP[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{CVMX_ADD_IO_SEG(0x0001DF0000000060ull) /* CVMX_DPI_REQ_ERR_RST */, 0, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "DPI_REQ_ERR_RST[QERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
@@ -12549,50 +12549,50 @@ static struct cvmx_error_muxchild error_tree_cn68xx =
 			{CVMX_ADD_IO_SEG(0x0001070100083000ull) + ((0) & 31) * 0x200000ull /* CVMX_CIU2_SRC_PPX_IP2_MIO(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 63 /* rst */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001180000001628ull) /* CVMX_MIO_RST_INT */, CVMX_ADD_IO_SEG(0x0001180000001630ull) /* CVMX_MIO_RST_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_RST_INT[RST_LINK0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_RST_INT[RST_LINK1]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, "MIO_RST_INT[PERST0]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, "MIO_RST_INT[PERST1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_RST_INT[RST_LINK0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_RST_INT[RST_LINK1]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 8, 0, 0, "MIO_RST_INT[PERST0]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 9, 0, 0, "MIO_RST_INT[PERST1]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 1 /* ssoiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000001048ull) /* CVMX_SSO_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000001050ull) /* CVMX_SSO_IQ_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "SSO_IQ_INT[IQ_INT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "SSO_IQ_INT[IQ_INT]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 16 /* nand */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001070001000020ull) /* CVMX_NDF_INT */, CVMX_ADD_IO_SEG(0x0001070001000028ull) /* CVMX_NDF_INT_EN */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, "NDF_INT[WDOG]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, "NDF_INT[SM_BAD]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, "NDF_INT[ECC_1BIT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, "NDF_INT[ECC_MULT]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, "NDF_INT[OVRF]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 2, 0, 0, "NDF_INT[WDOG]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 3, 0, 0, "NDF_INT[SM_BAD]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 4, 0, 0, "NDF_INT[ECC_1BIT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 5, 0, 0, "NDF_INT[ECC_MULT]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 6, 0, 0, "NDF_INT[OVRF]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 17 /* mio */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x00011800000000A0ull) /* CVMX_MIO_BOOT_ERR */, CVMX_ADD_IO_SEG(0x00011800000000A8ull) /* CVMX_MIO_BOOT_INT */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
-							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, 0, "MIO_BOOT_ERR[ADR_ERR]"},
+							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 1, 0, 0, "MIO_BOOT_ERR[WAIT_ERR]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
 					{0}}},
 				{1, 40 /* usb_uctl */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x000118006F000020ull) /* CVMX_UCTLX_INT_REG(0) */, CVMX_ADD_IO_SEG(0x000118006F000028ull) /* CVMX_UCTLX_INT_ENA(0) */, (struct cvmx_error_regbit[]){
-							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
-							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 0, 0, 0, "UCTLX_INT_REG(0)[PP_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 1, 0, 0, "UCTLX_INT_REG(0)[ER_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 2, 0, 0, "UCTLX_INT_REG(0)[OR_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 3, 0, 0, "UCTLX_INT_REG(0)[CF_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 4, 0, 0, "UCTLX_INT_REG(0)[WB_PSH_F]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 5, 0, 0, "UCTLX_INT_REG(0)[WB_POP_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 6, 0, 0, "UCTLX_INT_REG(0)[OC_OVF_E]"},
+							{1, 1, CVMX_ERROR_GROUP_USB, 7, 0, 0, "UCTLX_INT_REG(0)[EC_OVF_E]"},
 							{0}},
 						NULL /*cvmx_error_childbit*/
 					},
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 8d92a4295fdc..7f8c4854dc07 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 167433 $<hr>
+ * <hr>$Revision: 170015 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1908,19 +1908,20 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	}
 
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX)
-	    && OCTEON_IS_MODEL(OCTEON_CN73XX)
-	    && OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
+	    || OCTEON_IS_MODEL(OCTEON_CN73XX)
+	    || OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
 		cvmx_pciercx_cfg038_t pciercx_cfg038;
-		cvmx_sli_window_ctl_t sli_window_ctl;
+		cvmx_pciercx_cfg548_t cfg548;
 
 		pciercx_cfg032.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
 					CVMX_PCIERCX_CFG032(pcie_port));
 		/* Errata PEM-28816: Link retrain initiated at GEN1 can cause PCIE
 		   link to hang. For Gen1 links we must disable equalization */
 		if (pciercx_cfg032.s.ls == 1) {
-			cvmx_pciercx_cfg548_t cfg548;
+#if 0
 			cvmx_dprintf("%d:%d:PCIe: Disabling equalization for GEN1 Link\n",
 					node, pcie_port);
+#endif
 			cfg548.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
 					CVMX_PCIERCX_CFG548(pcie_port));
 			cfg548.s.ed = 1;
@@ -1936,12 +1937,10 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		CVMX_PCIE_CFGX_WRITE(pcie_port, CVMX_PCIERCX_CFG038(pcie_port),
 					pciercx_cfg038.u32);
 
-		/* Errata PEM-31375 PEM RSL accesses to PCLK registers can
-		   timeout during speed change. Change SLI_WINDOW_CTL[time]
-		   to 525us */
-		sli_window_ctl.u64 = CVMX_READ_CSR(CVMX_PEXP_SLI_WINDOW_CTL);
-		sli_window_ctl.s.time = cvmx_clock_get_rate(CVMX_CLOCK_SCLK) * 525 / 1000000;
-		CVMX_WRITE_CSR(CVMX_PEXP_SLI_WINDOW_CTL, sli_window_ctl.u64);
+		/* Errata PCIE-29566 PEM Link Hangs after going into L1 */
+		cfg548.u32 = CVMX_PCIE_CFGX_READ(pcie_port, CVMX_PCIERCX_CFG548(pcie_port));
+		cfg548.s.grizdnc = 0;
+		CVMX_PCIE_CFGX_WRITE(pcie_port, CVMX_PCIERCX_CFG548(pcie_port), cfg548.u32);
 	}
 
 	/* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 58d54bfdd4f1..e63ea649fcb8 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -841,6 +841,7 @@ static int cvmx_pko_setup_macs(int node)
 		unsigned pko_fifo_cnt, fifo_size;
 		unsigned mac_fifo_cnt;
 		unsigned tmp;
+		int saved_fifo_num;
 
 		pko_fifo_cnt = cvmx_pko3_mac_table[mac_num].fifo_cnt;
 		mac_fifo_cnt = cvmx_pko3_mac_table[mac_num].mac_fifo_cnt;
@@ -918,16 +919,34 @@ static int cvmx_pko_setup_macs(int node)
 		tmp = (skid_credit / 256) >> 1; /* valid 0,1,2 */
 		pko_mac_cfg.u64 =
 			cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(mac_num));
+
+		/* The PKO_MACX_CFG bits cannot be changed unless FIFO_MUM=0x1f (unused fifo) */
+		saved_fifo_num = pko_mac_cfg.s.fifo_num;
+		pko_mac_cfg.s.fifo_num = 0x1f;
 		pko_mac_cfg.s.skid_max_cnt = tmp;
 		cvmx_write_csr_node(node, CVMX_PKO_MACX_CFG(mac_num),
 			pko_mac_cfg.u64);
 
-		if(debug) cvmx_dprintf(
-			"%s: mac %u PKO_MCI0_MAX_CREDX=%u PKO_MCI1_MAX_CREDX=%u PKO_MACX_CFG[SKID_MAX_CNT]=%u\n",
+		pko_mac_cfg.u64 =
+			cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(mac_num));
+		pko_mac_cfg.s.fifo_num = saved_fifo_num;
+		cvmx_write_csr_node(node, CVMX_PKO_MACX_CFG(mac_num),
+			pko_mac_cfg.u64);
+
+		if (debug) {
+			pko_mci0_max_cred.u64 =
+			     cvmx_read_csr_node(node, CVMX_PKO_MCI0_MAX_CREDX(mac_num));
+			pko_mci1_max_cred.u64 =
+			     cvmx_read_csr_node(node, CVMX_PKO_MCI1_MAX_CREDX(mac_num));
+			pko_mac_cfg.u64 =
+			     cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(mac_num));
+			cvmx_dprintf(
+			     "%s: mac %u PKO_MCI0_MAX_CREDX=%u PKO_MCI1_MAX_CREDX=%u PKO_MACX_CFG[SKID_MAX_CNT]=%u\n",
 			__FUNCTION__,  mac_num,
 			pko_mci0_max_cred.s.max_cred_lim,
 			pko_mci1_max_cred.s.max_cred_lim,
 			pko_mac_cfg.s.skid_max_cnt);
+		}
 	} /* for mac_num */
 
 	return 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index d57c3645ddba..0707d577ad41 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 167267 $<hr>
+ * <hr>$Revision: 169703 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -2353,16 +2353,16 @@ int __cvmx_qlm_rx_equalization(int node, int qlm, int lane)
 			rx_aeq_out_2.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_RX_AEQ_OUT_2(l, qlm));
 			rx_vma_status_0.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_RX_VMA_STATUS_0(l, qlm));
 			cvmx_dprintf("    DFE Tap1:%lu, Tap2:%ld, Tap3:%ld, Tap4:%ld, Tap5:%ld\n",
-					cvmx_bit_extract(rx_aeq_out_1.u64, 0, 5),
-					cvmx_bit_extract_smag(rx_aeq_out_1.u64, 5, 9),
-					cvmx_bit_extract_smag(rx_aeq_out_1.u64, 10, 14),
-					cvmx_bit_extract_smag(rx_aeq_out_0.u64, 0, 4),
-					cvmx_bit_extract_smag(rx_aeq_out_0.u64, 5, 9));
+					(unsigned int long)cvmx_bit_extract(rx_aeq_out_1.u64, 0, 5),
+					(unsigned int long)cvmx_bit_extract_smag(rx_aeq_out_1.u64, 5, 9),
+					(unsigned int long)cvmx_bit_extract_smag(rx_aeq_out_1.u64, 10, 14),
+					(unsigned int long)cvmx_bit_extract_smag(rx_aeq_out_0.u64, 0, 4),
+					(unsigned int long)cvmx_bit_extract_smag(rx_aeq_out_0.u64, 5, 9));
 			cvmx_dprintf("    Pre-CTLE Gain:%lu, Post-CTLE Gain:%lu, CTLE Peak:%lu, CTLE Pole:%lu\n",
-					cvmx_bit_extract(rx_aeq_out_2.u64, 4, 4),
-					cvmx_bit_extract(rx_aeq_out_2.u64, 0, 4),
-					cvmx_bit_extract(rx_vma_status_0.u64, 2, 4),
-					cvmx_bit_extract(rx_vma_status_0.u64, 0, 2));
+					(unsigned int long)cvmx_bit_extract(rx_aeq_out_2.u64, 4, 4),
+					(unsigned int long)cvmx_bit_extract(rx_aeq_out_2.u64, 0, 4),
+					(unsigned int long)cvmx_bit_extract(rx_vma_status_0.u64, 2, 4),
+					(unsigned int long)cvmx_bit_extract(rx_vma_status_0.u64, 0, 2));
 # endif
 #endif
 		}
diff --git a/arch/mips/include/asm/octeon/cvmx-agl-defs.h b/arch/mips/include/asm/octeon/cvmx-agl-defs.h
index 25d9dd9124fd..9c76d5be2324 100644
--- a/arch/mips/include/asm/octeon/cvmx-agl-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-agl-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-asxx-defs.h b/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
index 029760450d36..4d5eb9a35a97 100644
--- a/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-bch-defs.h b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
index 60af688589d3..d7f3206db2bf 100644
--- a/arch/mips/include/asm/octeon/cvmx-bch-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -336,7 +336,7 @@ union cvmx_bch_eco {
 	struct cvmx_bch_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< N/A */
+	uint64_t eco_rw                       : 32; /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index ac4a1adc2c6b..c5a80f2d3218 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -2594,7 +2594,7 @@ union cvmx_bgxx_cmrx_rx_adr_ctl {
                                                          0x3 = Reserved. */
 	uint64_t bcst_accept                  : 1;  /**< Allow or deny broadcast packets.
                                                          0 = Reject all broadcast packets.
-                                                         1 = Accept all broadcast Packets. */
+                                                         1 = Accept all broadcast packets. */
 #else
 	uint64_t bcst_accept                  : 1;
 	uint64_t mcst_mode                    : 2;
@@ -4385,7 +4385,7 @@ union cvmx_bgxx_gmp_gmi_rxx_int {
                                                          conditions are visible by 1) transfer ended before slottime - COLDET or 2) carrier extend
                                                          error - CAREXT. */
 	uint64_t falerr                       : 1;  /**< False-carrier error, or carrier-extend error after slottime is satisfied. SGMII/1000Base-X only. */
-	uint64_t rsverr                       : 1;  /**< Reserved opcode. */
+	uint64_t rsverr                       : 1;  /**< Detected reserved opcode. */
 	uint64_t pcterr                       : 1;  /**< Bad preamble/protocol error. Checks that the frame begins with a valid PREAMBLE sequence.
                                                          Does not check the number of PREAMBLE cycles. */
 	uint64_t ovrerr                       : 1;  /**< Internal data aggregation overflow. This interrupt should never assert. SGMII/1000Base-X only. */
@@ -4770,7 +4770,7 @@ union cvmx_bgxx_gmp_gmi_txx_slot {
 	struct cvmx_bgxx_gmp_gmi_txx_slot_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t slot                         : 10; /**< Slottime (refer to Std 802.3 to set correctly):
+	uint64_t slot                         : 10; /**< Slottime (refer to IEEE 802.3 to set correctly):
                                                          10/100 Mbs: Set SLOT to 0x40.
                                                          1000 Mbs: Set SLOT to 0x200.
                                                          SGMII/1000Base-X only. */
@@ -5237,14 +5237,11 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t sgmii                        : 1;  /**< SGMII mode.
-                                                         0 = other mode selected.
-                                                         1 = SGMII or 1000BASE-X mode selected.
-                                                         See GSER()_LANE_MODE[LMODE]. */
+	uint64_t sgmii                        : 1;  /**< Reserved. Always 0. */
 	uint64_t gmxeno                       : 1;  /**< GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
                                                          GMI is checked only at SOP of every packet. */
 	uint64_t loopbck2                     : 1;  /**< Sets external loopback mode to return RX data back out via the TX data path. 0 = No
-                                                         loopback, 1 = Loopback.
+                                                         loopback. 1 = Loopback.
                                                          LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
 	uint64_t mac_phy                      : 1;  /**< MAC/PHY.
                                                          0 = MAC.
@@ -5334,7 +5331,7 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                           1          0         1000 Mb/s
                                                           1          1         reserved
                                                          </pre> */
-	uint64_t uni                          : 1;  /**< Unidirectional (Std 802.3-2005, Clause 66.2). When set to 1, this bit overrides [AN_EN]
+	uint64_t uni                          : 1;  /**< Unidirectional (IEEE 802.3-2005, Clause 66.2). When set to 1, this bit overrides [AN_EN]
                                                          and
                                                          disables the autonegotiation variable mr_an_enable. Used in both 1000BASE-X and SGMII
                                                          modes. */
@@ -6004,13 +6001,13 @@ union cvmx_bgxx_smux_rx_int {
                                                          type for HiGig2.
                                                          FC_OBJECT field is neither 0x0 for physical link, nor 0x2 for logical link. Those are the
                                                          only two defined types in HiGig2 */
-	uint64_t bad_term                     : 1;  /**< Frame is terminated by control character other than /T/. (XAUI/RXAUI mode only) The error
+	uint64_t bad_term                     : 1;  /**< Frame is terminated by control character other than /T/. The error
                                                          propagation control character /E/ will be included as part of the frame and does not cause
                                                          a frame termination. */
-	uint64_t bad_seq                      : 1;  /**< Reserved sequence detected. (XAUI/RXAUI mode only) */
-	uint64_t rem_fault                    : 1;  /**< Remote-fault sequence detected. (XAUI/RXAUI mode only) */
-	uint64_t loc_fault                    : 1;  /**< Local-fault sequence detected. (XAUI/RXAUI mode only) */
-	uint64_t rsverr                       : 1;  /**< Reserved opcodes. */
+	uint64_t bad_seq                      : 1;  /**< Detected reserved sequence. */
+	uint64_t rem_fault                    : 1;  /**< Remote-fault sequence detected. */
+	uint64_t loc_fault                    : 1;  /**< Local-fault sequence detected. */
+	uint64_t rsverr                       : 1;  /**< Detected reserved opcode. */
 	uint64_t pcterr                       : 1;  /**< Bad preamble/protocol. In XAUI/RXAUI mode, the column of data that was bad is logged in
                                                          BGX()_SMU()_RX_BAD_COL_LO and BGX()_SMU()_RX_BAD_COL_HI.
                                                          PCTERR checks that the frame begins with a valid
@@ -6301,7 +6298,7 @@ union cvmx_bgxx_smux_tx_min_pkt {
 	uint64_t reserved_8_63                : 56;
 	uint64_t min_size                     : 8;  /**< Min frame in bytes inclusive of FCS, if applied. Padding is only appended when
                                                          BGX()_SMU()_TX_APPEND[PAD] for the corresponding port is set. When FCS is added to
-                                                         a packet which was padded, the FCS always appears in the 4 octets preceding /T/ or /E/. */
+                                                         a packet which was padded, the FCS always appears in the four octets preceding /T/ or /E/. */
 #else
 	uint64_t min_size                     : 8;
 	uint64_t reserved_8_63                : 56;
@@ -6518,7 +6515,7 @@ typedef union cvmx_bgxx_smux_tx_thresh cvmx_bgxx_smux_tx_thresh_t;
  * cvmx_bgx#_spu#_an_adv
  *
  * Software programs this register with the contents of the AN-link code word base page to be
- * transmitted during autonegotiation. (See Std 802.3 section 73.6 for details.) Any write
+ * transmitted during autonegotiation. (See IEEE 802.3 section 73.6 for details.) Any write
  * operations to this register prior to completion of autonegotiation, as indicated by
  * BGX()_SPU()_AN_STATUS[AN_COMPLETE], should be followed by a renegotiation in order for
  * the new values to take effect. Renegotiation is initiated by setting
@@ -6550,7 +6547,7 @@ union cvmx_bgxx_spux_an_adv {
 	uint64_t pause                        : 1;  /**< PAUSE ability. */
 	uint64_t e                            : 5;  /**< Echoed nonce. Provides the echoed-nonce value to use when ACK = 0 in transmitted DME page.
                                                          Should always be 0x0. */
-	uint64_t s                            : 5;  /**< Selector. Should be 0x1 (encoding for IEEE Std 802.3). */
+	uint64_t s                            : 5;  /**< Selector. Should be 0x1 (encoding for IEEE 802.3). */
 #else
 	uint64_t s                            : 5;
 	uint64_t e                            : 5;
@@ -6636,7 +6633,7 @@ union cvmx_bgxx_spux_an_control {
 	uint64_t an_reset                     : 1;  /**< Autonegotiation reset. Setting this bit or BGX()_SPU()_CONTROL1[RESET] to 1
                                                          causes the following to happen:
                                                          * Resets the logical PCS (LPCS)
-                                                         * Sets the Std 802.3 PCS, FEC and AN registers for the LPCS to their default states
+                                                         * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states
                                                          * Resets the associated SerDes lanes.
                                                          It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                          automatically cleared. */
@@ -6671,7 +6668,7 @@ typedef union cvmx_bgxx_spux_an_control cvmx_bgxx_spux_an_control_t;
  * cvmx_bgx#_spu#_an_lp_base
  *
  * This register captures the contents of the latest AN link code word base page received from
- * the link partner during autonegotiation. (See Std 802.3 section 73.6 for details.)
+ * the link partner during autonegotiation. (See IEEE 802.3 section 73.6 for details.)
  * BGX()_SPU()_AN_STATUS[PAGE_RX] is set when this register is updated by hardware.
  */
 union cvmx_bgxx_spux_an_lp_base {
@@ -6869,10 +6866,10 @@ typedef union cvmx_bgxx_spux_an_xnp_tx cvmx_bgxx_spux_an_xnp_tx_t;
 /**
  * cvmx_bgx#_spu#_br_algn_status
  *
- * This register implements the Std 802.3 multilane BASE-R PCS alignment status 1-4 registers
+ * This register implements the IEEE 802.3 multilane BASE-R PCS alignment status 1-4 registers
  * (3.50-3.53). It is valid only when the LPCS type is 40GBASE-R
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
- * types. Std 802.3 bits that are not applicable to 40GBASE-R (e.g. status bits for PCS lanes
+ * types. IEEE 802.3 bits that are not applicable to 40GBASE-R (e.g. status bits for PCS lanes
  * 19-4) are not implemented and marked as reserved. PCS lanes 3-0 are valid and are mapped to
  * physical SerDes lanes based on the programming of BGX()_CMR()_CONFIG[LANE_TO_SDS].
  */
@@ -6911,7 +6908,7 @@ typedef union cvmx_bgxx_spux_br_algn_status cvmx_bgxx_spux_br_algn_status_t;
 /**
  * cvmx_bgx#_spu#_br_bip_err_cnt
  *
- * This register implements the Std 802.3 BIP error-counter registers for PCS lanes 0-3
+ * This register implements the IEEE 802.3 BIP error-counter registers for PCS lanes 0-3
  * (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
  * types. The counters are indexed by the RX PCS lane number based on the Alignment Marker
@@ -6922,7 +6919,7 @@ typedef union cvmx_bgxx_spux_br_algn_status cvmx_bgxx_spux_br_algn_status_t;
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
- * only as specified in Std 802.3.
+ * only as specified in IEEE 802.3.
  */
 union cvmx_bgxx_spux_br_bip_err_cnt {
 	uint64_t u64;
@@ -6949,7 +6946,7 @@ typedef union cvmx_bgxx_spux_br_bip_err_cnt cvmx_bgxx_spux_br_bip_err_cnt_t;
 /**
  * cvmx_bgx#_spu#_br_lane_map
  *
- * This register implements the Std 802.3 lane 0-3 mapping registers (3.400-3.403). It is valid
+ * This register implements the IEEE 802.3 lane 0-3 mapping registers (3.400-3.403). It is valid
  * only when the LPCS type is 40GBASE-R (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always
  * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each programmed PCS lane
  * (called service interface in 802.3ba-2010) is valid when that lane has achieved alignment
@@ -6958,11 +6955,11 @@ typedef union cvmx_bgxx_spux_br_bip_err_cnt cvmx_bgxx_spux_br_bip_err_cnt_t;
  * returns the actual detected receive PCS lane number based on the received alignment marker
  * contents received on that service interface.
  *
- * The mapping is flexible because Std 802.3 allows multilane BASE-R receive lanes to be re-
+ * The mapping is flexible because IEEE 802.3 allows multilane BASE-R receive lanes to be re-
  * ordered. Note that for the transmit side, each PCS lane is mapped to a physical SerDes lane
  * based on the programming of BGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
  * BGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the service interface to physical SerDes
- * lane mapping, and this register specifies the PCS lane to service interface mapping.
+ * lane mapping, and this register specifies the service interface to PCS lane mapping.
  */
 union cvmx_bgxx_spux_br_lane_map {
 	uint64_t u64;
@@ -7237,7 +7234,7 @@ union cvmx_bgxx_spux_br_status1 {
 	uint64_t rcv_lnk                      : 1;  /**< BASE-R receive link status.
                                                          0 = BASE-R PCS receive-link down.
                                                          1 = BASE-R PCS receive-link up.
-                                                         This bit is a reflection of the PCS_status variable defined in Std 802.3 sections
+                                                         This bit is a reflection of the PCS_status variable defined in IEEE 802.3 sections
                                                          49.2.14.1 and 82.3.1. */
 	uint64_t reserved_4_11                : 8;
 	uint64_t prbs9                        : 1;  /**< 10GBASE-R PRBS9 pattern testing ability. Always 0; PRBS9 pattern testing is not supported. */
@@ -7246,12 +7243,12 @@ union cvmx_bgxx_spux_br_status1 {
                                                          0 = 64/66 bit receiver is detecting a bit-error rate of < 10.4.
                                                          1 = 64/66 bit receiver is detecting a bit-error rate of >= 10.4.
                                                          This bit is a direct reflection of the state of the HI_BER variable in the 64 B/66 B state
-                                                         diagram and is defined in Std 802.3 sections 49.2.13.2.2 and 82.2.18.2.2. */
+                                                         diagram and is defined in IEEE 802.3 sections 49.2.13.2.2 and 82.2.18.2.2. */
 	uint64_t blk_lock                     : 1;  /**< BASE-R PCS block lock.
                                                          0 = No block lock.
                                                          1 = 64/66 bit receiver for BASE-R has block lock.
                                                          This bit is a direct reflection of the state of the BLOCK_LOCK variable in the 64 B/66 B
-                                                         state diagram and is defined in Std 802.3 sections 49.2.13.2.2 and 82.2.18.2.2.
+                                                         state diagram and is defined in IEEE 802.3 sections 49.2.13.2.2 and 82.2.18.2.2.
                                                          For a multilane logical PCS (i.e. 40GBASE-R), this bit indicates that the receiver has
                                                          both block lock and alignment for all lanes and is identical to
                                                          BGX()_SPU()_BR_ALGN_STATUS[ALIGND]. */
@@ -7275,12 +7272,12 @@ typedef union cvmx_bgxx_spux_br_status1 cvmx_bgxx_spux_br_status1_t;
 /**
  * cvmx_bgx#_spu#_br_status2
  *
- * This register implements a combination of the following Std 802.3 registers:
+ * This register implements a combination of the following IEEE 802.3 registers:
  * * BASE-R PCS status 2 (MDIO address 3.33).
  * * BASE-R BER high-order counter (MDIO address 3.44).
  * * Errored-blocks high-order counter (MDIO address 3.45).
  *
- * Note that the relative locations of some fields have been moved from Std 802.3 in order to
+ * Note that the relative locations of some fields have been moved from IEEE 802.3 in order to
  * make the register layout more software friendly: the BER counter high-order and low-order bits
  * from sections 3.44 and 3.33 have been combined into the contiguous, 22-bit [BER_CNT] field;
  * likewise, the errored-blocks counter high-order and low-order bits from section 3.45 have been
@@ -7292,38 +7289,37 @@ union cvmx_bgxx_spux_br_status2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
 	uint64_t err_blks                     : 22; /**< Errored-blocks counter. This is the BASE-R errored-blocks counter as defined by the
-                                                         errored_block_count variable specified in Std 802.3 sections 49.2.14.2 and 82.2.18.2.4. It
-                                                         increments by 1 on each block for which the BASE-R receive state machine, specified in Std
+                                                         errored_block_count variable specified in IEEE 802.3 sections 49.2.14.2 and 82.2.18.2.4.
+                                                         It
+                                                         increments by one on each block for which the BASE-R receive state machine, specified in Std
                                                          802.3 diagrams 49-15 and 82-15, enters the RX_E state.
                                                          Back-to-back blocks in the RX_E state are counted as transitions from RX_E to RX_E and
-                                                         keep incrementing the counter. The counter is reset to all 0s after this register is read
+                                                         keep incrementing the counter. The counter is reset to all zeros after this register is read
                                                          by software.
                                                          The reset operation takes precedence over the increment operation: if the register is read
-                                                         on the same clock cycle as an increment operation, the counter is reset to all 0s and the
+                                                         on the same clock cycle as an increment operation, the counter is reset to all zeros and the
                                                          increment operation is lost.
-                                                         This field is writable for test purposes, rather than read-only as specified in Std 802.3. */
+                                                         This field is writable for test purposes, rather than read-only as specified in IEEE
+                                                         802.3. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t ber_cnt                      : 22; /**< Bit-error-rate counter. This is the BASE-R BER counter as defined by the BER_COUNT
-                                                         variable in Std 802.3 sections 49.2.14.2 and 82.2.18.2.4. The counter is reset to all 0s
-                                                         after this register is read by software, and is held at all 1s in case of overflow.
+                                                         variable in IEEE 802.3 sections 49.2.14.2 and 82.2.18.2.4. The counter is reset to all zeros
+                                                         after this register is read by software, and is held at all ones in case of overflow.
                                                          The reset operation takes precedence over the increment operation: if the register is read
-                                                         on the same clock cycle an increment operation, the counter is reset to all 0s and the
+                                                         on the same clock cycle an increment operation, the counter is reset to all zeros and the
                                                          increment operation is lost.
-                                                         This field is writable for test purposes, rather than read-only as specified in Std 802.3. */
+                                                         This field is writable for test purposes, rather than read-only as specified in IEEE
+                                                         802.3. */
 	uint64_t latched_lock                 : 1;  /**< Latched-block lock.
                                                          0 = No block.
                                                          1 = 64/66 bit receiver for BASE-R has block lock.
                                                          This is a latching-low version of BGX()_SPU()_BR_STATUS1[BLK_LOCK]; it stays clear
-                                                         until the register is read by software.
-                                                         Note that in order to avoid read side effects, this is implemented as a write-1-to-set
-                                                         bit, rather than latching low read-only as specified in 802.3. */
+                                                         until a write-1-to-set by software. */
 	uint64_t latched_ber                  : 1;  /**< Latched-high bit-error rate.
                                                          0 = Not a high BER.
                                                          1 = 64/66 bit receiver is detecting a high BER.
                                                          This is a latching-high version of BGX()_SPU()_BR_STATUS1[HI_BER]; it stays set until
-                                                         the register is read by software.
-                                                         Note that in order to avoid read side effects, this is implemented as a write-1-to-clear
-                                                         bit, rather than latching high read-only as specified in 802.3. */
+                                                         a write-1-to-clear by software. */
 	uint64_t reserved_0_13                : 14;
 #else
 	uint64_t reserved_0_13                : 14;
@@ -7397,14 +7393,15 @@ union cvmx_bgxx_spux_br_tp_err_cnt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t err_cnt                      : 16; /**< Error counter. This 16-bit counter contains the number of errors received during a pattern
-                                                         test. These bits are reset to all 0s when this register is read by software, and they are
-                                                         held at all 1s in the case of overflow.
-                                                         The test pattern methodology is described in Std 802.3, Sections 49.2.12 and 82.2.10. This
+                                                         test. These bits are reset to all zeros when this register is read by software, and they are
+                                                         held at all ones in the case of overflow.
+                                                         The test pattern methodology is described in IEEE 802.3, Sections 49.2.12 and 82.2.10.
+                                                         This
                                                          counter counts either block errors or bit errors dependent on the test mode (see Section
                                                          49.2.12). The reset operation takes precedence over the increment operation; if the
                                                          register is read on the same clock cycle as an increment operation, the counter is reset
-                                                         to all 0s and the increment operation is lost. This field is writable for test purposes,
-                                                         rather than read-only as specified in Std 802.3. */
+                                                         to all zeros and the increment operation is lost. This field is writable for test purposes,
+                                                         rather than read-only as specified in IEEE 802.3. */
 #else
 	uint64_t err_cnt                      : 16;
 	uint64_t reserved_16_63               : 48;
@@ -7460,7 +7457,7 @@ union cvmx_bgxx_spux_control1 {
 	uint64_t reset                        : 1;  /**< Reset. Setting this bit or BGX()_SPU()_AN_CONTROL[AN_RESET] to 1 causes the
                                                          following to happen:
                                                          * Resets the logical PCS (LPCS)
-                                                         * Sets the Std 802.3 PCS, FEC and AN registers for the LPCS to their default states
+                                                         * Sets the IEEE 802.3 PCS, FEC and AN registers for the LPCS to their default states
                                                          * Resets the associated SerDes lanes.
                                                          It takes up to 32 coprocessor-clock cycles to reset the LPCS, after which RESET is
                                                          automatically cleared. */
@@ -7606,7 +7603,7 @@ typedef union cvmx_bgxx_spux_fec_control cvmx_bgxx_spux_fec_control_t;
  *
  * This register is valid only when the LPCS type is BASE-R
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x3 or 0x4). The FEC corrected-block counters are
- * defined in Std 802.3 section 74.8.4.1. Each corrected-blocks counter increments by 1 for a
+ * defined in IEEE 802.3 section 74.8.4.1. Each corrected-blocks counter increments by 1 for a
  * corrected FEC block, i.e. an FEC block that has been received with invalid parity on the
  * associated PCS lane and has been corrected by the FEC decoder. The counter is reset to all 0s
  * when the register is read, and held at all 1s in case of overflow.
@@ -7614,7 +7611,7 @@ typedef union cvmx_bgxx_spux_fec_control cvmx_bgxx_spux_fec_control_t;
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
- * only as specified in Std 802.3.
+ * only as specified in IEEE 802.3.
  */
 union cvmx_bgxx_spux_fec_corr_blks01 {
 	uint64_t u64;
@@ -7622,12 +7619,12 @@ union cvmx_bgxx_spux_fec_corr_blks01 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ln1_corr_blks                : 32; /**< PCS Lane 1 FEC corrected blocks.
                                                          * For 10GBASE-R, reserved.
-                                                         * For 40GBASE-R, correspond to the Std 802.3 FEC_corrected_blocks_counter_1 variable
+                                                         * For 40GBASE-R, correspond to the IEEE 802.3 FEC_corrected_blocks_counter_1 variable
                                                          (registers 1.302-1.303). */
 	uint64_t ln0_corr_blks                : 32; /**< PCS Lane 0 FEC corrected blocks.
-                                                         * For 10GBASE-R, corresponds to the Std 802.3 FEC_corrected_blocks_counter variable
+                                                         * For 10GBASE-R, corresponds to the IEEE 802.3 FEC_corrected_blocks_counter variable
                                                          (registers 1.172-1.173).
-                                                         * For 40GBASE-R, correspond to the Std 802.3 FEC_corrected_blocks_counter_0 variable
+                                                         * For 40GBASE-R, correspond to the IEEE 802.3 FEC_corrected_blocks_counter_0 variable
                                                          (registers 1.300-1.301). */
 #else
 	uint64_t ln0_corr_blks                : 32;
@@ -7646,7 +7643,7 @@ typedef union cvmx_bgxx_spux_fec_corr_blks01 cvmx_bgxx_spux_fec_corr_blks01_t;
  *
  * This register is valid only when the LPCS type is 40GBASE-R
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4). The FEC corrected-block counters are defined in
- * Std 802.3 section 74.8.4.1. Each corrected-blocks counter increments by 1 for a corrected FEC
+ * IEEE 802.3 section 74.8.4.1. Each corrected-blocks counter increments by 1 for a corrected FEC
  * block, i.e. an FEC block that has been received with invalid parity on the associated PCS lane
  * and has been corrected by the FEC decoder. The counter is reset to all 0s when the register is
  * read, and held at all 1s in case of overflow.
@@ -7654,15 +7651,15 @@ typedef union cvmx_bgxx_spux_fec_corr_blks01 cvmx_bgxx_spux_fec_corr_blks01_t;
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
- * only as specified in Std 802.3.
+ * only as specified in IEEE 802.3.
  */
 union cvmx_bgxx_spux_fec_corr_blks23 {
 	uint64_t u64;
 	struct cvmx_bgxx_spux_fec_corr_blks23_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ln3_corr_blks                : 32; /**< PCS Lane 3 FEC corrected blocks. Correspond to the Std 802.3
+	uint64_t ln3_corr_blks                : 32; /**< PCS Lane 3 FEC corrected blocks. Correspond to the IEEE 802.3
                                                          FEC_corrected_blocks_counter_3 variable (registers 1.306-1.307). */
-	uint64_t ln2_corr_blks                : 32; /**< PCS Lane 2 FEC corrected blocks. Correspond to the Std 802.3
+	uint64_t ln2_corr_blks                : 32; /**< PCS Lane 2 FEC corrected blocks. Correspond to the IEEE 802.3
                                                          FEC_corrected_blocks_counter_3 variable (registers 1.304-1.305). */
 #else
 	uint64_t ln2_corr_blks                : 32;
@@ -7681,7 +7678,7 @@ typedef union cvmx_bgxx_spux_fec_corr_blks23 cvmx_bgxx_spux_fec_corr_blks23_t;
  *
  * This register is valid only when the LPCS type is BASE-R
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x3 or 0x4). The FEC corrected-block counters are
- * defined in Std 802.3 section 74.8.4.2. Each uncorrected-blocks counter increments by 1 for an
+ * defined in IEEE 802.3 section 74.8.4.2. Each uncorrected-blocks counter increments by 1 for an
  * uncorrected FEC block, i.e. an FEC block that has been received with invalid parity on the
  * associated PCS lane and has not been corrected by the FEC decoder. The counter is reset to all
  * 0s when the register is read, and held at all 1s in case of overflow.
@@ -7689,7 +7686,7 @@ typedef union cvmx_bgxx_spux_fec_corr_blks23 cvmx_bgxx_spux_fec_corr_blks23_t;
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
- * only as specified in Std 802.3.
+ * only as specified in IEEE 802.3.
  */
 union cvmx_bgxx_spux_fec_uncorr_blks01 {
 	uint64_t u64;
@@ -7697,12 +7694,12 @@ union cvmx_bgxx_spux_fec_uncorr_blks01 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ln1_uncorr_blks              : 32; /**< PCS Lane 1 FEC corrected blocks.
                                                          * For 10GBASE-R, reserved.
-                                                         * For 40GBASE-R, corresponds to the Std 802.3 FEC_uncorrected_blocks_counter_1 variable
+                                                         * For 40GBASE-R, corresponds to the IEEE 802.3 FEC_uncorrected_blocks_counter_1 variable
                                                          (registers 1.702-1.703). */
 	uint64_t ln0_uncorr_blks              : 32; /**< PCS Lane 0 FEC uncorrected blocks.
-                                                         * For 10GBASE-R, corresponds to the Std 802.3 FEC_uncorrected_blocks_counter variable
+                                                         * For 10GBASE-R, corresponds to the IEEE 802.3 FEC_uncorrected_blocks_counter variable
                                                          (registers 1.174-1.175).
-                                                         * For 40GBASE-R, correspond to the Std 802.3 FEC_uncorrected_blocks_counter_0 variable
+                                                         * For 40GBASE-R, correspond to the IEEE 802.3 FEC_uncorrected_blocks_counter_0 variable
                                                          (registers 1.700-1.701). */
 #else
 	uint64_t ln0_uncorr_blks              : 32;
@@ -7721,7 +7718,7 @@ typedef union cvmx_bgxx_spux_fec_uncorr_blks01 cvmx_bgxx_spux_fec_uncorr_blks01_
  *
  * This register is valid only when the LPCS type is 40GBASE-R
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4). The FEC uncorrected-block counters are defined
- * in Std 802.3 section 74.8.4.2. Each corrected-blocks counter increments by 1 for an
+ * in IEEE 802.3 section 74.8.4.2. Each corrected-blocks counter increments by 1 for an
  * uncorrected FEC block, i.e. an FEC block that has been received with invalid parity on the
  * associated PCS lane and has not been corrected by the FEC decoder. The counter is reset to all
  * 0s when the register is read, and held at all 1s in case of overflow.
@@ -7729,15 +7726,15 @@ typedef union cvmx_bgxx_spux_fec_uncorr_blks01 cvmx_bgxx_spux_fec_uncorr_blks01_
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
- * only as specified in Std 802.3.
+ * only as specified in IEEE 802.3.
  */
 union cvmx_bgxx_spux_fec_uncorr_blks23 {
 	uint64_t u64;
 	struct cvmx_bgxx_spux_fec_uncorr_blks23_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ln3_uncorr_blks              : 32; /**< PCS Lane 3 FEC uncorrected blocks. Corresponds to the Std 802.3
+	uint64_t ln3_uncorr_blks              : 32; /**< PCS Lane 3 FEC uncorrected blocks. Corresponds to the IEEE 802.3
                                                          FEC_uncorrected_blocks_counter_3 variable (registers 1.706-1.707). */
-	uint64_t ln2_uncorr_blks              : 32; /**< PCS Lane 2 FEC uncorrected blocks. Corresponds to the Std 802.3
+	uint64_t ln2_uncorr_blks              : 32; /**< PCS Lane 2 FEC uncorrected blocks. Corresponds to the IEEE 802.3
                                                          FEC_uncorrected_blocks_counter_3 variable (registers 1.704-1.705). */
 #else
 	uint64_t ln2_uncorr_blks              : 32;
@@ -7903,9 +7900,9 @@ union cvmx_bgxx_spux_misc_control {
                                                          to ensure sufficient density of XAUI idle skip (||R||) columns with a small transmit
                                                          inter-frame gap (IFG) in order to allow the link partner's receiver to delete ||R
                                                          columns as needed for clock rate compensation. It is usually set when the LMAC's transmit
-                                                         IFG is set to 8 bytes in HiGig/HiGig2 modes (i.e. BGX()_SMU()_TX_IFG[IFG1] +
+                                                         IFG is set to eight bytes in HiGig/HiGig2 modes (i.e. BGX()_SMU()_TX_IFG[IFG1] +
                                                          BGX()_SMU()_TX_IFG[IFG2] = 8), and should be cleared when the transmit IFG is
-                                                         greater than 8 bytes. When this bit is set, the SPU will send an ||R|| column after a
+                                                         greater than eight bytes. When this bit is set, the SPU will send an ||R|| column after a
                                                          ||T0|| column (terminate in lane 0) if no ||R|| was sent in the previous IFG. This is a
                                                          minor deviation from the functionality specified in 802.3-2008 Figure 48-6 (PCS transmit
                                                          source state diagram), whereby the state will transition directly from SEND_DATA to
@@ -7927,8 +7924,8 @@ union cvmx_bgxx_spux_misc_control {
                                                          the Marvell RXAUI Interface specification. This does not obey 6.25GHz SerDes disparity. */
 	uint64_t xor_rxplrt                   : 4;  /**< RX polarity control per logical PCS lane */
 	uint64_t xor_txplrt                   : 4;  /**< TX polarity control per logical PCS lane */
-	uint64_t rxplrt                       : 1;  /**< Receive polarity. 1 = inverted polarity, 0 = normal polarity. */
-	uint64_t txplrt                       : 1;  /**< Transmit polarity. 1 = inverted polarity, 0 = normal polarity. */
+	uint64_t rxplrt                       : 1;  /**< Receive polarity. 1 = inverted polarity. 0 = normal polarity. */
+	uint64_t txplrt                       : 1;  /**< Transmit polarity. 1 = inverted polarity. 0 = normal polarity. */
 #else
 	uint64_t txplrt                       : 1;
 	uint64_t rxplrt                       : 1;
@@ -7988,14 +7985,12 @@ union cvmx_bgxx_spux_status1 {
 	uint64_t rcv_lnk                      : 1;  /**< PCS receive link status:
                                                            0 = receive link down.
                                                            1 = receive link up.
-                                                         This is a latching-low bit; it stays clear until the register is read by software.
+                                                         This is a latching-low bit; it stays clear until a write-1-to-set by software.
                                                          For a BASE-X logical PCS type (in the associated BGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                          XAUI or RXAUI), this is a latching-low version of BGX()_SPU()_BX_STATUS[ALIGND].
                                                          For a BASE-R logical PCS type (in the associated BGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                          10G_R or 40G_R), this is a latching-low version of
-                                                         BGX()_SPU()_BR_STATUS1[RCV_LNK].
-                                                         Note that in order to avoid read side effects, this is implemented as a write-1-to-set
-                                                         bit, rather than latching low read-only as specified in 802.3. */
+                                                         BGX()_SPU()_BR_STATUS1[RCV_LNK]. */
 	uint64_t lpable                       : 1;  /**< Low-power ability. Always returns 1 to indicate that the LPCS supports low-power mode. */
 	uint64_t reserved_0_0                 : 1;
 #else
@@ -8025,10 +8020,8 @@ union cvmx_bgxx_spux_status2 {
 	uint64_t dev                          : 2;  /**< Device present. Always returns 0x2 to indicate a device is present at this address. */
 	uint64_t reserved_12_13               : 2;
 	uint64_t xmtflt                       : 1;  /**< Transmit fault. Always returns 0. */
-	uint64_t rcvflt                       : 1;  /**< Receive fault: 1 = receive fault, 0 = no receive fault. Latching high bit; stays set until
-                                                         software writes a 1.
-                                                         Note that in order to avoid read side effects, this is implemented as a write-1-to-clear
-                                                         bit, rather than latching high read-only as specified in 802.3. */
+	uint64_t rcvflt                       : 1;  /**< Receive fault: 1 = receive fault. 0 = no receive fault. Latching high bit; stays set until
+                                                         a write-1-to-clear by software. */
 	uint64_t reserved_6_9                 : 4;
 	uint64_t hundredgb_r                  : 1;  /**< 100GBASE-R capable. Always 0. */
 	uint64_t fortygb_r                    : 1;  /**< 40GBASE-R capable. Always 1. */
@@ -8093,9 +8086,9 @@ union cvmx_bgxx_spu_dbg_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
 	uint64_t ms_clk_period                : 12; /**< Millisecond clock period. Specifies the number of microsecond clock ticks per millisecond,
-                                                         minus 1. The default value of 999 (0x3E7) should be used during normal operation; other
+                                                         minus one. The default value of 999 (0x3E7) should be used during normal operation; other
                                                          values may be used for test/debug purposes. */
-	uint64_t us_clk_period                : 12; /**< Microsecond clock period. Specifies the number of SCLK cycles per microseconds, minus 1.
+	uint64_t us_clk_period                : 12; /**< Microsecond clock period. Specifies the number of SCLK cycles per microseconds, minus one.
                                                          For example, if SCLK runs at 1.3 GHz, the number of SCLK cycles per microsecond is 1,300
                                                          so the value of this field should be 1,299 (0x513). This is used by the BASE-R BER monitor
                                                          timers. */
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index e760640d487e..deef10f57c11 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -42,7 +42,7 @@
  * Simple allocate only memory allocator.  Used to allocate memory at application
  * start time.
  *
- * <hr>$Revision: 130285 $<hr>
+ * <hr>$Revision: 169699 $<hr>
  *
  */
 
@@ -212,24 +212,6 @@ extern void *cvmx_bootmem_alloc_node(uint64_t node, uint64_t size, uint64_t alig
 extern void *cvmx_bootmem_alloc_address(uint64_t size, uint64_t address,
 					uint64_t alignment);
 
-/**
- * Allocate a block of memory from the free list that was
- * passed to the application by the bootloader within a specified
- * address range. This is an allocate-only algorithm, so
- * freeing memory is not possible. Allocation will fail if
- * memory cannot be allocated in the requested range.
- *
- * @param size      Size in bytes of block to allocate
- * @param min_addr  defines the minimum address of the range
- * @param max_addr  defines the maximum address of the range
- * @param alignment Alignment required - must be power of 2
- * @param flags     Flags to control options for the allocation.
- * @return pointer to block of memory, NULL on error
- */
-extern void *cvmx_bootmem_alloc_range_flags(uint64_t size, uint64_t alignment,
-					    uint64_t min_addr,
-					    uint64_t max_addr, uint32_t flags);
-
 /**
  * Allocate a block of memory from the free list that was
  * passed to the application by the bootloader within a specified
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index ca151ae20f76..862a634bceaa 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -13100,7 +13100,9 @@ union cvmx_ciu_pp_rst {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t rst                          : 47; /**< Core reset for cores 1 and above. Writing a 1 holds the corresponding core in reset,
-                                                         writing a 0 releases from reset. */
+                                                         writing a 0 releases from reset.
+                                                         The upper bits of this field remain accessible but will have no effect if the cores
+                                                         are disabled. The number of bits cleared in CIU_FUSE[FUSE] indicate the number of cores. */
 	uint64_t rst0                         : 1;  /**< Core reset for core 0, depends on standalone mode. */
 #else
 	uint64_t rst0                         : 1;
@@ -13235,7 +13237,9 @@ union cvmx_ciu_pp_rst_pending {
 	uint64_t pend                         : 48; /**< Set if corresponding core is waiting to change its reset state. Normally a reset change
                                                          occurs immediately but if RST_PP_POWER[GATE] bit is set and the core is released from
                                                          reset a delay of 64K core clocks between each core reset will apply to satisfy power
-                                                         management. */
+                                                         management.
+                                                         The upper bits of this field remain accessible but will have no effect if the cores
+                                                         are disabled. The number of bits cleared in CIU_FUSE[FUSE] indicate the number of cores. */
 #else
 	uint64_t pend                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -16843,10 +16847,10 @@ union cvmx_ciu_wdogx {
 	uint64_t reserved_46_63               : 18;
 	uint64_t gstopen                      : 1;  /**< Global-stop enable. */
 	uint64_t dstop                        : 1;  /**< Debug-stop enable. */
-	uint64_t cnt                          : 24; /**< Number of 1024-cycle intervals until next watchdog expiration. Cleared on write to
-                                                         associated CIU_PP_POKE() register. */
+	uint64_t cnt                          : 24; /**< Number of 256-cycle coprocessor clock intervals until next watchdog expiration.
+                                                         Cleared on write to associated CIU_PP_POKE() register. */
 	uint64_t len                          : 16; /**< Watchdog time-expiration length. The most-significant 16 bits of a 24-bit decrementer that
-                                                         decrements every 1024 cycles. Must be set > 0. */
+                                                         decrements every 256-cycle coprocessor clock interval. Must be set > 0. */
 	uint64_t state                        : 2;  /**< Watchdog state. The number of watchdog time expirations since last core poke. Cleared on
                                                          write to associated CIU_PP_POKE() register. */
 	uint64_t mode                         : 2;  /**< Watchdog mode:
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
index cd763cec934e..60bc3303dfaf 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-dbg-defs.h b/arch/mips/include/asm/octeon/cvmx-dbg-defs.h
index 2697c3471eaa..d14709ed7ff6 100644
--- a/arch/mips/include/asm/octeon/cvmx-dbg-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dbg-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index 7a2ac39fe0d0..94d0764c937a 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -1213,14 +1213,7 @@ union cvmx_dpi_dma_control {
 	uint64_t ffp_dis                      : 1;  /**< Force forward progress disable. The DMA engines will compete for shared resources. If the
                                                          hardware detects that particular engines are not able to make requests to an interface,
                                                          the hardware will periodically trade-off throughput for fairness. */
-	uint64_t commit_mode                  : 1;  /**< DMA engine commit mode.
-                                                         When COMMIT_MODE=1, DPI considers an instruction complete when the hardware internally
-                                                         generates the final write for the current instruction.
-                                                         When COMMIT_MODE=0, DPI additionally waits for the final write to reach the interface
-                                                         coherency point to declare the instructions complete.
-                                                         When COMMIT_MODE=1, DPI may not follow the HRM ordering rules. DPI
-                                                         hardware performance may be better with COMMIT_MODE=1 than with COMMIT_MODE=0 due to
-                                                         the relaxed ordering rules. If the HRM ordering rules are required, set COMMIT_MODE=0. */
+	uint64_t commit_mode                  : 1;  /**< DMA engine commit mode. For diagnostic use only. */
 	uint64_t pkt_hp                       : 1;  /**< High-Priority Mode for Packet Interface.
                                                          This mode has been deprecated. */
 	uint64_t pkt_en                       : 1;  /**< Enables the packet interface. When the packet interface is enabled, engines 4 and 5 are
@@ -1596,14 +1589,7 @@ union cvmx_dpi_dma_control {
 	uint64_t ffp_dis                      : 1;  /**< Force forward progress disable. The DMA engines will compete for shared resources. If the
                                                          hardware detects that particular engines are not able to make requests to an interface,
                                                          the hardware will periodically trade-off throughput for fairness. */
-	uint64_t commit_mode                  : 1;  /**< DMA engine commit mode.
-                                                         When COMMIT_MODE=1, DPI considers an instruction complete when the hardware internally
-                                                         generates the final write for the current instruction.
-                                                         When COMMIT_MODE=0, DPI additionally waits for the final write to reach the interface
-                                                         coherency point to declare the instructions complete.
-                                                         When COMMIT_MODE=1, DPI may not follow the HRM ordering rules. DPI
-                                                         hardware performance may be better with COMMIT_MODE=1 than with COMMIT_MODE=0 due to
-                                                         the relaxed ordering rules. If the HRM ordering rules are required, set COMMIT_MODE=0. */
+	uint64_t commit_mode                  : 1;  /**< DMA engine commit mode. For diagnostic use only. */
 	uint64_t reserved_57_57               : 1;
 	uint64_t pkt_en                       : 1;  /**< Enables the packet interface. When the packet interface is enabled, engines 4 and 5 are
                                                          used for packets and are not available for DMA. When PKT_EN=1, then DMA_ENB<5>=0 and
@@ -2861,8 +2847,8 @@ union cvmx_dpi_sli_prtx_cfg {
                                                          1 = 256B.
                                                          The MPS size must not exceed the size selected by PCIE*_CFG030[MPS] when DPI is
                                                          operating in PCIe mode (QLM_CFG=PCIe).
-                                                         The MPS size must not exceed 256B when DPI is operating in SRIO mode
-                                                         (QLM_CFG=SRIO). */
+                                                         For CNF75XX, when DPI is operating in SRIO mode (QLM_CFG=SRIO), the MPS size
+                                                         must not exceed 256B. */
 	uint64_t mrrs_lim                     : 1;  /**< MAC memory space read requests cannot cross the (naturally-aligned) MRRS boundary.
                                                          When clear, DPI is allowed to issue a MAC memory-space read that crosses the naturally-
                                                          aligned boundary of size defined by MRRS. (DPI will still only cross the boundary when it
@@ -2878,8 +2864,8 @@ union cvmx_dpi_sli_prtx_cfg {
                                                          0x3 = 1024B.
                                                          The MRRS size must not exceed the size selected by PCIE*_CFG030[MRRS] when DPI
                                                          is operating in PCIe mode (QLM_CFG=PCIe).
-                                                         The MRRS size must not exceed 256B when DPI is operating in SRIO mode
-                                                         (QLM_CFG=SRIO). */
+                                                         For CNF75XX, when DPI is operating in SRIO mode (QLM_CFG=SRIO), the MRRS size
+                                                         must not exceed 256B. */
 #else
 	uint64_t mrrs                         : 2;
 	uint64_t reserved_2_2                 : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index 4a72a4442041..2c040adb1d96 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -5097,9 +5097,9 @@ union cvmx_dtx_agl_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5122,8 +5122,8 @@ union cvmx_dtx_agl_datx {
 	struct cvmx_dtx_agl_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5142,8 +5142,8 @@ union cvmx_dtx_agl_enax {
 	struct cvmx_dtx_agl_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5202,9 +5202,9 @@ union cvmx_dtx_ase_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5227,8 +5227,8 @@ union cvmx_dtx_ase_datx {
 	struct cvmx_dtx_ase_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5247,8 +5247,8 @@ union cvmx_dtx_ase_enax {
 	struct cvmx_dtx_ase_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5306,9 +5306,9 @@ union cvmx_dtx_bbx1i_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5330,8 +5330,8 @@ union cvmx_dtx_bbx1i_datx {
 	struct cvmx_dtx_bbx1i_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5349,8 +5349,8 @@ union cvmx_dtx_bbx1i_enax {
 	struct cvmx_dtx_bbx1i_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5406,9 +5406,9 @@ union cvmx_dtx_bbx2i_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5430,8 +5430,8 @@ union cvmx_dtx_bbx2i_datx {
 	struct cvmx_dtx_bbx2i_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5449,8 +5449,8 @@ union cvmx_dtx_bbx2i_enax {
 	struct cvmx_dtx_bbx2i_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5506,9 +5506,9 @@ union cvmx_dtx_bbx3i_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5530,8 +5530,8 @@ union cvmx_dtx_bbx3i_datx {
 	struct cvmx_dtx_bbx3i_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5549,8 +5549,8 @@ union cvmx_dtx_bbx3i_enax {
 	struct cvmx_dtx_bbx3i_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5607,9 +5607,9 @@ union cvmx_dtx_bch_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5632,8 +5632,8 @@ union cvmx_dtx_bch_datx {
 	struct cvmx_dtx_bch_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5652,8 +5652,8 @@ union cvmx_dtx_bch_enax {
 	struct cvmx_dtx_bch_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5714,9 +5714,9 @@ union cvmx_dtx_bgxx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5741,8 +5741,8 @@ union cvmx_dtx_bgxx_datx {
 	struct cvmx_dtx_bgxx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5763,8 +5763,8 @@ union cvmx_dtx_bgxx_enax {
 	struct cvmx_dtx_bgxx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5808,9 +5808,9 @@ union cvmx_dtx_broadcast_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5837,8 +5837,8 @@ union cvmx_dtx_broadcast_enax {
 	struct cvmx_dtx_broadcast_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5904,9 +5904,9 @@ union cvmx_dtx_bts_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5928,8 +5928,8 @@ union cvmx_dtx_bts_datx {
 	struct cvmx_dtx_bts_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5947,8 +5947,8 @@ union cvmx_dtx_bts_enax {
 	struct cvmx_dtx_bts_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6007,9 +6007,9 @@ union cvmx_dtx_ciu_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6034,8 +6034,8 @@ union cvmx_dtx_ciu_datx {
 	struct cvmx_dtx_ciu_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6056,8 +6056,8 @@ union cvmx_dtx_ciu_enax {
 	struct cvmx_dtx_ciu_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6119,9 +6119,9 @@ union cvmx_dtx_denc_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6143,8 +6143,8 @@ union cvmx_dtx_denc_datx {
 	struct cvmx_dtx_denc_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6162,8 +6162,8 @@ union cvmx_dtx_denc_enax {
 	struct cvmx_dtx_denc_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6223,9 +6223,9 @@ union cvmx_dtx_dfa_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6251,8 +6251,8 @@ union cvmx_dtx_dfa_datx {
 	struct cvmx_dtx_dfa_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6274,8 +6274,8 @@ union cvmx_dtx_dfa_enax {
 	struct cvmx_dtx_dfa_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6339,9 +6339,9 @@ union cvmx_dtx_dlfe_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6363,8 +6363,8 @@ union cvmx_dtx_dlfe_datx {
 	struct cvmx_dtx_dlfe_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6382,8 +6382,8 @@ union cvmx_dtx_dlfe_enax {
 	struct cvmx_dtx_dlfe_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6444,9 +6444,9 @@ union cvmx_dtx_dpi_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6473,8 +6473,8 @@ union cvmx_dtx_dpi_datx {
 	struct cvmx_dtx_dpi_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6497,8 +6497,8 @@ union cvmx_dtx_dpi_enax {
 	struct cvmx_dtx_dpi_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6564,9 +6564,9 @@ union cvmx_dtx_fdeqx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6588,8 +6588,8 @@ union cvmx_dtx_fdeqx_datx {
 	struct cvmx_dtx_fdeqx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6607,8 +6607,8 @@ union cvmx_dtx_fdeqx_enax {
 	struct cvmx_dtx_fdeqx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6669,9 +6669,9 @@ union cvmx_dtx_fpa_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6698,8 +6698,8 @@ union cvmx_dtx_fpa_datx {
 	struct cvmx_dtx_fpa_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6722,8 +6722,8 @@ union cvmx_dtx_fpa_enax {
 	struct cvmx_dtx_fpa_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6790,9 +6790,9 @@ union cvmx_dtx_gmxx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6815,8 +6815,8 @@ union cvmx_dtx_gmxx_datx {
 	struct cvmx_dtx_gmxx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6835,8 +6835,8 @@ union cvmx_dtx_gmxx_enax {
 	struct cvmx_dtx_gmxx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6897,9 +6897,9 @@ union cvmx_dtx_gserx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6924,8 +6924,8 @@ union cvmx_dtx_gserx_datx {
 	struct cvmx_dtx_gserx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -6946,8 +6946,8 @@ union cvmx_dtx_gserx_enax {
 	struct cvmx_dtx_gserx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7011,9 +7011,9 @@ union cvmx_dtx_hna_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7037,8 +7037,8 @@ union cvmx_dtx_hna_datx {
 	struct cvmx_dtx_hna_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7058,8 +7058,8 @@ union cvmx_dtx_hna_enax {
 	struct cvmx_dtx_hna_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7120,9 +7120,9 @@ union cvmx_dtx_ila_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7145,8 +7145,8 @@ union cvmx_dtx_ila_datx {
 	struct cvmx_dtx_ila_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7165,8 +7165,8 @@ union cvmx_dtx_ila_enax {
 	struct cvmx_dtx_ila_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7225,9 +7225,9 @@ union cvmx_dtx_ilk_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7250,8 +7250,8 @@ union cvmx_dtx_ilk_datx {
 	struct cvmx_dtx_ilk_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7270,8 +7270,8 @@ union cvmx_dtx_ilk_enax {
 	struct cvmx_dtx_ilk_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7330,9 +7330,9 @@ union cvmx_dtx_iob_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7355,8 +7355,8 @@ union cvmx_dtx_iob_datx {
 	struct cvmx_dtx_iob_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7375,8 +7375,8 @@ union cvmx_dtx_iob_enax {
 	struct cvmx_dtx_iob_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7437,9 +7437,9 @@ union cvmx_dtx_iobn_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7464,8 +7464,8 @@ union cvmx_dtx_iobn_datx {
 	struct cvmx_dtx_iobn_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7486,8 +7486,8 @@ union cvmx_dtx_iobn_enax {
 	struct cvmx_dtx_iobn_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7552,9 +7552,9 @@ union cvmx_dtx_iobp_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7579,8 +7579,8 @@ union cvmx_dtx_iobp_datx {
 	struct cvmx_dtx_iobp_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7601,8 +7601,8 @@ union cvmx_dtx_iobp_enax {
 	struct cvmx_dtx_iobp_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7665,9 +7665,9 @@ union cvmx_dtx_ipd_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7690,8 +7690,8 @@ union cvmx_dtx_ipd_datx {
 	struct cvmx_dtx_ipd_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7710,8 +7710,8 @@ union cvmx_dtx_ipd_enax {
 	struct cvmx_dtx_ipd_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7774,9 +7774,9 @@ union cvmx_dtx_key_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7803,8 +7803,8 @@ union cvmx_dtx_key_datx {
 	struct cvmx_dtx_key_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7827,8 +7827,8 @@ union cvmx_dtx_key_enax {
 	struct cvmx_dtx_key_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7899,9 +7899,9 @@ union cvmx_dtx_l2c_cbcx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7928,8 +7928,8 @@ union cvmx_dtx_l2c_cbcx_datx {
 	struct cvmx_dtx_l2c_cbcx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -7952,8 +7952,8 @@ union cvmx_dtx_l2c_cbcx_enax {
 	struct cvmx_dtx_l2c_cbcx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8024,9 +8024,9 @@ union cvmx_dtx_l2c_mcix_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8053,8 +8053,8 @@ union cvmx_dtx_l2c_mcix_datx {
 	struct cvmx_dtx_l2c_mcix_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8077,8 +8077,8 @@ union cvmx_dtx_l2c_mcix_enax {
 	struct cvmx_dtx_l2c_mcix_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8149,9 +8149,9 @@ union cvmx_dtx_l2c_tadx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8178,8 +8178,8 @@ union cvmx_dtx_l2c_tadx_datx {
 	struct cvmx_dtx_l2c_tadx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8202,8 +8202,8 @@ union cvmx_dtx_l2c_tadx_enax {
 	struct cvmx_dtx_l2c_tadx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8270,9 +8270,9 @@ union cvmx_dtx_lapx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8295,8 +8295,8 @@ union cvmx_dtx_lapx_datx {
 	struct cvmx_dtx_lapx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8315,8 +8315,8 @@ union cvmx_dtx_lapx_enax {
 	struct cvmx_dtx_lapx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8377,9 +8377,9 @@ union cvmx_dtx_lbk_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8404,8 +8404,8 @@ union cvmx_dtx_lbk_datx {
 	struct cvmx_dtx_lbk_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8426,8 +8426,8 @@ union cvmx_dtx_lbk_enax {
 	struct cvmx_dtx_lbk_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8494,9 +8494,9 @@ union cvmx_dtx_lmcx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8523,8 +8523,8 @@ union cvmx_dtx_lmcx_datx {
 	struct cvmx_dtx_lmcx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8547,8 +8547,8 @@ union cvmx_dtx_lmcx_enax {
 	struct cvmx_dtx_lmcx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8614,9 +8614,9 @@ union cvmx_dtx_mdbx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8638,8 +8638,8 @@ union cvmx_dtx_mdbx_datx {
 	struct cvmx_dtx_mdbx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8657,8 +8657,8 @@ union cvmx_dtx_mdbx_enax {
 	struct cvmx_dtx_mdbx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8714,9 +8714,9 @@ union cvmx_dtx_mhbw_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8738,8 +8738,8 @@ union cvmx_dtx_mhbw_datx {
 	struct cvmx_dtx_mhbw_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8757,8 +8757,8 @@ union cvmx_dtx_mhbw_enax {
 	struct cvmx_dtx_mhbw_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8819,9 +8819,9 @@ union cvmx_dtx_mio_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8848,8 +8848,8 @@ union cvmx_dtx_mio_datx {
 	struct cvmx_dtx_mio_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8872,8 +8872,8 @@ union cvmx_dtx_mio_enax {
 	struct cvmx_dtx_mio_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8940,9 +8940,9 @@ union cvmx_dtx_ocx_bot_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -8965,8 +8965,8 @@ union cvmx_dtx_ocx_bot_datx {
 	struct cvmx_dtx_ocx_bot_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -8985,8 +8985,8 @@ union cvmx_dtx_ocx_bot_enax {
 	struct cvmx_dtx_ocx_bot_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9045,9 +9045,9 @@ union cvmx_dtx_ocx_lnkx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9070,8 +9070,8 @@ union cvmx_dtx_ocx_lnkx_datx {
 	struct cvmx_dtx_ocx_lnkx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9090,8 +9090,8 @@ union cvmx_dtx_ocx_lnkx_enax {
 	struct cvmx_dtx_ocx_lnkx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9150,9 +9150,9 @@ union cvmx_dtx_ocx_olex_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9175,8 +9175,8 @@ union cvmx_dtx_ocx_olex_datx {
 	struct cvmx_dtx_ocx_olex_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9195,8 +9195,8 @@ union cvmx_dtx_ocx_olex_enax {
 	struct cvmx_dtx_ocx_olex_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9255,9 +9255,9 @@ union cvmx_dtx_ocx_top_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9280,8 +9280,8 @@ union cvmx_dtx_ocx_top_datx {
 	struct cvmx_dtx_ocx_top_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9300,8 +9300,8 @@ union cvmx_dtx_ocx_top_enax {
 	struct cvmx_dtx_ocx_top_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9361,9 +9361,9 @@ union cvmx_dtx_osm_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9387,8 +9387,8 @@ union cvmx_dtx_osm_datx {
 	struct cvmx_dtx_osm_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9408,8 +9408,8 @@ union cvmx_dtx_osm_enax {
 	struct cvmx_dtx_osm_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9470,9 +9470,9 @@ union cvmx_dtx_pcsx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9495,8 +9495,8 @@ union cvmx_dtx_pcsx_datx {
 	struct cvmx_dtx_pcsx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9515,8 +9515,8 @@ union cvmx_dtx_pcsx_enax {
 	struct cvmx_dtx_pcsx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9579,9 +9579,9 @@ union cvmx_dtx_pemx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9608,8 +9608,8 @@ union cvmx_dtx_pemx_datx {
 	struct cvmx_dtx_pemx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9632,8 +9632,8 @@ union cvmx_dtx_pemx_enax {
 	struct cvmx_dtx_pemx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9700,9 +9700,9 @@ union cvmx_dtx_pip_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9725,8 +9725,8 @@ union cvmx_dtx_pip_datx {
 	struct cvmx_dtx_pip_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9745,8 +9745,8 @@ union cvmx_dtx_pip_enax {
 	struct cvmx_dtx_pip_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9807,9 +9807,9 @@ union cvmx_dtx_pki_pbe_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9834,8 +9834,8 @@ union cvmx_dtx_pki_pbe_datx {
 	struct cvmx_dtx_pki_pbe_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9856,8 +9856,8 @@ union cvmx_dtx_pki_pbe_enax {
 	struct cvmx_dtx_pki_pbe_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9922,9 +9922,9 @@ union cvmx_dtx_pki_pfe_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -9949,8 +9949,8 @@ union cvmx_dtx_pki_pfe_datx {
 	struct cvmx_dtx_pki_pfe_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -9971,8 +9971,8 @@ union cvmx_dtx_pki_pfe_enax {
 	struct cvmx_dtx_pki_pfe_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10037,9 +10037,9 @@ union cvmx_dtx_pki_pix_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10064,8 +10064,8 @@ union cvmx_dtx_pki_pix_datx {
 	struct cvmx_dtx_pki_pix_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10086,8 +10086,8 @@ union cvmx_dtx_pki_pix_enax {
 	struct cvmx_dtx_pki_pix_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10154,9 +10154,9 @@ union cvmx_dtx_pko_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10183,8 +10183,8 @@ union cvmx_dtx_pko_datx {
 	struct cvmx_dtx_pko_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10207,8 +10207,8 @@ union cvmx_dtx_pko_enax {
 	struct cvmx_dtx_pko_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10274,9 +10274,9 @@ union cvmx_dtx_pnbx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10298,8 +10298,8 @@ union cvmx_dtx_pnbx_datx {
 	struct cvmx_dtx_pnbx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10317,8 +10317,8 @@ union cvmx_dtx_pnbx_enax {
 	struct cvmx_dtx_pnbx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10374,9 +10374,9 @@ union cvmx_dtx_pnbdx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10398,8 +10398,8 @@ union cvmx_dtx_pnbdx_datx {
 	struct cvmx_dtx_pnbdx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10417,8 +10417,8 @@ union cvmx_dtx_pnbdx_enax {
 	struct cvmx_dtx_pnbdx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10475,9 +10475,9 @@ union cvmx_dtx_pow_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10500,8 +10500,8 @@ union cvmx_dtx_pow_datx {
 	struct cvmx_dtx_pow_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10520,8 +10520,8 @@ union cvmx_dtx_pow_enax {
 	struct cvmx_dtx_pow_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10579,9 +10579,9 @@ union cvmx_dtx_prch_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10603,8 +10603,8 @@ union cvmx_dtx_prch_datx {
 	struct cvmx_dtx_prch_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10622,8 +10622,8 @@ union cvmx_dtx_prch_enax {
 	struct cvmx_dtx_prch_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10679,9 +10679,9 @@ union cvmx_dtx_psm_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10703,8 +10703,8 @@ union cvmx_dtx_psm_datx {
 	struct cvmx_dtx_psm_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10722,8 +10722,8 @@ union cvmx_dtx_psm_enax {
 	struct cvmx_dtx_psm_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10781,9 +10781,9 @@ union cvmx_dtx_rad_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10807,8 +10807,8 @@ union cvmx_dtx_rad_datx {
 	struct cvmx_dtx_rad_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10828,8 +10828,8 @@ union cvmx_dtx_rad_enax {
 	struct cvmx_dtx_rad_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10889,9 +10889,9 @@ union cvmx_dtx_rdec_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -10913,8 +10913,8 @@ union cvmx_dtx_rdec_datx {
 	struct cvmx_dtx_rdec_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10932,8 +10932,8 @@ union cvmx_dtx_rdec_enax {
 	struct cvmx_dtx_rdec_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -10989,9 +10989,9 @@ union cvmx_dtx_rfif_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11013,8 +11013,8 @@ union cvmx_dtx_rfif_datx {
 	struct cvmx_dtx_rfif_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11032,8 +11032,8 @@ union cvmx_dtx_rfif_enax {
 	struct cvmx_dtx_rfif_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11089,9 +11089,9 @@ union cvmx_dtx_rmap_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11113,8 +11113,8 @@ union cvmx_dtx_rmap_datx {
 	struct cvmx_dtx_rmap_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11132,8 +11132,8 @@ union cvmx_dtx_rmap_enax {
 	struct cvmx_dtx_rmap_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11192,9 +11192,9 @@ union cvmx_dtx_rnm_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11219,8 +11219,8 @@ union cvmx_dtx_rnm_datx {
 	struct cvmx_dtx_rnm_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11241,8 +11241,8 @@ union cvmx_dtx_rnm_enax {
 	struct cvmx_dtx_rnm_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11309,9 +11309,9 @@ union cvmx_dtx_rst_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11338,8 +11338,8 @@ union cvmx_dtx_rst_datx {
 	struct cvmx_dtx_rst_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11362,8 +11362,8 @@ union cvmx_dtx_rst_enax {
 	struct cvmx_dtx_rst_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11544,9 +11544,9 @@ union cvmx_dtx_sli_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11573,8 +11573,8 @@ union cvmx_dtx_sli_datx {
 	struct cvmx_dtx_sli_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11597,8 +11597,8 @@ union cvmx_dtx_sli_enax {
 	struct cvmx_dtx_sli_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11764,9 +11764,9 @@ union cvmx_dtx_sriox_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11788,8 +11788,8 @@ union cvmx_dtx_sriox_datx {
 	struct cvmx_dtx_sriox_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11807,8 +11807,8 @@ union cvmx_dtx_sriox_enax {
 	struct cvmx_dtx_sriox_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11867,9 +11867,9 @@ union cvmx_dtx_sso_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -11894,8 +11894,8 @@ union cvmx_dtx_sso_datx {
 	struct cvmx_dtx_sso_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11916,8 +11916,8 @@ union cvmx_dtx_sso_enax {
 	struct cvmx_dtx_sso_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -11979,9 +11979,9 @@ union cvmx_dtx_tdec_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12003,8 +12003,8 @@ union cvmx_dtx_tdec_datx {
 	struct cvmx_dtx_tdec_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12022,8 +12022,8 @@ union cvmx_dtx_tdec_enax {
 	struct cvmx_dtx_tdec_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12084,9 +12084,9 @@ union cvmx_dtx_tim_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12113,8 +12113,8 @@ union cvmx_dtx_tim_datx {
 	struct cvmx_dtx_tim_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12137,8 +12137,8 @@ union cvmx_dtx_tim_enax {
 	struct cvmx_dtx_tim_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12204,9 +12204,9 @@ union cvmx_dtx_ulfe_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12228,8 +12228,8 @@ union cvmx_dtx_ulfe_datx {
 	struct cvmx_dtx_ulfe_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12247,8 +12247,8 @@ union cvmx_dtx_ulfe_enax {
 	struct cvmx_dtx_ulfe_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12307,9 +12307,9 @@ union cvmx_dtx_usbdrdx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12334,8 +12334,8 @@ union cvmx_dtx_usbdrdx_datx {
 	struct cvmx_dtx_usbdrdx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12356,8 +12356,8 @@ union cvmx_dtx_usbdrdx_enax {
 	struct cvmx_dtx_usbdrdx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12420,9 +12420,9 @@ union cvmx_dtx_usbhx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12445,8 +12445,8 @@ union cvmx_dtx_usbhx_datx {
 	struct cvmx_dtx_usbhx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12465,8 +12465,8 @@ union cvmx_dtx_usbhx_enax {
 	struct cvmx_dtx_usbhx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12524,9 +12524,9 @@ union cvmx_dtx_vdec_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12548,8 +12548,8 @@ union cvmx_dtx_vdec_datx {
 	struct cvmx_dtx_vdec_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12567,8 +12567,8 @@ union cvmx_dtx_vdec_enax {
 	struct cvmx_dtx_vdec_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12624,9 +12624,9 @@ union cvmx_dtx_wpse_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12648,8 +12648,8 @@ union cvmx_dtx_wpse_datx {
 	struct cvmx_dtx_wpse_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12667,8 +12667,8 @@ union cvmx_dtx_wpse_enax {
 	struct cvmx_dtx_wpse_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12724,9 +12724,9 @@ union cvmx_dtx_wrce_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12748,8 +12748,8 @@ union cvmx_dtx_wrce_datx {
 	struct cvmx_dtx_wrce_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12767,8 +12767,8 @@ union cvmx_dtx_wrce_enax {
 	struct cvmx_dtx_wrce_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12824,9 +12824,9 @@ union cvmx_dtx_wrde_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12848,8 +12848,8 @@ union cvmx_dtx_wrde_datx {
 	struct cvmx_dtx_wrde_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12867,8 +12867,8 @@ union cvmx_dtx_wrde_enax {
 	struct cvmx_dtx_wrde_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12924,9 +12924,9 @@ union cvmx_dtx_wrse_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -12948,8 +12948,8 @@ union cvmx_dtx_wrse_datx {
 	struct cvmx_dtx_wrse_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -12967,8 +12967,8 @@ union cvmx_dtx_wrse_enax {
 	struct cvmx_dtx_wrse_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13024,9 +13024,9 @@ union cvmx_dtx_wtxe_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -13048,8 +13048,8 @@ union cvmx_dtx_wtxe_datx {
 	struct cvmx_dtx_wtxe_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13067,8 +13067,8 @@ union cvmx_dtx_wtxe_enax {
 	struct cvmx_dtx_wtxe_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13125,9 +13125,9 @@ union cvmx_dtx_xcv_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -13150,8 +13150,8 @@ union cvmx_dtx_xcv_datx {
 	struct cvmx_dtx_xcv_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13170,8 +13170,8 @@ union cvmx_dtx_xcv_enax {
 	struct cvmx_dtx_xcv_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13229,9 +13229,9 @@ union cvmx_dtx_xsx_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -13253,8 +13253,8 @@ union cvmx_dtx_xsx_datx {
 	struct cvmx_dtx_xsx_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13272,8 +13272,8 @@ union cvmx_dtx_xsx_enax {
 	struct cvmx_dtx_xsx_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13331,9 +13331,9 @@ union cvmx_dtx_zip_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
-                                                         only. */
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block
+                                                         debug data. Not applicable when software directly reads the DAT(0..1) registers.
+                                                         For diagnostic use only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -13357,8 +13357,8 @@ union cvmx_dtx_zip_datx {
 	struct cvmx_dtx_zip_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
-                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the
+                                                         ability to peek into blocks during an OCLA capture without OCLA reconfiguration. */
 #else
 	uint64_t raw                          : 36;
 	uint64_t reserved_36_63               : 28;
@@ -13378,8 +13378,8 @@ union cvmx_dtx_zip_enax {
 	struct cvmx_dtx_zip_enax_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
-                                                         only one block will drive each bit. */
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug
+                                                         buses. Normally only one block will drive each bit. */
 #else
 	uint64_t ena                          : 36;
 	uint64_t reserved_36_63               : 28;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 38a3422fe9bd..61ff53742ff2 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -3393,7 +3393,7 @@ union cvmx_fpa_poolx_cfg {
                                                          0x1 = LDT.
                                                          0x2 = Load with DWB.
                                                          0x3 = Reserved. */
-	uint64_t s_type                       : 1;  /**< Type of store to use when sending pages to L2:
+	uint64_t s_type                       : 1;  /**< Type of store to use when FPA sends stores to L2:
                                                          0 = use STF.
                                                          1 = use STT. */
 	uint64_t nat_align                    : 1;  /**< Returning buffers should be rounded to the nearest natural alignment specified with
diff --git a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
index 7e1a2761c210..0028afc10d7d 100644
--- a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -8486,7 +8486,7 @@ union cvmx_gmxx_rxx_int_en {
                                                          character /E/ will be included as part of the
                                                          frame and does not cause a frame termination.
                                                          (XAUI Mode only) */
-	uint64_t bad_seq                      : 1;  /**< Reserved Sequence Deteted
+	uint64_t bad_seq                      : 1;  /**< Detected reserved sequence.
                                                          (XAUI Mode only) */
 	uint64_t rem_fault                    : 1;  /**< Remote Fault Sequence Deteted
                                                          (XAUI Mode only) */
@@ -8500,7 +8500,7 @@ union cvmx_gmxx_rxx_int_en {
                                                          (SGMII/1000Base-X half-duplex only) */
 	uint64_t falerr                       : 1;  /**< False carrier error or extend error after slottime
                                                          (SGMII/1000Base-X only) */
-	uint64_t rsverr                       : 1;  /**< Reserved opcodes */
+	uint64_t rsverr                       : 1;  /**< Detected reserved opcode. */
 	uint64_t pcterr                       : 1;  /**< Bad Preamble / Protocol */
 	uint64_t ovrerr                       : 1;  /**< Internal Data Aggregation Overflow
                                                          (SGMII/1000Base-X only) */
@@ -9174,7 +9174,7 @@ union cvmx_gmxx_rxx_int_reg {
                                                          character /E/ will be included as part of the
                                                          frame and does not cause a frame termination.
                                                          (XAUI Mode only) */
-	uint64_t bad_seq                      : 1;  /**< Reserved Sequence Deteted
+	uint64_t bad_seq                      : 1;  /**< Detected reserved sequence.
                                                          (XAUI Mode only) */
 	uint64_t rem_fault                    : 1;  /**< Remote Fault Sequence Deteted
                                                          (XAUI Mode only) */
@@ -9189,7 +9189,7 @@ union cvmx_gmxx_rxx_int_reg {
                                                          (SGMII/1000Base-X half-duplex only) */
 	uint64_t falerr                       : 1;  /**< False carrier error or extend error after slottime
                                                          (SGMII/1000Base-X only) */
-	uint64_t rsverr                       : 1;  /**< Reserved opcodes */
+	uint64_t rsverr                       : 1;  /**< Detected reserved opcode. */
 	uint64_t pcterr                       : 1;  /**< Bad Preamble / Protocol
                                                          In XAUI mode, the column of data that was bad
                                                          will be logged in GMX_RX_XAUI_BAD_COL */
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index 3884667d8b09..66046a86f3b1 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -409,7 +409,7 @@ union cvmx_gpio_bit_cfgx {
 	uint64_t clk_gen                      : 1;  /**< When TX_OE is set, GPIO pin becomes a clock */
 	uint64_t clk_sel                      : 2;  /**< Selects which of the 4 GPIO clock generators */
 	uint64_t fil_sel                      : 4;  /**< Filter select. Global counter bit-select (controls sample rate). */
-	uint64_t fil_cnt                      : 4;  /**< Filter count. Specifies the number of consecutive samples (FIL_CNT+1) to change state.
+	uint64_t fil_cnt                      : 4;  /**< Filter count. Specifies the number of consecutive samples ([FIL_CNT]+1) to change state.
                                                          Zero to disable the filter. */
 	uint64_t int_type                     : 1;  /**< Type of interrupt when pin is an input and [INT_EN] set. When set, rising edge interrupt,
                                                          else level interrupt. Only valid for GPIO 0..15, no function for GPIO 16..31. */
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 7a70b545f535..6e74a0f991c1 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -1059,6 +1059,34 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 #define CVMX_GSERX_LANEX_RX_CTLE_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_DELTA_PM_0(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_DELTA_PM_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440080ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_DELTA_PM_0(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440080ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_DELTA_PM_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_DELTA_PM_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440088ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_DELTA_PM_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440088ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -2476,100 +2504,127 @@ static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long offset)
 static inline uint64_t CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460268ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460268ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460268ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460268ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_KR_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_KR_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460250ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460250ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_KR_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460250ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_KR_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460250ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_KX4_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_KX4_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460248ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460248ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_KX4_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460248ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_KX4_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460248ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_KX_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_KX_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460240ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460240ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_KX_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460240ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_KX_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460240ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_PCIE1_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_PCIE1_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460228ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460228ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_PCIE1_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460228ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_PCIE1_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460228ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_PCIE2_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_PCIE2_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460230ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460230ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_PCIE2_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460230ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_PCIE2_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460230ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_PCIE3_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_PCIE3_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460238ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460238ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_PCIE3_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460238ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_PCIE3_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460238ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_QSGMII_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_QSGMII_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460260ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460260ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_QSGMII_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460260ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_QSGMII_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460260ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_RX_LDLL_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_RX_LDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460218ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460218ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_RX_LDLL_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460218ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_RX_LDLL_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460218ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsigned long block_id)
@@ -2589,12 +2644,15 @@ static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsi
 static inline uint64_t CVMX_GSERX_SLICEX_SGMII_MODE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_SGMII_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
-	return CVMX_ADD_IO_SEG(0x0001180090460258ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+	return CVMX_ADD_IO_SEG(0x0001180090460258ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
 }
 #else
-#define CVMX_GSERX_SLICEX_SGMII_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460258ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#define CVMX_GSERX_SLICEX_SGMII_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460258ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long offset)
@@ -3025,7 +3083,9 @@ union cvmx_gserx_cfg {
 	uint64_t rmac                         : 1;  /**< When set, indicates the GSER is configured for RMAC mode. [RMAC] must not be set
                                                          when any of [BGX,PCIE,SRIO] are set. [RMAC] must only be set for DLM6, DLM7, and
                                                          DLM8 (i.e. GSER6, GSER7, and GSER8). */
-	uint64_t srio                         : 1;  /**< When set, indicates the GSER is configured for SRIO mode. [SRIO] must not be set
+	uint64_t srio                         : 1;  /**< For CNF73XX, this field is reserved.
+                                                         For CNF75XX, when set, indicates the GSER is configured for SRIO mode. [SRIO] must not be
+                                                         set
                                                          when any of [BGX,PCIE,RMAC] are set. [SRIO] must only be set for QLM2 and QLM3
                                                          (i.e. GSER2 and GSER3). */
 	uint64_t sata                         : 1;  /**< Unused. */
@@ -4535,7 +4595,7 @@ union cvmx_gserx_lanex_lbert_ecnt {
 	uint64_t lbert_err_ovbit14            : 1;  /**< If this bit is set, multiply [LBERT_ERR_CNT] by 128.
                                                          If this bit is set and [LBERT_ERR_CNT] = 2^15-1, signals
                                                          overflow of the counter. */
-	uint64_t lbert_err_cnt                : 15; /**< Current error count.
+	uint64_t lbert_err_cnt                : 15; /**< Current bit error count.
                                                          If [LBERT_ERR_OVBIT14] is active, then multiply
                                                          count by 128. */
 #else
@@ -4987,8 +5047,8 @@ union cvmx_gserx_lanex_pcs_macifc_mon_2 {
 	uint64_t tx_coeff_req                 : 1;  /**< Current state of the MAC to PCS TX coefficient request input. */
 	uint64_t tx_vboost_en                 : 1;  /**< Current state of the MAC to PCS TX Vboost enable input. */
 	uint64_t tx_swing                     : 5;  /**< Current state of the MAC to PCS TX equalizer swing<4:0> input. */
-	uint64_t tx_pre                       : 4;  /**< Current state of the MAC to PCS TX equalizer pre emphasis<3:0> input. */
-	uint64_t tx_post                      : 5;  /**< Current state of the MAC to PCS TX equalizer post emphasis<4:0> input. */
+	uint64_t tx_pre                       : 4;  /**< Current state of the MAC to PCS TX equalizer preemphasis<3:0> input. */
+	uint64_t tx_post                      : 5;  /**< Current state of the MAC to PCS TX equalizer postemphasis<4:0> input. */
 #else
 	uint64_t tx_post                      : 5;
 	uint64_t tx_pre                       : 4;
@@ -5810,6 +5870,65 @@ union cvmx_gserx_lanex_rx_ctle_ctrl {
 };
 typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
 
+/**
+ * cvmx_gser#_lane#_rx_delta_pm_0
+ *
+ * These are the RAW PCS per-lane RX VMA performance metric 0 register. These registers are for
+ * diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_delta_pm_0 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_delta_pm_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_6_63                : 58;
+	uint64_t sds_pcs_rx_vma_delta_pm_max  : 6;  /**< RX VMA Delta performance metric.
+                                                         <5:3> = Inverted delta.
+                                                         <2:0> = VMA window count upper bits <18:16>.
+                                                                 Lower bits in GSER()_LANE()_RX_DELTA_PM_1
+                                                                 [SDS_PCS_RX_VMA_DELTA_PM_MAX]. */
+#else
+	uint64_t sds_pcs_rx_vma_delta_pm_max  : 6;
+	uint64_t reserved_6_63                : 58;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_delta_pm_0_s cn73xx;
+	struct cvmx_gserx_lanex_rx_delta_pm_0_s cn78xx;
+	struct cvmx_gserx_lanex_rx_delta_pm_0_s cn78xxp1;
+	struct cvmx_gserx_lanex_rx_delta_pm_0_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_delta_pm_0 cvmx_gserx_lanex_rx_delta_pm_0_t;
+
+/**
+ * cvmx_gser#_lane#_rx_delta_pm_1
+ *
+ * These are the RAW PCS per-lane RX VMA performance metric 0 register. These registers are for
+ * diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
+ * fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_delta_pm_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_delta_pm_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t sds_pcs_rx_vma_delta_pm_max  : 16; /**< RX VMA Delta performance metric.
+                                                         VMA window count lower bits <15:0>.
+                                                         Upper bits in GSER()_LANE()_RX_DELTA_PM_0
+                                                         [SDS_PCS_RX_VMA_DELTA_PM_MAX]. */
+#else
+	uint64_t sds_pcs_rx_vma_delta_pm_max  : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_delta_pm_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_delta_pm_1_s cn78xx;
+	struct cvmx_gserx_lanex_rx_delta_pm_1_s cn78xxp1;
+	struct cvmx_gserx_lanex_rx_delta_pm_1_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_delta_pm_1 cvmx_gserx_lanex_rx_delta_pm_1_t;
+
 /**
  * cvmx_gser#_lane#_rx_loop_ctrl
  *
@@ -6760,8 +6879,8 @@ union cvmx_gserx_lanex_sds_pin_mon_2 {
 	uint64_t pcs_sds_tx_turbos_en         : 1;  /**< TX turbo mode enable signal, increases swing of TX
                                                          through current mode. */
 	uint64_t pcs_sds_premptap             : 9;  /**< Preemphasis control.
-                                                         <8:4> = Post-cursor.
-                                                         <3:0> = Pre-cursor. */
+                                                         <8:4> = Postcursor.
+                                                         <3:0> = Precursor. */
 #else
 	uint64_t pcs_sds_premptap             : 9;
 	uint64_t pcs_sds_tx_turbos_en         : 1;
@@ -6778,8 +6897,8 @@ typedef union cvmx_gserx_lanex_sds_pin_mon_2 cvmx_gserx_lanex_sds_pin_mon_2_t;
 /**
  * cvmx_gser#_lane#_tx_cfg_0
  *
- * These registers are for diagnostic use only. These registers are reset by hardware only during
- * chip cold reset. The values of the CSR fields in these registers do not change during chip
+ * These registers are reset by hardware only during chip cold reset. The
+ * values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
 union cvmx_gserx_lanex_tx_cfg_0 {
@@ -6798,23 +6917,16 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 	uint64_t cfg_tx_swing                 : 5;  /**< TX output swing control.
                                                          Default swing encoding when GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN] is
                                                          asserted.
-                                                         Recommended settings:
-                                                         When auto-negotiated link training is not present, including XFI and all
-                                                         protocols <= 6.25Gbaud except PCIe, the transmit swing should be manually
-                                                         over-ridden. GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN] should be set
-                                                         and [CFG_TX_SWING] configures the swing. A transmit swing change should be
-                                                         followed by a control interface configuration over-ride to force the
-                                                         new setting - see GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ].
-                                                         [CFG_TX_SWING] should be derived from signal integrity simulations
-                                                         with the IBIS-AMI model supplied by Cavium when auto-negotiated link
-                                                         training is not present and link speed <= 6.25 Gbaud.
-                                                         <pre>
-                                                             Frequency          Possibly useful [CFG_TX_SWING] value
-                                                             --------------------------------------------------------
-                                                              6.25 Gbaud             0xa
-                                                              10.3125 Gbaud          0xd
-                                                              other                  0x7
-                                                         </pre> */
+                                                         It is recommended to not use the GSER()_LANE()_TX_CFG_0[CFG_TX_SWING],
+                                                         GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN,TX_PREMPTAP_OVRRD_VAL], or
+                                                         GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] override registers for 10BASE-KR,
+                                                         SRIO or PCIe links in which the transmitter is adapted by the respective
+                                                         hardware-controlled link training protocols.
+                                                         The [CFG_TX_SWING] value for transmitter swing should be derived from
+                                                         signal integrity simulations with IBIS-AMI models supplied by Cavium.
+                                                         A transmit swing change should be followed by a control interface configuration
+                                                         over-ride to force the new setting - see
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ]. */
 	uint64_t fast_rdet_mode               : 1;  /**< Assert to enable fast RX detection. For simulation purposes only. */
 	uint64_t fast_tristate_mode           : 1;  /**< Assert to enable fast tristate power up. For simulation purposes only. */
 	uint64_t reserved_0_0                 : 1;
@@ -6880,8 +6992,8 @@ typedef union cvmx_gserx_lanex_tx_cfg_0 cvmx_gserx_lanex_tx_cfg_0_t;
 /**
  * cvmx_gser#_lane#_tx_cfg_1
  *
- * These registers are for diagnostic use only. These registers are reset by hardware only during
- * chip cold reset. The values of the CSR fields in these registers do not change during chip
+ * These registers are reset by hardware only during chip cold reset. The
+ * values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
 union cvmx_gserx_lanex_tx_cfg_1 {
@@ -6897,21 +7009,26 @@ union cvmx_gserx_lanex_tx_cfg_1 {
                                                          0x3 = 20-bit. */
 	uint64_t tx_vboost_en_ovrrd_en        : 1;  /**< Override enable for pcs_sds_txX_vboost_en, TX  vboost mode enable. */
 	uint64_t tx_turbo_en_ovrrd_en         : 1;  /**< Override enable for pcs_sds_txX_turbo_en, Turbo mode enable. */
-	uint64_t tx_swing_ovrrd_en            : 1;  /**< Override enable for pcs_sds_txX_swing, TX swing.
-                                                         Recommended settings:
-                                                         When auto-negotiated link training is not present, including XFI and all
-                                                         protocols <= 6.25Gbaud except PCIe, the transmit swing should be manually
-                                                         over-ridden. [TX_SWING_OVRRD_EN] should be set and
-                                                         GSER()_LANE()_TX_CFG_0[CFG_TX_SWING] configures the swing. A transmit swing
-                                                         change should be followed by a control interface configuration over-ride to
-                                                         force the new setting - see GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ]. */
-	uint64_t tx_premptap_ovrrd_val        : 1;  /**< Override enable for pcs_sds_txX_preemptap, preemphasis control.
-                                                         Recommended settings:
-                                                         When auto-negotiated link training is not present, including XFI and all
-                                                         protocols <= 6.25Gbaud except PCIe, the transmit preemphasis pre and post
-                                                         cursor values should be manually over-ridden.  [TX_PREMPTAP_OVRRD_VAL] should
-                                                         be set and GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] has the pre and post
-                                                         cursor values. A preemphasis control change should be followed by a control
+	uint64_t tx_swing_ovrrd_en            : 1;  /**< Override enable for pcs_sds_txX_swing, TX swing. See
+                                                         GSER()_LANE()_TX_CFG_0[CFG_TX_SWING].
+                                                         It is recommended to not use the GSER()_LANE()_TX_CFG_0[CFG_TX_SWING],
+                                                         GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN,TX_PREMPTAP_OVRRD_VAL], or
+                                                         GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] override registers for 10BASE-KR,
+                                                         SRIO or PCIe links in which the transmitter is adapted by the respective
+                                                         hardware-controlled link training protocols.
+                                                         A transmit swing change should be followed by a control interface
+                                                         configuration over-ride to force the new setting - see
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ]. */
+	uint64_t tx_premptap_ovrrd_val        : 1;  /**< Override enable for pcs_sds_txX_preemptap, preemphasis control. When
+                                                         over-riding,  [TX_PREMPTAP_OVRRD_VAL] should be set and
+                                                         GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] has the precursor and
+                                                         postcursor values.
+                                                         It is recommended to not use the GSER()_LANE()_TX_CFG_0[CFG_TX_SWING],
+                                                         GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN,TX_PREMPTAP_OVRRD_VAL], or
+                                                         GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] override registers for 10BASE-KR,
+                                                         SRIO or PCIe links in which the transmitter is adapted by the respective
+                                                         hardware-controlled link training protocols.
+                                                         A preemphasis control change should be followed by a control
                                                          interface configuration override to force the new setting - see
                                                          GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ]. */
 	uint64_t tx_elec_idle_ovrrd_en        : 1;  /**< Override enable for pcs_sds_txX_elec_idle, TX electrical idle. */
@@ -7061,8 +7178,8 @@ typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
 /**
  * cvmx_gser#_lane#_tx_pre_emphasis
  *
- * These registers are for diagnostic use only. These registers are reset by hardware only during
- * chip cold reset. The values of the CSR fields in these registers do not change during chip
+ * These registers are reset by hardware only during chip cold reset. The
+ * values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
 union cvmx_gserx_lanex_tx_pre_emphasis {
@@ -7071,28 +7188,20 @@ union cvmx_gserx_lanex_tx_pre_emphasis {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t cfg_tx_premptap              : 9;  /**< Override preemphasis control. Applies when
-                                                         GSER()_LANE()_TX_CFG_3[TX_PREMPTAP_OVRRD_EN] is asserted.
-                                                         <8:4> = Post-cursor.
-                                                         <3:0> = Pre-cursor.
-                                                         Recommended settings:
-                                                         When auto-negotiated link training is not present, including XFI and all
-                                                         protocols <= 6.25Gbaud except PCIe, the transmit preemphasis pre and post
-                                                         cursor values should be manually over-ridden.
-                                                         GSER()_LANE()_TX_CFG_1[TX_PREMPTAP_OVRRD_VAL] should be set
-                                                         and [CFG_TX_PREMPTAP] has the pre and post cursor values. A preemphasis
-                                                         control change should be followed by a control interface configuration
-                                                         over-ride to force the new setting - see
-                                                         GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ].
-                                                         [CFG_TX_PREMPTAP] should be derived from signal integrity simulations
-                                                         with the IBIS-AMI model supplied by Cavium when auto-negotiated link
-                                                         training is not present and link speed <= 6.25 Gbaud.
-                                                         <pre>
-                                                            Frequency        Possibly useful [CFG_TX_PREMPTAP] value
-                                                            --------------------------------------------------------
-                                                             6,25 Gbaud            0xa0
-                                                             10.3125 Gbaud         0xd0
-                                                             other                 0xf0
-                                                         </pre> */
+                                                         GSER()_LANE()_TX_CFG_1[TX_PREMPTAP_OVRRD_VAL] is asserted.
+                                                         <8:4> = Postcursor.
+                                                         <3:0> = Precursor.
+                                                         It is recommended to not use the GSER()_LANE()_TX_CFG_0[CFG_TX_SWING],
+                                                         GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN,TX_PREMPTAP_OVRRD_VAL], or
+                                                         GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] override registers for 10BASE-KR,
+                                                         SRIO or PCIe links in which the transmitter is adapted by the respective
+                                                         hardware-controlled link training protocols.
+                                                         The [CFG_TX_PREEMPTAP] value for transmitter preemphasis and
+                                                         postemphasis should be derived from signal integrity simulations
+                                                         with IBIS-AMI models supplied by Cavium.
+                                                         A preemphasis control change should be followed by a control interface
+                                                         configuration over-ride to force the new setting - see
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ]. */
 #else
 	uint64_t cfg_tx_premptap              : 9;
 	uint64_t reserved_9_63                : 55;
@@ -9134,10 +9243,7 @@ union cvmx_gserx_refclk_sel {
 	struct cvmx_gserx_refclk_sel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t pcie_refclk125               : 1;  /**< For bootable PCIe links, this is loaded with
-                                                         PCIE0/2_REFCLK_125 at cold reset and indicates a 125 MHz reference clock when set. For
-                                                         non-bootable PCIe links, this bit is set to zero at cold reset and indicates a 100 MHz
-                                                         reference clock. It is not used for non-PCIe links. */
+	uint64_t pcie_refclk125               : 1;  /**< Reserved. */
 	uint64_t com_clk_sel                  : 1;  /**< When set, the reference clock is sourced from the external clock mux. */
 	uint64_t use_com1                     : 1;  /**< This bit controls the external mux select. When set, QLMC_REF_CLK1_N/P
                                                          are selected as the reference clock. When clear, QLMC_REF_CLK0_N/P are selected as the
@@ -9629,7 +9735,7 @@ union cvmx_gserx_sata_lanex_tx_preemphx {
 	struct cvmx_gserx_sata_lanex_tx_preemphx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t tx_preemph                   : 7;  /**< This static value sets the TX driver de-emphasis value in the
+	uint64_t tx_preemph                   : 7;  /**< This static value sets the TX driver deemphasis value in the
                                                          case where the PHY is running at the Gen1, Gen2, and Gen3
                                                          rates. Used for tuning at the board level for RX eye compliance.
                                                          This register is used for SATA lanes only for GSER(4). */
@@ -9706,7 +9812,7 @@ union cvmx_gserx_sata_p0_tx_preemph_genx {
 	struct cvmx_gserx_sata_p0_tx_preemph_genx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t tx_preemph                   : 6;  /**< This static value sets the TX driver de-emphasis value in the
+	uint64_t tx_preemph                   : 6;  /**< This static value sets the TX driver deemphasis value in the
                                                          case where the PHY is running at the Gen1, Gen2, and Gen3
                                                          rates. Used for tuning at the board level for RX eye compliance. */
 #else
@@ -10010,7 +10116,7 @@ typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_cei_6g_sr_mode {
 	uint64_t u64;
@@ -10065,6 +10171,9 @@ union cvmx_gserx_slicex_cei_6g_sr_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_cei_6g_sr_mode_s cn73xx;
+	struct cvmx_gserx_slicex_cei_6g_sr_mode_s cn78xx;
+	struct cvmx_gserx_slicex_cei_6g_sr_mode_s cn78xxp1;
+	struct cvmx_gserx_slicex_cei_6g_sr_mode_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_cei_6g_sr_mode cvmx_gserx_slicex_cei_6g_sr_mode_t;
 
@@ -10075,7 +10184,7 @@ typedef union cvmx_gserx_slicex_cei_6g_sr_mode cvmx_gserx_slicex_cei_6g_sr_mode_
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_kr_mode {
 	uint64_t u64;
@@ -10130,6 +10239,9 @@ union cvmx_gserx_slicex_kr_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_kr_mode_s    cn73xx;
+	struct cvmx_gserx_slicex_kr_mode_s    cn78xx;
+	struct cvmx_gserx_slicex_kr_mode_s    cn78xxp1;
+	struct cvmx_gserx_slicex_kr_mode_s    cnf75xx;
 };
 typedef union cvmx_gserx_slicex_kr_mode cvmx_gserx_slicex_kr_mode_t;
 
@@ -10140,7 +10252,7 @@ typedef union cvmx_gserx_slicex_kr_mode cvmx_gserx_slicex_kr_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_kx4_mode {
 	uint64_t u64;
@@ -10169,7 +10281,7 @@ union cvmx_gserx_slicex_kx4_mode {
 	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
-                                                         0x1 = 3.125 GHz.
+                                                         0x1 = 3.125 GHz, or SATA mode.
                                                          0x3 = 4 GHz.
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
@@ -10178,7 +10290,7 @@ union cvmx_gserx_slicex_kx4_mode {
 	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
-                                                         0x1 = 3.125 GHz.
+                                                         0x1 = 3.125 GHz, or SATA mode.
                                                          0x3 = 4 GHz.
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
@@ -10195,6 +10307,9 @@ union cvmx_gserx_slicex_kx4_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_kx4_mode_s   cn73xx;
+	struct cvmx_gserx_slicex_kx4_mode_s   cn78xx;
+	struct cvmx_gserx_slicex_kx4_mode_s   cn78xxp1;
+	struct cvmx_gserx_slicex_kx4_mode_s   cnf75xx;
 };
 typedef union cvmx_gserx_slicex_kx4_mode cvmx_gserx_slicex_kx4_mode_t;
 
@@ -10205,7 +10320,7 @@ typedef union cvmx_gserx_slicex_kx4_mode cvmx_gserx_slicex_kx4_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_kx_mode {
 	uint64_t u64;
@@ -10234,7 +10349,7 @@ union cvmx_gserx_slicex_kx_mode {
 	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
-                                                         0x1 = 3.125 GHz.
+                                                         0x1 = 3.125 GHz, or SATA mode.
                                                          0x3 = 4 GHz.
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
@@ -10243,7 +10358,7 @@ union cvmx_gserx_slicex_kx_mode {
 	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
-                                                         0x1 = 3.125 GHz.
+                                                         0x1 = 3.125 GHz, or SATA mode.
                                                          0x3 = 4 GHz.
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
@@ -10260,6 +10375,9 @@ union cvmx_gserx_slicex_kx_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_kx_mode_s    cn73xx;
+	struct cvmx_gserx_slicex_kx_mode_s    cn78xx;
+	struct cvmx_gserx_slicex_kx_mode_s    cn78xxp1;
+	struct cvmx_gserx_slicex_kx_mode_s    cnf75xx;
 };
 typedef union cvmx_gserx_slicex_kx_mode cvmx_gserx_slicex_kx_mode_t;
 
@@ -10270,7 +10388,7 @@ typedef union cvmx_gserx_slicex_kx_mode cvmx_gserx_slicex_kx_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_pcie1_mode {
 	uint64_t u64;
@@ -10295,8 +10413,7 @@ union cvmx_gserx_slicex_pcie1_mode {
                                                          0x1 = 3.125 GHz.
                                                          0x6 = 4 GHz.
                                                          0x7 = 5.15625 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_PI_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
@@ -10305,8 +10422,7 @@ union cvmx_gserx_slicex_pcie1_mode {
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
                                                          0x7 = 6.25 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_LDLL_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
@@ -10315,8 +10431,7 @@ union cvmx_gserx_slicex_pcie1_mode {
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
                                                          0x7 = 6.25 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_SDLL_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 #else
 	uint64_t rx_sdll_bwsel                : 3;
 	uint64_t rx_ldll_bwsel                : 3;
@@ -10328,6 +10443,9 @@ union cvmx_gserx_slicex_pcie1_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_pcie1_mode_s cn73xx;
+	struct cvmx_gserx_slicex_pcie1_mode_s cn78xx;
+	struct cvmx_gserx_slicex_pcie1_mode_s cn78xxp1;
+	struct cvmx_gserx_slicex_pcie1_mode_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_pcie1_mode cvmx_gserx_slicex_pcie1_mode_t;
 
@@ -10338,7 +10456,7 @@ typedef union cvmx_gserx_slicex_pcie1_mode cvmx_gserx_slicex_pcie1_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_pcie2_mode {
 	uint64_t u64;
@@ -10363,8 +10481,7 @@ union cvmx_gserx_slicex_pcie2_mode {
                                                          0x1 = 3.125 GHz.
                                                          0x6 = 4 GHz.
                                                          0x7 = 5.15625 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_PI_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
@@ -10373,8 +10490,7 @@ union cvmx_gserx_slicex_pcie2_mode {
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
                                                          0x7 = 6.25 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_LDLL_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
@@ -10383,8 +10499,7 @@ union cvmx_gserx_slicex_pcie2_mode {
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
                                                          0x7 = 6.25 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_SDLL_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 #else
 	uint64_t rx_sdll_bwsel                : 3;
 	uint64_t rx_ldll_bwsel                : 3;
@@ -10396,6 +10511,9 @@ union cvmx_gserx_slicex_pcie2_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_pcie2_mode_s cn73xx;
+	struct cvmx_gserx_slicex_pcie2_mode_s cn78xx;
+	struct cvmx_gserx_slicex_pcie2_mode_s cn78xxp1;
+	struct cvmx_gserx_slicex_pcie2_mode_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_pcie2_mode cvmx_gserx_slicex_pcie2_mode_t;
 
@@ -10406,7 +10524,7 @@ typedef union cvmx_gserx_slicex_pcie2_mode cvmx_gserx_slicex_pcie2_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_pcie3_mode {
 	uint64_t u64;
@@ -10431,28 +10549,25 @@ union cvmx_gserx_slicex_pcie3_mode {
                                                          0x1 = 3.125 GHz.
                                                          0x6 = 4 GHz.
                                                          0x7 = 5.15625 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_PI_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
-                                                         0x1 = 3.125 GHz.
+                                                         0x1 = 3.125 GHz, or SATA mode.
                                                          0x3 = 4 GHz.
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
                                                          0x7 = 6.25 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_LDLL_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
                                                          based on the PLL clock frequency as follows:
                                                          0x0 = 2.5 GHz.
-                                                         0x1 = 3.125 GHz.
+                                                         0x1 = 3.125 GHz, or SATA mode.
                                                          0x3 = 4 GHz.
                                                          0x5 = 5.15625 GHz.
                                                          0x6 = 5.65 GHz.
                                                          0x7 = 6.25 GHz.
-                                                         All other values in this field are reserved.
-                                                         In SATA Mode program RX_SDLL_BWSEL = 0x1. */
+                                                         All other values in this field are reserved. */
 #else
 	uint64_t rx_sdll_bwsel                : 3;
 	uint64_t rx_ldll_bwsel                : 3;
@@ -10464,6 +10579,9 @@ union cvmx_gserx_slicex_pcie3_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_pcie3_mode_s cn73xx;
+	struct cvmx_gserx_slicex_pcie3_mode_s cn78xx;
+	struct cvmx_gserx_slicex_pcie3_mode_s cn78xxp1;
+	struct cvmx_gserx_slicex_pcie3_mode_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_pcie3_mode cvmx_gserx_slicex_pcie3_mode_t;
 
@@ -10474,7 +10592,7 @@ typedef union cvmx_gserx_slicex_pcie3_mode cvmx_gserx_slicex_pcie3_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_qsgmii_mode {
 	uint64_t u64;
@@ -10529,6 +10647,9 @@ union cvmx_gserx_slicex_qsgmii_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_qsgmii_mode_s cn73xx;
+	struct cvmx_gserx_slicex_qsgmii_mode_s cn78xx;
+	struct cvmx_gserx_slicex_qsgmii_mode_s cn78xxp1;
+	struct cvmx_gserx_slicex_qsgmii_mode_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_qsgmii_mode cvmx_gserx_slicex_qsgmii_mode_t;
 
@@ -10539,7 +10660,7 @@ typedef union cvmx_gserx_slicex_qsgmii_mode cvmx_gserx_slicex_qsgmii_mode_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_rx_ldll_ctrl {
 	uint64_t u64;
@@ -10574,6 +10695,9 @@ union cvmx_gserx_slicex_rx_ldll_ctrl {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_rx_ldll_ctrl_s cn73xx;
+	struct cvmx_gserx_slicex_rx_ldll_ctrl_s cn78xx;
+	struct cvmx_gserx_slicex_rx_ldll_ctrl_s cn78xxp1;
+	struct cvmx_gserx_slicex_rx_ldll_ctrl_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_rx_ldll_ctrl cvmx_gserx_slicex_rx_ldll_ctrl_t;
 
@@ -10659,7 +10783,7 @@ typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  *
- * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_sgmii_mode {
 	uint64_t u64;
@@ -10714,6 +10838,9 @@ union cvmx_gserx_slicex_sgmii_mode {
 #endif
 	} s;
 	struct cvmx_gserx_slicex_sgmii_mode_s cn73xx;
+	struct cvmx_gserx_slicex_sgmii_mode_s cn78xx;
+	struct cvmx_gserx_slicex_sgmii_mode_s cn78xxp1;
+	struct cvmx_gserx_slicex_sgmii_mode_s cnf75xx;
 };
 typedef union cvmx_gserx_slicex_sgmii_mode cvmx_gserx_slicex_sgmii_mode_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 1af94c47c1fd..c79a7a41c535 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -193,7 +193,7 @@ typedef union cvmx_user_static_pko_queue_config
 	{
 		struct pko_queues_cfg {
 			unsigned
-				queues_per_port:5,
+				queues_per_port:11,
 				qos_enable:1,
 				pfc_enable:1;
 		} pko_cfg_iface[6];
diff --git a/arch/mips/include/asm/octeon/cvmx-iob-defs.h b/arch/mips/include/asm/octeon/cvmx-iob-defs.h
index cc10264065ef..81cadb60eaa1 100644
--- a/arch/mips/include/asm/octeon/cvmx-iob-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iob-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 06a58270644d..8e40f68e7d5b 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -872,9 +872,11 @@ union cvmx_iobn_pp_bist_status {
 	struct cvmx_iobn_pp_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t pp_bstat                     : 48; /**< BIST Status of the cores. Bit vector position is the number of the core (i.e. core 0 ==
-                                                         PP_BSTAT<0>). Only even number bits are valid; all odd number bits are read as 0. For odd
-                                                         number cores, see IOBP_PP_BIST_STATUS. */
+	uint64_t pp_bstat                     : 48; /**< BIST Status of the cores. Bit vector position is the physical number of the core
+                                                         (i.e. core 0 == PP_BSTAT<0>). Only even number bits are valid; all odd number bits
+                                                         are read as 0. For odd number cores, see IOBP_PP_BIST_STATUS.
+                                                         Software must bit-wise logical AND IOBN_PP_BIST_STATUS with CIU_FUSE before using
+                                                         it. */
 #else
 	uint64_t pp_bstat                     : 48;
 	uint64_t reserved_48_63               : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
index a575ccb2e71d..6585afc6903f 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
@@ -339,9 +339,11 @@ union cvmx_iobp_pp_bist_status {
 	struct cvmx_iobp_pp_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t pp_bstat                     : 48; /**< BIST status of cores. Bit vector position is the number of the core (i.e. core 0 ==
-                                                         PP_BSTAT<0>). Only odd number bits are valid;, all even number bits are read as 0. For
-                                                         even number cores, see IOBN_PP_BIST_STATUS. */
+	uint64_t pp_bstat                     : 48; /**< BIST status of cores. Bit vector position is the physical number of the core
+                                                         (i.e. core 1 == PP_BSTAT<1>). Only odd number bits are valid; all even number
+                                                         bits are read as 0. For even number cores, see IOBN_PP_BIST_STATUS.
+                                                         Software must bit-wise logical AND IOBN_PP_BIST_STATUS with CIU_FUSE before using
+                                                         it. */
 #else
 	uint64_t pp_bstat                     : 48;
 	uint64_t reserved_48_63               : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd-defs.h b/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
index 1836f37c2d90..5b29481875a3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 32773506c2e4..54a82c87e190 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -2669,8 +2669,11 @@ union cvmx_l2c_cbcx_int {
 	uint64_t mibsbe                       : 1;  /**< Reserved. */
 	uint64_t ioccmddbe                    : 1;  /**< IOCCMD double-bit error occurred. See L2C_CBC(0..3)_IOCERR for logged information. */
 	uint64_t ioccmdsbe                    : 1;  /**< IOCCMD single-bit error occurred. See L2C_CBC(0..3)_IOCERR for logged information. */
-	uint64_t rsddbe                       : 1;  /**< RSD double-bit error occurred. See L2C_CBC()_RSDERR for logged information. */
-	uint64_t rsdsbe                       : 1;  /**< RSD single-bit error occurred. See L2C_CBC()_RSDERR for logged information. */
+	uint64_t rsddbe                       : 1;  /**< RSD double-bit error occurred. See L2C_CBC()_RSDERR for logged information.
+                                                         An indication of a hardware failure and may be considered fatal. */
+	uint64_t rsdsbe                       : 1;  /**< RSD single-bit error occurred. See L2C_CBC()_RSDERR for logged
+                                                         information. Hardware automatically corrected the error. Software may choose to
+                                                         count the number of these single-bit errors. */
 #else
 	uint64_t rsdsbe                       : 1;
 	uint64_t rsddbe                       : 1;
@@ -2848,13 +2851,12 @@ typedef union cvmx_l2c_cbcx_miberr cvmx_l2c_cbcx_miberr_t;
 /**
  * cvmx_l2c_cbc#_rsderr
  *
- * This register records error information for all CBC RSD errors.
- * An error locks the INDEX and [SYN] and sets the bit corresponding to the error received.
- * RSDDBE errors take priority and overwrite an earlier logged RSDSBE error. Only one of
- * [RSDSBE]/[RSDDBE] is set at any given time and serves to document which error the INDEX/[SYN]
- * is
- * associated with.
- * The syndrome is recorded for DBE errors, though the utility of the value is not clear.
+ * This register records error information for all CBC RSD errors. An error locks the
+ * [INDEX] and [SYN] and sets the bit corresponding to the error received. RSDDBE
+ * errors take priority and overwrite an earlier logged RSDSBE error. Only one of
+ * [RSDSBE]/[RSDDBE] is set at any given time and serves to document which error the
+ * INDEX/[SYN] is associated with. The syndrome is recorded for DBE errors, though the
+ * utility of the value is not clear.
  */
 union cvmx_l2c_cbcx_rsderr {
 	uint64_t u64;
@@ -6281,8 +6283,10 @@ union cvmx_l2c_mcix_int {
 	struct cvmx_l2c_mcix_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t vbfdbe                       : 1;  /**< VBF double-bit error occurred. See L2C_MCI()_ERR for logged information. */
-	uint64_t vbfsbe                       : 1;  /**< VBF single-bit error occurred. See L2C_MCI()_ERR for logged information. */
+	uint64_t vbfdbe                       : 1;  /**< VBF double-bit error occurred. See L2C_MCI()_ERR for logged information.
+                                                         An indication of a hardware failure and may be considered fatal. */
+	uint64_t vbfsbe                       : 1;  /**< VBF single-bit error occurred. See L2C_MCI()_ERR for logged information.
+                                                         Hardware corrected the failure. Software may choose to count these single-bit errors. */
 #else
 	uint64_t vbfsbe                       : 1;
 	uint64_t vbfdbe                       : 1;
@@ -7063,9 +7067,9 @@ typedef union cvmx_l2c_rsdx_pfc cvmx_l2c_rsdx_pfc_t;
  *
  * This register records error information for all RTG SBE/DBE errors.
  * The priority of errors (lowest to highest) is SBE, DBE. An error locks [SYN], [WAY],
- * and [L2IDX] fields for equal or lower priority errors until cleared by software.
+ * and [L2IDX] for equal or lower priority errors until cleared by software.
  * The syndrome is recorded for DBE errors, though the utility of the value is not clear.
- * [L2IDX][19:7] is the L2 block index associated with the command which had no way to allocate.
+ * [L2IDX]<19:7> is the L2 block index associated with the command which had no way to allocate.
  */
 union cvmx_l2c_rtgx_err {
 	uint64_t u64;
@@ -7076,8 +7080,9 @@ union cvmx_l2c_rtgx_err {
 	uint64_t reserved_39_61               : 23;
 	uint64_t syn                          : 7;  /**< Syndrome for the single-bit error. */
 	uint64_t reserved_24_31               : 8;
-	uint64_t way                          : 4;  /**< Way of the L2 block containing the error */
-	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error */
+	uint64_t way                          : 4;  /**< Way of the L2 block containing the error. */
+	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error.
+                                                         See L2C_TAD()_INT_W1C[RTGSBE] for an important use of this field. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -7668,13 +7673,31 @@ union cvmx_l2c_tadx_int {
 	uint64_t reserved_36_63               : 28;
 	uint64_t wrdisoci                     : 1;  /**< Reserved. */
 	uint64_t rddisoci                     : 1;  /**< Reserved. */
-	uint64_t rtgdbe                       : 1;  /**< RTG double-bit error. */
-	uint64_t rtgsbe                       : 1;  /**< RTG single-bit error. */
+	uint64_t rtgdbe                       : 1;  /**< RTG double-bit error.
+                                                         See L2C_TAD()_RTG_ERR for logged information.
+                                                         An indication of a hardware failure and may be considered fatal. */
+	uint64_t rtgsbe                       : 1;  /**< RTG single-bit error on a read. See L2C_TAD()_RTG_ERR for logged
+                                                         information. When [RTGSBE] is set, hardware corrected the error before using the
+                                                         RTG tag, but did not correct any stored value. When [RTGSBE] is set, software
+                                                         should eject the RTG location indicated by the corresponding
+                                                         L2C_TAD()_RTG_ERR[WAY,L2IDX] before clearing [RTGSBE]. Otherwise, hardware may
+                                                         encounter the error again the next time the same RTG location is
+                                                         referenced. Software may also choose to count the number of these single-bit
+                                                         errors.
+                                                         The eject should use a CACHE 0x3 instruction with an effective address of:
+                                                         <pre>
+                                                           payload<24> = 1
+                                                           payload<23:20> = L2C_TAD()_RTG_ERR[WAY]
+                                                           payload<19:7>  = L2C_TAD()_RTG_ERR[L2IDX]
+                                                         </pre> */
 	uint64_t reserved_18_31               : 14;
 	uint64_t lfbto                        : 1;  /**< An LFB entry (or more) has encountered a timeout condition When LFBTO timeout condition
                                                          occurs L2C_TAD()_TIMEOUT is loaded. L2C_TAD()_TIMEOUT is loaded with info from the
                                                          first LFB that timed out. if multiple LFB timed out simultaneously, then the it will
-                                                         capture info from the lowest LFB number that timed out. */
+                                                         capture info from the lowest LFB number that timed out.
+                                                         Should not occur during normal operation.  OCI/CCPI link failures may cause this
+                                                         failure. This may be an indication of hardware failure, and may be considered
+                                                         fatal. */
 	uint64_t reserved_15_16               : 2;
 	uint64_t bigrd                        : 1;  /**< Read reference past L2C_BIG_CTL[MAXDRAM] occurred. [BIGRD] interrupts can occur during
                                                          normal operation as the cores are allowed to prefetch to nonexistent memory locations.
@@ -7684,8 +7707,26 @@ union cvmx_l2c_tadx_int {
 	uint64_t holerd                       : 1;  /**< Read reference to 256MB hole occurred. */
 	uint64_t holewr                       : 1;  /**< Write reference to 256MB hole occurred. */
 	uint64_t reserved_2_10                : 9;
-	uint64_t l2ddbe                       : 1;  /**< L2D double-bit error occurred. See L2C_TQD()_ERR for logged information. */
-	uint64_t l2dsbe                       : 1;  /**< L2D single-bit error occurred. See L2C_TQD()_ERR for logged information. */
+	uint64_t l2ddbe                       : 1;  /**< L2D double-bit error occurred. See L2C_TAD()_TQD_ERR for logged information. An
+                                                         indication of a hardware failure and may be considered fatal. */
+	uint64_t l2dsbe                       : 1;  /**< L2D single-bit error on a read. See L2C_TAD()_TQD_ERR for logged
+                                                         information. When [L2DSBE] is set, hardware corrected the error before using the
+                                                         data, but did not correct any stored value. When [L2DSBE] is set, software
+                                                         should eject the cache block indicated by the corresponding
+                                                         L2C_TAD()_TQD_ERR[QDNUM,L2DIDX] before clearing [L2DSBE]. Otherwise, hardware
+                                                         may encounter the error again the next time the same L2D location is
+                                                         referenced. Software may also choose to count the number of these single-bit
+                                                         errors.
+                                                         The eject should use a CACHE 0x3 instruction with an effective address of:
+                                                         <pre>
+                                                           payload<24:22> = 0
+                                                           payload<21:18> = L2C_TAD()_TQD_ERR[L2DIDX]<10:7>  // way
+                                                           payload<17:11> = L2C_TAD()_TQD_ERR[L2DIDX]<6:0>   // index<10:4>
+                                                           payload<10:9>  = L2C_TAD()_TQD_ERR[L2DIDX]<12:11> // index<3:2>
+                                                           payload<8:7>   = tad             // index<1:0>
+                                                         </pre>
+                                                         where tad is the TAD index from this CSR. Note that L2C_CTL[DISIDXALIAS] has no
+                                                         effect on the payload. */
 #else
 	uint64_t l2dsbe                       : 1;
 	uint64_t l2ddbe                       : 1;
@@ -8308,7 +8349,7 @@ union cvmx_l2c_tadx_timeout {
 	uint64_t u64;
 	struct cvmx_l2c_tadx_timeout_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t infolfb                      : 1;  /**< Logged address information is for the LFB original transation. */
+	uint64_t infolfb                      : 1;  /**< Logged address information is for the LFB original transaction. */
 	uint64_t infovab                      : 1;  /**< Logged address information is for the VAB (replacement). If both this and [INFOLFB] is
                                                          set,
                                                          then both could have timed out, but info captured is from the original LFB. */
@@ -8354,7 +8395,9 @@ union cvmx_l2c_tadx_timetwo {
 	struct cvmx_l2c_tadx_timetwo_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_33_63               : 31;
-	uint64_t sid                          : 4;  /**< Source id of the original request, that is 'source' of request. */
+	uint64_t sid                          : 4;  /**< Source id of the original request, that is 'source' of request. This is only valid if the
+                                                         request is a local request (valid if L2C_TAD()_TIMEOUT[CMD] is an XMC request and not
+                                                         relevant if it is an CCPI request). */
 	uint64_t busid                        : 4;  /**< Busid of the original request, that is 'source' of request. */
 	uint64_t vabst                        : 3;  /**< This is the LFB internal state if INFOLFB is set, else will contain VAB internal state if
                                                          INFOVAB is set. */
@@ -8381,8 +8424,13 @@ typedef union cvmx_l2c_tadx_timetwo cvmx_l2c_tadx_timetwo_t;
 /**
  * cvmx_l2c_tad_ctl
  *
- * "* If MAXLFB is != 0, VBF_THRESH should be less than MAXLFB.
- * * If MAXVBF is != 0, VBF_THRESH should be less than MAXVBF."
+ * In CNXXXX, MAXLFB, EXLRQ, EXRRQ, EXFWD, EXVIC refer to half-TAD LFBs/VABs. Therefore, even
+ * though there are 24 LFBs/VABs in a full TAD, the number applies to both halves.
+ * * If [MAXLFB] is written to 0 or 13-15 operation is undefined. (CN78XX pass 1.0).
+ * * If [MAXLFB] is != 0, [VBF_THRESH] should be less than [MAXLFB].
+ * * If [MAXVBF] is != 0, [VBF_THRESH] should be less than [MAXVBF].
+ * * If [MAXLFB] != 0, [EXLRQ] + [EXRRQ] + [EXFWD] + [EXVIC] must be less than or equal to MAXLFB
+ * - 3.
  */
 union cvmx_l2c_tad_ctl {
 	uint64_t u64;
@@ -8399,7 +8447,9 @@ union cvmx_l2c_tad_ctl {
 	uint64_t exfwd                        : 4;  /**< Reserved. */
 	uint64_t exvic                        : 4;  /**< Reserved. */
 	uint64_t vbf_thresh                   : 4;  /**< VBF threshold. When the number of in-use VBFs exceeds this number the L2C TAD increases
-                                                         the priority of all its write operations in the LMC. */
+                                                         the priority of all its write operations in the LMC.
+                                                         If [MAXLFB] is != 0x0, [VBF_THRESH] should be less than [MAXLFB].
+                                                         If [MAXVBF] is != 0x0, [VBF_THRESH] should be less than [MAXVBF]. */
 	uint64_t maxvbf                       : 4;  /**< Maximum VBFs in use at once (0 means 16, 1-15 as expected). */
 	uint64_t maxlfb                       : 4;  /**< Maximum VABs/LFBs in use at once (0 means 16, 1-15 as expected). */
 #else
@@ -8519,7 +8569,8 @@ union cvmx_l2c_tqdx_err {
 	uint64_t qdnum                        : 3;  /**< Quad containing the error. */
 	uint64_t qdhlf                        : 1;  /**< Quad half of the containing the error. */
 	uint64_t l2didx                       : 14; /**< For L2D errors, index within the quad-half containing the error. For SBF and FBF errors
-                                                         <13:5> is 0x0 and <4:0> is the index of the error (<4:1> is lfbnum<3:0>, <0> is addr<5>). */
+                                                         <13:5> is 0x0 and <4:0> is the index of the error (<4:1> is lfbnum<3:0>, <0> is addr<5>).
+                                                         See L2C_TAD()_INT[L2DSBE] for an important use of this field. */
 #else
 	uint64_t l2didx                       : 14;
 	uint64_t qdhlf                        : 1;
@@ -8679,7 +8730,8 @@ union cvmx_l2c_ttgx_err {
 	uint64_t syn                          : 7;  /**< Syndrome for the single-bit error. */
 	uint64_t reserved_24_31               : 8;
 	uint64_t way                          : 4;  /**< Way of the L2 block containing the error. */
-	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error. */
+	uint64_t l2idx                        : 13; /**< Index of the L2 block containing the error.
+                                                         See L2C_TAD()_INT[TAGSBE] for an important use of this field. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
diff --git a/arch/mips/include/asm/octeon/cvmx-l2d-defs.h b/arch/mips/include/asm/octeon/cvmx-l2d-defs.h
index 9312afebb545..1479f31bff03 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2d-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2d-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-l2t-defs.h b/arch/mips/include/asm/octeon/cvmx-l2t-defs.h
index 0a0f68429bfc..043354244e07 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2t-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2t-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-led-defs.h b/arch/mips/include/asm/octeon/cvmx-led-defs.h
index 76a3f0e7e402..ed2a0e64fc47 100644
--- a/arch/mips/include/asm/octeon/cvmx-led-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-led-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index f34d2f91fa5e..22f7d67a3a39 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -2075,7 +2075,7 @@ union cvmx_lmcx_bank_conflict1 {
 	uint64_t u64;
 	struct cvmx_lmcx_bank_conflict1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cnt                          : 64; /**< Bank conflict counter. A 64-bit counter that increments at every dclk
+	uint64_t cnt                          : 64; /**< Bank conflict counter. A 64-bit counter that increments at every DCLK
                                                          cycles when LMC could not issue R/W operations to the DRAM due to
                                                          bank conflict. This increments when all 8 In-Flight buffers are not
                                                          utilized. */
@@ -2095,7 +2095,7 @@ union cvmx_lmcx_bank_conflict2 {
 	uint64_t u64;
 	struct cvmx_lmcx_bank_conflict2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cnt                          : 64; /**< Bank conflict counter. A 64-bit counter that increments at every dclk
+	uint64_t cnt                          : 64; /**< Bank conflict counter. A 64-bit counter that increments at every DCLK
                                                          cycles when LMC could not issue R/W operations to the DRAM due to
                                                          bank conflict. This increments only when there are less than 4 In-Flight
                                                          buffers occupied. */
@@ -2121,9 +2121,9 @@ union cvmx_lmcx_bist_ctl {
 	uint64_t reserved_5_63                : 59;
 	uint64_t macram_bist_status           : 1;  /**< Maximum Activate Counts RAM BIST status.
                                                          1 means fail. */
-	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; 1 means fail. */
+	uint64_t dlcram_bist_status           : 1;  /**< DLC RAM BIST status; one means fail. */
 	uint64_t dlcram_bist_done             : 1;  /**< DLC and MAC RAM BIST complete indication;
-                                                         1 means both RAMs have completed. */
+                                                         One means both RAMs have completed. */
 	uint64_t start_bist                   : 1;  /**< Start BIST on DLC and MAC memory. */
 	uint64_t reserved_0_0                 : 1;
 #else
@@ -2254,21 +2254,17 @@ union cvmx_lmcx_char_ctl {
 	struct cvmx_lmcx_char_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
-	uint64_t dq_char_byte_check           : 1;  /**< When set, LMC performs loopback pattern check on a byte. The selection of the byte is
-                                                         controlled by the LMC()_CHAR_CTL[CSR DQ_CHAR_BYTE_SEL]. */
-	uint64_t dq_char_check_lock           : 1;  /**< Indicates if a lock has been achieved. Is set to 1 only if a lock is achieved during the
-                                                         LFSR priming period after DQ_CHAR_CHECK_ENABLE is set to 1, and is forced back to 0 when
-                                                         DQ_CHAR_CHECK_ENABLE is set to 0. */
-	uint64_t dq_char_check_enable         : 1;  /**< Enable DQ pattern check. The transition from disabled to enabled clears
-                                                         LMC()_CHAR_DQ_ERR_COUNT. */
-	uint64_t dq_char_bit_sel              : 3;  /**< Select a bit within the byte for DQ characterization pattern check. */
-	uint64_t dq_char_byte_sel             : 4;  /**< Select a byte of data for DQ characterization pattern check. */
-	uint64_t dr                           : 1;  /**< Pattern at data rate (not clock rate). */
-	uint64_t skew_on                      : 1;  /**< Skew adjacent bits. */
-	uint64_t en                           : 1;  /**< Enable characterization. */
-	uint64_t sel                          : 1;  /**< Pattern select: 0 = PRBS, 1 = programmable pattern. */
-	uint64_t prog                         : 8;  /**< Programmable pattern. */
-	uint64_t prbs                         : 32; /**< PRBS polynomial. */
+	uint64_t dq_char_byte_check           : 1;  /**< Reserved. */
+	uint64_t dq_char_check_lock           : 1;  /**< Reserved. */
+	uint64_t dq_char_check_enable         : 1;  /**< Reserved. */
+	uint64_t dq_char_bit_sel              : 3;  /**< Reserved. */
+	uint64_t dq_char_byte_sel             : 4;  /**< Reserved. */
+	uint64_t dr                           : 1;  /**< Reserved. */
+	uint64_t skew_on                      : 1;  /**< Reserved. */
+	uint64_t en                           : 1;  /**< Reserved. */
+	uint64_t sel                          : 1;  /**< Reserved. */
+	uint64_t prog                         : 8;  /**< Reserved. */
+	uint64_t prbs                         : 32; /**< The LFSR polynomials used when generating data sequence. See LMC()_DBTRAIN_CTL[LFSR_PATTERN_SEL]. */
 #else
 	uint64_t prbs                         : 32;
 	uint64_t prog                         : 8;
@@ -2403,8 +2399,8 @@ union cvmx_lmcx_char_mask0 {
 	struct cvmx_lmcx_char_mask0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t mask                         : 64; /**< Mask for DQ0<63:0>.
-                                                         Before enabling ECC Corrupt generation logic by setting
-                                                         LMC()_ECC_PARITY_TEST[ECC_CORRUPT_ENA], set any the MASK bits to 1 to flip the
+                                                         Before enabling ECC corrupt generation logic by setting
+                                                         LMC()_ECC_PARITY_TEST[ECC_CORRUPT_ENA], set any the MASK bits to one to flip the
                                                          corresponding bits of the lower 64-bit dataword during a write data transfer. */
 #else
 	uint64_t mask                         : 64;
@@ -2472,7 +2468,7 @@ union cvmx_lmcx_char_mask2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t mask                         : 64; /**< Mask for DQ1<63:0>.
                                                          Before enabling ECC Corrupt generation logic by setting
-                                                         LMC()_ECC_PARITY_TEST[ECC_CORRUPT_ENA], set any the MASK bits to 1 to flip the
+                                                         LMC()_ECC_PARITY_TEST[ECC_CORRUPT_ENA], set any the MASK bits to one to flip the
                                                          corresponding bits of the upper 64-bit dataword during a write data transfer. */
 #else
 	uint64_t mask                         : 64;
@@ -2819,7 +2815,7 @@ union cvmx_lmcx_comp_ctl2 {
                                                            0x4 = 34 ohm.
                                                            0x5 = 40 ohm.
                                                            0x6 = 48 ohm.
-                                                           _ else = Reserved." */
+                                                           _ else = Reserved. */
 	uint64_t dqx_ctl                      : 4;  /**< Drive strength control for DDR_DQ* /DDR_CB* /DDR_DQS_*_P/N drivers.
                                                          0x1 = 24 ohm.
                                                          0x2 = 26.67 ohm.
@@ -3052,7 +3048,7 @@ typedef union cvmx_lmcx_comp_ctl2 cvmx_lmcx_comp_ctl2_t;
  * * Prior to the self-refresh exit sequence, LMC()_MODEREG_PARAMS0 should be reprogrammed
  * (if needed) to the appropriate values.
  *
- * See LMC Initialization Sequence for the LMC bring-up sequence.
+ * See LMC initialization sequence for the LMC bringup sequence.
  */
 union cvmx_lmcx_config {
 	uint64_t u64;
@@ -3060,9 +3056,9 @@ union cvmx_lmcx_config {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t lrdimm_ena                   : 1;  /**< Reserved. */
 	uint64_t bg2_enable                   : 1;  /**< BG1 enable bit. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
-                                                         Set to 1 when using DDR4 x4 or x8 parts.
-                                                         Clear to 0 when using DDR4 x16 parts. */
-	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
+                                                         Set to one when using DDR4 x4 or x8 parts.
+                                                         Clear to zero when using DDR4 x16 parts. */
+	uint64_t mode_x4dev                   : 1;  /**< DDR x4 device mode. */
 	uint64_t mode32b                      : 1;  /**< 32-bit datapath mode. When set, only 32 DQ pins are used. */
 	uint64_t scrz                         : 1;  /**< Hide LMC()_SCRAMBLE_CFG0 and LMC()_SCRAMBLE_CFG1 when set. */
 	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ. */
@@ -3095,7 +3091,7 @@ union cvmx_lmcx_config {
                                                          * DDR#_A<4> is swapped with DDR#_A<3>.
                                                          For CN70XX, MIRRMASK<3:2> MBZ.
                                                          * When RANK_ENA = 0, MIRRMASK<1> MBZ." */
-	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized. To write-level/read-level/initialize rank
+	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized. To write level/read level/initialize rank
                                                          i, set [RANKMASK]<i>:
                                                          <pre>
                                                                        RANK_ENA = 1   RANK_ENA = 0
@@ -3106,14 +3102,13 @@ union cvmx_lmcx_config {
                                                          </pre>
                                                          For read/write leveling, each rank has to be leveled separately, so [RANKMASK] should only
                                                          have one bit set. [RANKMASK] is not used during self-refresh entry/exit and precharge
-                                                         power-
-                                                         down entry/exit instruction sequences. When [RANK_ENA] = 0, [RANKMASK]<1> and
+                                                         power down entry/exit instruction sequences. When [RANK_ENA] = 0, [RANKMASK]<1> and
                                                          [RANKMASK]<3> MBZ. */
 	uint64_t rank_ena                     : 1;  /**< "RANK enable (for use with dual-rank DIMMs).
                                                          * For dual-rank DIMMs, the [RANK_ENA] bit will enable the drive of the DDR#_DIMM*_CS*_L
                                                          and
                                                          ODT_<1:0> pins differently based on the ([PBANK_LSB] - 1) address bit.
-                                                         * Write 0 for SINGLE ranked DIMMs." */
+                                                         * Write zero for SINGLE ranked DIMMs." */
 	uint64_t sref_with_dll                : 1;  /**< Self-refresh entry/exit write mode registers. When set, self-refresh entry sequence writes
                                                          MR2 and MR1 (in this order, in all ranks), and self-refresh exit sequence writes MR1, MR0,
                                                          MR2, and MR3 (in this order, for all ranks). The write operations occur before self-
@@ -3123,7 +3118,7 @@ union cvmx_lmcx_config {
                                                          lines have a larger delay than the CK line. */
 	uint64_t reserved_18_39               : 22;
 	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT.
-                                                         To cause the reset, software writes this to a 1, then rewrites it to a 0. */
+                                                         To cause the reset, software writes this to a one, then rewrites it to a zero. */
 	uint64_t ecc_adr                      : 1;  /**< Include memory reference address in the ECC calculation.
                                                          0 = disabled, 1 = enabled. */
 	uint64_t forcewrite                   : 4;  /**< Force the oldest outstanding write to complete after having waited for 2^[FORCEWRITE] CK
@@ -3171,20 +3166,20 @@ union cvmx_lmcx_config {
                                                          * Number of row bits of the memory part--specified indirectly by [PBANK_LSB].
                                                          * Number of ranks in a DIMM--specified by [RANK_ENA].
                                                          * Number of DIMMs in the system by the register below ([PBANK_LSB]).
-                                                         Column address starts from mem_addr[3] for 64b (8Bytes) DQ width. [ROW_LSB] is
+                                                         Column address starts from mem_addr[3] for 64b (8 bytes) DQ width. [ROW_LSB] is
                                                          mem_adr[15] for 64b mode. Therefore, the [ROW_LSB] parameter should be set to
                                                          0x1 (64b).
                                                          For example, for a DIMM made of Samsung's K4B1G0846C-F7 1GB (16M * 8 bit * 8 bank)
                                                          parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
                                                          16. So, row = mem_adr<29:16>.
-                                                         Refer to Cache-block Read Transaction Example, Cache-block Read Transaction Example. */
-	uint64_t ecc_ena                      : 1;  /**< ECC enable. When set, enables the 8b ECC check/correct logic. Should be 1 when used with
-                                                         DIMMs with ECC; 0, otherwise.
+                                                         Refer to cache-block read transaction example, Cache-block read transaction example. */
+	uint64_t ecc_ena                      : 1;  /**< ECC enable. When set, enables the 8b ECC check/correct logic. Should be one when used with
+                                                         DIMMs with ECC; zero, otherwise.
                                                          * When this mode is turned on, DQ<71:64> on write operations contains the ECC code
                                                          generated for the 64 bits of data which will be written in the memory. Later on read
                                                          operations, will be used to check for single-bit error (which will be auto-corrected) and
                                                          double-bit error (which will be reported).
-                                                         * When not turned on, DQ<71:64> are driven to 0. Please refer to SEC_ERR, DED_ERR,
+                                                         * When not turned on, DQ<71:64> are driven to zero. Please refer to SEC_ERR, DED_ERR,
                                                          LMC()_FADR, and LMC()_ECC_SYND registers for diagnostics information when there is
                                                          an error. */
 	uint64_t init_start                   : 1;  /**< A 0->1 transition starts the DDR memory sequence that is
@@ -4545,7 +4540,7 @@ union cvmx_lmcx_control {
                                                          the bandwidth allocated to DFA reads. [CRM_MAX] is subdivided into two regions with DFA
                                                          reads being preferred over LMC reads/writes when [CRM_CNT] < [CRM_THR]. [CRM_CNT]
                                                          increments by
-                                                         1 when a DFA read is slotted and by 2 when a LMC read/write is slotted, and rolls over
+                                                         one when a DFA read is slotted and by 2 when a LMC read/write is slotted, and rolls over
                                                          when [CRM_MAX] is reached.
                                                          0x0 = Reserved. */
 	uint64_t rodt_bprch                   : 1;  /**< When set, the turn-off time for the ODT pin during a read command is delayed an additional
@@ -5789,8 +5784,8 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
                                                          back-to-back read commands. Otherwise it will space out back-to-back
                                                          reads with a default value of 4 cycles.
-                                                         While in DRAM MPR mode, reads from Page 0 may use tCCD_S or tCCD_L.
-                                                         Reads from Pages 1, 2 or 3 however must use tCCD_L, thereby requring
+                                                         While in DRAM MPR mode, reads from page 0 may use tCCD_S or tCCD_L.
+                                                         Reads from pages 1, 2 or 3 however must use tCCD_L, thereby requiring
                                                          this bit to be set. */
 	uint64_t rw_train                     : 1;  /**< When set, the sequence will perform a Write to the DRAM
                                                          memory array using burst patern that are set in the CSRs
@@ -5807,7 +5802,7 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t activate                     : 1;  /**< Reserved. */
 	uint64_t prank                        : 2;  /**< Physical rank bits for read/write/activate operation. */
 	uint64_t lrank                        : 3;  /**< Reserved. */
-	uint64_t row_a                        : 18; /**< The row address for the Activate command. */
+	uint64_t row_a                        : 18; /**< The row address for the activate command. */
 	uint64_t bg                           : 2;  /**< The bank group that the R/W commands are directed to. */
 	uint64_t ba                           : 2;  /**< The bank address for the R/W commands are directed to. */
 	uint64_t column_a                     : 13; /**< Column address for the R/W operation. */
@@ -5892,8 +5887,8 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
                                                          back-to-back read commands. Otherwise it will space out back-to-back
                                                          reads with a default value of 4 cycles.
-                                                         While in DRAM MPR mode, reads from Page 0 may use tCCD_S or tCCD_L.
-                                                         Reads from Pages 1, 2 or 3 however must use tCCD_L, thereby requring
+                                                         While in DRAM MPR mode, reads from page 0 may use tCCD_S or tCCD_L.
+                                                         Reads from pages 1, 2 or 3 however must use tCCD_L, thereby requiring
                                                          this bit to be set. */
 	uint64_t rw_train                     : 1;  /**< When set, the sequence will perform a Write to the DRAM
                                                          memory array using burst patern that are set in the CSRs
@@ -5910,7 +5905,7 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t activate                     : 1;  /**< Reserved. */
 	uint64_t prank                        : 2;  /**< Physical rank bits for read/write/activate operation. */
 	uint64_t lrank                        : 3;  /**< Reserved. */
-	uint64_t row_a                        : 18; /**< The row address for the Activate command. */
+	uint64_t row_a                        : 18; /**< The row address for the activate command. */
 	uint64_t bg                           : 2;  /**< The bank group that the R/W commands are directed to. */
 	uint64_t ba                           : 2;  /**< The bank address for the R/W commands are directed to. */
 	uint64_t column_a                     : 13; /**< Column address for the R/W operation. */
@@ -6370,21 +6365,21 @@ typedef union cvmx_lmcx_ddr4_dimm_ctl cvmx_lmcx_ddr4_dimm_ctl_t;
 /**
  * cvmx_lmc#_ddr_pll_ctl
  *
- * This register controls the DDR_CK frequency. For details, refer to CK Speed Programming. See
- * LMC Initialization Sequence for the initialization sequence.
- * DDR PLL Bringup sequence:
+ * This register controls the DDR_CK frequency. For details, refer to CK speed programming. See
+ * LMC initialization sequence for the initialization sequence.
+ * DDR PLL bringup sequence:
  *
- * 1. Write [CLKF], [DDR_PS_EN], DFM_PS_EN, DIFFAMP, CPS, CPB.
+ * 1. Write [CLKF], [CLKR], [DDR_PS_EN].
  *
- * 2. Wait 128 ref clock cycles (7680 rclk cycles).
+ * 2. Wait 128 ref clock cycles (7680 core-clock cycles).
  *
- * 3. Write 1 to RESET_N.
+ * 3. Write 1 to [RESET_N].
  *
- * 4. Wait 1152 ref clocks (1152*16 rclk cycles).
+ * 4. Wait 1152 ref clocks (1152*16 core-clock cycles).
  *
- * 5. Write 0 to DDR_DIV_RESET and DFM_DIV_RESET.
+ * 5. Write 0 to [DDR_DIV_RESET].
  *
- * 6. Wait 10 ref clock cycles (160 rclk cycles) before bringing up the DDR interface
+ * 6. Wait 10 ref clock cycles (160 core-clock cycles) before bringing up the DDR interface.
  */
 union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t u64;
@@ -6393,7 +6388,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_45_63               : 19;
 	uint64_t dclk_alt_refclk_sel          : 1;  /**< Select alternate reference clock for DCLK PLL. */
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
-	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
+	uint64_t dclk_invert                  : 1;  /**< Invert DCLK that feeds LMC/DDR at the south side of the chip. */
 	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
 	uint64_t ddr4_mode                    : 1;  /**< DDR4 mode select: 1 = DDR4, 0 = DDR3. */
 	uint64_t pll_fbslip                   : 1;  /**< PLL FBSLIP indication. */
@@ -6566,7 +6561,7 @@ union cvmx_lmcx_ddr_pll_ctl {
                                                          0xF = Reserved.
                                                          [DDR_PS_EN] is not used when [DDR_DIV_RESET] = 1. */
 	uint64_t reserved_9_17                : 9;
-	uint64_t clkf_ext                     : 1;  /**< A 1-bit extension to the [CLKF] register to support for DDR4-2666. */
+	uint64_t clkf_ext                     : 1;  /**< A 1-bit extension to the [CLKF] register to support for DDR4-2666; effectively [CLKF]<7>. */
 	uint64_t reset_n                      : 1;  /**< PLL reset */
 	uint64_t clkf                         : 7;  /**< Multiply reference by [CLKF]. 31 <= [CLKF] <= 99. LMC PLL frequency = 50 * [CLKF]. min =
                                                          1.6
@@ -6820,7 +6815,7 @@ union cvmx_lmcx_dimm_ctl {
                                                          part. When Par_In is grounded, PARITY should be cleared to 0." */
 	uint64_t tcws                         : 13; /**< LMC waits for this time period before and after a RDIMM control word access during a
                                                          power-up/init SEQUENCE. TCWS is in multiples of 8 CK cycles.
-                                                         Set TCWS (CSR field) = RNDUP[TCWS(ns)/(8 * TCYC(ns))], where TCWS is the desired time
+                                                         Set [TCWS] (CSR field) = RNDUP[TCWS(ns)/(8 * TCYC(ns))], where TCWS is the desired time
                                                          (ns), and TCYC(ns) is the DDR clock frequency (not data rate).
                                                          TYP = 0x4E0 (equivalent to 15 us) when changing clock timing (RC2.DBA1, RC6.DA4, RC10.DA3,
                                                          RC10.DA4, RC11.DA3, and RC11.DA4)
@@ -6894,7 +6889,7 @@ typedef union cvmx_lmcx_dll_ctl cvmx_lmcx_dll_ctl_t;
 /**
  * cvmx_lmc#_dll_ctl2
  *
- * See LMC Initialization Sequence for the initialization sequence.
+ * See LMC initialization sequence for the initialization sequence.
  *
  */
 union cvmx_lmcx_dll_ctl2 {
@@ -7306,11 +7301,11 @@ union cvmx_lmcx_dual_memcfg {
 	uint64_t row_lsb                      : 3;  /**< Encoding used to determine which memory address bit position represents the low order DDR
                                                          ROW address. Refer to
                                                          LMC()_CONFIG[ROW_LSB].
-                                                         Refer to cache-block read transaction example. */
+                                                         Refer to cache block read transaction example. */
 	uint64_t reserved_8_15                : 8;
-	uint64_t cs_mask                      : 8;  /**< Chip-select mask. This mask corresponds to the four chip-select signals for a memory
+	uint64_t cs_mask                      : 8;  /**< Chip select mask. This mask corresponds to the four chip-select signals for a memory
                                                          configuration. Each reference address asserts one of the chip-select signals. If that
-                                                         chip-select signal has its corresponding CS_MASK bit set, then the config1 parameters are
+                                                         chip select signal has its corresponding CS_MASK bit set, then the config1 parameters are
                                                          used, otherwise the config0 parameters are used. */
 #else
 	uint64_t cs_mask                      : 8;
@@ -7383,14 +7378,14 @@ typedef union cvmx_lmcx_dual_memcfg cvmx_lmcx_dual_memcfg_t;
 /**
  * cvmx_lmc#_ecc_parity_test
  *
- * This register has bits to control the generation of ECC and Command Address parity errors.
+ * This register has bits to control the generation of ECC and command address parity errors.
  * ECC error is generated by enabling [CA_PARITY_CORRUPT_ENA] and selecting any of the
  * [ECC_CORRUPT_IDX] index of the dataword from the cacheline to be corrupted.
- * User needs to select which bit of the 128-bits dataword to corrupt by asserting any of the
+ * User needs to select which bit of the 128-bit dataword to corrupt by asserting any of the
  * CHAR_MASK0 and CHAR_MASK2 bits. (CHAR_MASK0 and CHAR_MASK2 corresponds to the lower and upper
  * 64-bit signal that can corrupt any individual bit of the data).
  *
- * Command Address parity error is generated by enabling [CA_PARITY_CORRUPT_ENA] and
+ * Command address parity error is generated by enabling [CA_PARITY_CORRUPT_ENA] and
  * selecting the DDR command that the parity is to be corrupted with through [CA_PARITY_SEL].
  */
 union cvmx_lmcx_ecc_parity_test {
@@ -7399,7 +7394,7 @@ union cvmx_lmcx_ecc_parity_test {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t ecc_corrupt_ena              : 1;  /**< Enables the ECC data corruption. */
-	uint64_t ecc_corrupt_idx              : 3;  /**< Selects the cacheline index that the dataword is to be corrupted with. */
+	uint64_t ecc_corrupt_idx              : 3;  /**< Selects the cacheline index with which the dataword is to be corrupted. */
 	uint64_t reserved_6_7                 : 2;
 	uint64_t ca_parity_corrupt_ena        : 1;  /**< Enables the CA parity bit corruption. */
 	uint64_t ca_parity_sel                : 5;  /**< Selects the type of DDR command to corrupt the parity bit.
@@ -7516,7 +7511,7 @@ union cvmx_lmcx_ext_config {
                                                          When set, MRS commands are directed to either the A or B
                                                          side of the RCD.
                                                          PDA operation is NOT allowed when this bit is set. In
-                                                         other words, MR_MPR_CTL[MR_WR_PDA_ENABLE]
+                                                         other words, [MR_WR_PDA_ENABLE]
                                                          must be cleared before running MRW sequence with this
                                                          bit turned on. */
 	uint64_t mrs_bside_invert_disable     : 1;  /**< When set, the command decoder cancels the auto inversion of
@@ -7526,14 +7521,14 @@ union cvmx_lmcx_ext_config {
                                                          RC00 DA[0] = 1 so that the output inversion is disabled in
                                                          the DDR4 RCD. */
 	uint64_t dimm_sel_invert_off          : 1;  /**< During coalesce_address_mode, the default logic would be to invert
-                                                         the pbank bit whenever NXM[MEM_MSB_D1_R0] > NXM[MEM_MSB_D0_R0].
-                                                         When this bit is set to 1, it disables this default behaviour.
+                                                         the pbank bit whenever [MEM_MSB_D1_R0] > [MEM_MSB_D0_R0].
+                                                         When this bit is set to one, it disables this default behavior.
                                                          This configuration has lower priority compared to
                                                          [DIMM_SEL_FORCE_INVERT]. */
-	uint64_t dimm_sel_force_invert        : 1;  /**< When set to 1, this bit forces the pbank bit to be inverted
-                                                         when in coalesce_address_mode. That is, pbank value of 0 selects
+	uint64_t dimm_sel_force_invert        : 1;  /**< When set to one, this bit forces the pbank bit to be inverted
+                                                         when in coalesce_address_mode. That is, pbank value of zero selects
                                                          DIMM1 instead of DIMM0.
-                                                         Intended to be use for the case of DIMM1 having bigger rank/s
+                                                         Intended to be used for the case of DIMM1 having bigger rank/s
                                                          than DIMM0. This bit has priority over [DIMM_SEL_INVERT_OFF]. */
 	uint64_t coalesce_address_mode        : 1;  /**< When set to 1, LMC coalesces the L2C+LMC internal address mapping
                                                          to create a uniform memory space that are free from holes in
@@ -7541,10 +7536,10 @@ union cvmx_lmcx_ext_config {
                                                          the higher capacity is mapped to the lower address space. */
 	uint64_t dimm1_cid                    : 2;  /**< Reserved. */
 	uint64_t dimm0_cid                    : 2;  /**< Reserved. */
-	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
-                                                         RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
-                                                         To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
-                                                         DA0 = 1. */
+	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to one
+                                                         when using DDR4 RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set
+                                                         this to zero otherwise. To enable the parity checking in RCD, set this bit first
+                                                         BEFORE issuing the RCW write RC0E DA0 = 1. */
 	uint64_t reserved_46_47               : 2;
 	uint64_t error_alert_n_sample         : 1;  /**< Read to get a sample of the DDR*_ERROR_ALERT_L signal. */
 	uint64_t ea_int_polarity              : 1;  /**< Set to invert DDR*_ERROR_ALERT_L interrupt polarity. When clear, interrupt is signaled on
@@ -7565,7 +7560,7 @@ union cvmx_lmcx_ext_config {
                                                          If this bit is clear, select operation where signals other than CS are active before and
                                                          after the CS_N active cycle.
                                                          When this bit is set, select the operation where the other command signals (DDR*_RAS_L,
-                                                         DDR*_CAS_L, DDR*_WE_L, DDR*_A<15:0>, etc) all are active only during the cycle where the
+                                                         DDR*_CAS_L, DDR*_WE_L, DDR*_A<15:0>, etc.) all are active only during the cycle where the
                                                          CS_N is also active. */
 	uint64_t reserved_33_35               : 3;
 	uint64_t invert_data                  : 1;  /**< Set this bit to cause all data to be inverted before writing or reading to/from DRAM. This
@@ -7602,8 +7597,13 @@ union cvmx_lmcx_ext_config {
 	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. */
 	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. */
 	uint64_t dlc_nxm_rd                   : 1;  /**< Reserved. */
-	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. */
-	uint64_t l2c_nxm_wr                   : 1;  /**< When set, enable NXM events for L2C write operations. */
+	uint64_t l2c_nxm_rd                   : 1;  /**< When set, corresponding LMC()_INT[NXM_WR_ERR] will be set and LMC()_NXM_FADR will be
+                                                         loaded for L2C NXM read operations. NXM read operations may occur during normal operation
+                                                         (due to prefetches), so [L2C_NXM_RD] should not be set during normal operation to allow
+                                                         LMC()_INT[NXM_WR_ERR] to indicate NXM writes. */
+	uint64_t l2c_nxm_wr                   : 1;  /**< When set, corresponding LMC()_INT[NXM_WR_ERR] will be set and LMC()_NXM_FADR will be
+                                                         loaded for L2C NXM write operations. NXM writes are generally an indication of
+                                                         failure, so [L2C_NXM_WR] can generally be set. */
 #else
 	uint64_t l2c_nxm_wr                   : 1;
 	uint64_t l2c_nxm_rd                   : 1;
@@ -7861,7 +7861,7 @@ union cvmx_lmcx_ext_config2 {
 	uint64_t delay_unload_r0              : 1;  /**< Reserved, MBZ. */
 	uint64_t early_dqx2                   : 1;  /**< Similar to LMC()_CONFIG[EARLY_DQX]. This field provides an additional setting to send DQx
                                                          signals one more CK cycle earlier on top of LMC()_CONFIG[EARLY_DQX]. */
-	uint64_t xor_bank_sel                 : 4;  /**< When LMC()_CONTROL[XOR_BANK] is set to 1, this field selects which
+	uint64_t xor_bank_sel                 : 4;  /**< When LMC()_CONTROL[XOR_BANK] is set to one, this field selects which
                                                           L2C-LMC address bits are used to XOR the bank bits with.
                                                           The address selection is as follows:
                                                          - 0:  bank<3:0> = address<10:7> ^ address<15:12>
@@ -7885,7 +7885,7 @@ union cvmx_lmcx_ext_config2 {
                                                          address (bit 5 in 32-bit mode) becomes the low order DDR ROW address bit.
                                                          The upper DDR COLUMN address portion is selected using LMC()_CONFIG[ROW_LSB]
                                                          (and LMC()_DUAL_MEMCFG[ROW_LSB] for dual-memory configuration).
-                                                         It is recommended to set this bit to 1 when TRR_ON is set. */
+                                                         It is recommended to set this bit to one when TRR_ON is set. */
 	uint64_t trr_on                       : 1;  /**< When set, this enables row activates counts of the
                                                          DRAM used in target row refresh mode. This bit can
                                                          be safely set after the LMC()_EXT_CONFIG2[MACRAM_SCRUB_DONE]
@@ -7975,7 +7975,7 @@ union cvmx_lmcx_ext_config2 {
 	uint64_t delay_unload_r0              : 1;  /**< Reserved, MBZ. */
 	uint64_t early_dqx2                   : 1;  /**< Similar to LMC()_CONFIG[EARLY_DQX]. This field provides an additional setting to send DQx
                                                          signals one more CK cycle earlier on top of LMC()_CONFIG[EARLY_DQX]. */
-	uint64_t xor_bank_sel                 : 4;  /**< When LMC()_CONTROL[XOR_BANK] is set to 1, this field selects which
+	uint64_t xor_bank_sel                 : 4;  /**< When LMC()_CONTROL[XOR_BANK] is set to one, this field selects which
                                                           L2C-LMC address bits are used to XOR the bank bits with.
                                                           The address selection is as follows:
                                                          - 0:  bank<3:0> = address<10:7> ^ address<15:12>
@@ -7999,7 +7999,7 @@ union cvmx_lmcx_ext_config2 {
                                                          address (bit 5 in 32-bit mode) becomes the low order DDR ROW address bit.
                                                          The upper DDR COLUMN address portion is selected using LMC()_CONFIG[ROW_LSB]
                                                          (and LMC()_DUAL_MEMCFG[ROW_LSB] for dual-memory configuration).
-                                                         It is recommended to set this bit to 1 when TRR_ON is set. */
+                                                         It is recommended to set this bit to one when TRR_ON is set. */
 	uint64_t trr_on                       : 1;  /**< When set, this enables row activates counts of the
                                                          DRAM used in target row refresh mode. This bit can
                                                          be safely set after the LMC()_EXT_CONFIG2[MACRAM_SCRUB_DONE]
@@ -8346,35 +8346,71 @@ union cvmx_lmcx_int {
 	struct cvmx_lmcx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t macram_ded_err               : 1;  /**< MAC RAM ECC double error detect (DED). */
-	uint64_t macram_sec_err               : 1;  /**< MAC RAM ECC single error correct (SEC). */
-	uint64_t ddr_err                      : 1;  /**< DDR RAM error alert interrupt. */
+	uint64_t macram_ded_err               : 1;  /**< Reserved. */
+	uint64_t macram_sec_err               : 1;  /**< Reserved. */
+	uint64_t ddr_err                      : 1;  /**< DDR RAM error alert interrupt.
+                                                         Asserts whenever the corresponding DDR*_ERROR_ALERT_L pin (e.g. DDR4 ALERT_n)
+                                                         asserts.
+                                                         If LMC is auto-retrying address parity and/or write CRC errors, i.e. if
+                                                         LMC()_RETRY_CONFIG[RETRY_ENABLE,AUTO_ERROR_CONTINUE]=1,1
+                                                         (LMC()_MODEREG_PARAMS3[CA_PAR_PERS] should also be set - the DRAM should
+                                                         be in persistent parity error mode), then the DDR_ERR interrupt routine
+                                                         should:
+                                                           <pre>
+                                                           X=LMC()_RETRY_STATUS[ERROR_COUNT]
+                                                           do [
+                                                           Y = X
+                                                           Wait approximately 100ns
+                                                           Write a one to [DDR_ERR] to clear it (if set)
+                                                           X = LMC()_RETRY_STATUS[ERROR_COUNT]
+                                                           ] while (X != Y);
+                                                           Write LMC()_RETRY_STATUS[CLEAR_ERROR_COUNT]=1 (to clear
+                                                           LMC()_RETRY_STATUS[ERROR_COUNT])
+                                                           </pre>
+                                                         If X < LMC()_RETRY_CONFIG[MAX_ERRORS] after this sequence, assume that
+                                                         the hardware successfully corrected the error - software may
+                                                         choose to count the number of these errors. Else consider the error
+                                                         to be uncorrected and possibly fatal.
+                                                         Otherwise, if LMC is not auto-retrying, a [DDR_ERR] error may always be
+                                                         considered fatal. */
 	uint64_t dlcram_ded_err               : 1;  /**< DLC RAM ECC double error detect (DED). */
 	uint64_t dlcram_sec_err               : 1;  /**< DLC RAM ECC single error correct (SEC). */
-	uint64_t ded_err                      : 4;  /**< Double error detected (DED) of Rd Data.
+	uint64_t ded_err                      : 4;  /**< Double-bit error detected on a DRAM read. Generally an indication of DRAM
+                                                         corruption and may be considered fatal.
                                                          In 64b mode:
-                                                         _ <5> corresponds to DQ[63:0]_c0_p0
-                                                         _ <6> corresponds to DQ[63:0]_c0_p1
-                                                         _ <7> corresponds to DQ[63:0]_c1_p0
-                                                         _ <8> corresponds to DQ[63:0]_c1_p1
+                                                         _ <5> corresponds to DQ[63:0]_c0_p0.
+                                                         _ <6> corresponds to DQ[63:0]_c0_p1.
+                                                         _ <7> corresponds to DQ[63:0]_c1_p0.
+                                                         _ <8> corresponds to DQ[63:0]_c1_p1.
                                                          _ where _cC_pP denotes cycle C and phase P.
                                                          In 32b mode, each bit corresponds to 2 phases:
-                                                         _ <5> corresponds to DQ[31:0]_c0_p1/0
-                                                         _ <6> corresponds to DQ[31:0]_c1_p1/0
-                                                         _ <7> corresponds to DQ[31:0]_c2_p1/0
-                                                         _ <8> corresponds to DQ[31:0]_c3_p1/0 */
-	uint64_t sec_err                      : 4;  /**< Single error (corrected) of Rd Data.
-                                                         _ <1> corresponds to DQ[63:0]_c0_p0
-                                                         _ <2> corresponds to DQ[63:0]_c0_p1
-                                                         _ <3> corresponds to DQ[63:0]_c1_p0
-                                                         _ <4> corresponds to DQ[63:0]_c1_p1
+                                                         _ <5> corresponds to DQ[31:0]_c0_p1/0.
+                                                         _ <6> corresponds to DQ[31:0]_c1_p1/0.
+                                                         _ <7> corresponds to DQ[31:0]_c2_p1/0.
+                                                         _ <8> corresponds to DQ[31:0]_c3_p1/0. */
+	uint64_t sec_err                      : 4;  /**< Single-bit error detected on a DRAM read.
+                                                         When any of [SEC_ERR<3:0>] are set, hardware corrected the error before using the value,
+                                                         but did not correct any stored value. When any of [SEC_ERR<3:0>] are set, software should
+                                                         scrub the memory location whose address is in LMC()_SCRAMBLED_FADR before clearing the
+                                                         [SEC_ERR<3:0>] bits. Otherwise, hardware may encounter the error again the next time the
+                                                         same memory location is referenced. We recommend that the entire 128-byte cache block be
+                                                         scrubbed via load-exclusive/store-release instructions, but other methods are possible.
+                                                         Software may also choose to count the number of these single-bit errors.
+                                                         In 64b mode:
+                                                         _ <1> corresponds to DQ[63:0]_c0_p0.
+                                                         _ <2> corresponds to DQ[63:0]_c0_p1.
+                                                         _ <3> corresponds to DQ[63:0]_c1_p0.
+                                                         _ <4> corresponds to DQ[63:0]_c1_p1.
                                                          _ where _cC_pP denotes cycle C and phase P.
                                                          In 32b mode, each bit corresponds to 2 phases:
-                                                         <5> corresponds to DQ[31:0]_c0_p1/0
-                                                         <6> corresponds to DQ[31:0]_c1_p1/0
-                                                         <7> corresponds to DQ[31:0]_c2_p1/0
-                                                         <8> corresponds to DQ[31:0]_c3_p1/0 */
-	uint64_t nxm_wr_err                   : 1;  /**< Write to nonexistent memory. */
+                                                         _ <1> corresponds to DQ[31:0]_c0_p1/0.
+                                                         _ <2> corresponds to DQ[31:0]_c1_p1/0.
+                                                         _ <3> corresponds to DQ[31:0]_c2_p1/0.
+                                                         _ <4> corresponds to DQ[31:0]_c3_p1/0. */
+	uint64_t nxm_wr_err                   : 1;  /**< When set, indicates an access to nonexistent memory. Normally only NXM writes,
+                                                         but LMC()_EXT_CONFIG[L2C_NXM_RD,L2C_NXM_WR] actually determine whether NXM reads and
+                                                         writes (respectively) participate in [NXM_WR_ERR]. NXM writes are generally an indication
+                                                         of failure. When [LMC()_NXM_FADR] is set, LMC()_NXM_FADR indicates the NXM address. */
 #else
 	uint64_t nxm_wr_err                   : 1;
 	uint64_t sec_err                      : 4;
@@ -9377,10 +9413,10 @@ union cvmx_lmcx_modereg_params1 {
 	struct cvmx_lmcx_modereg_params1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_55_63               : 9;
-	uint64_t rtt_wr_11_ext                : 1;  /**< RTT_WR rank 3 extension bit for DDR4. */
-	uint64_t rtt_wr_10_ext                : 1;  /**< RTT_WR rank 2 extension bit for DDR4. */
-	uint64_t rtt_wr_01_ext                : 1;  /**< RTT_WR rank 1 extension bit for DDR4. */
-	uint64_t rtt_wr_00_ext                : 1;  /**< RTT_WR rank 0 extension bit for DDR4. */
+	uint64_t rtt_wr_11_ext                : 1;  /**< RTT_WR rank 3 extension bit for DDR4; effectively [RTT_WR_11]<2>. */
+	uint64_t rtt_wr_10_ext                : 1;  /**< RTT_WR rank 2 extension bit for DDR4; effectively [RTT_WR_10]<2>. */
+	uint64_t rtt_wr_01_ext                : 1;  /**< RTT_WR rank 1 extension bit for DDR4; effectively [RTT_WR_01]<2>. */
+	uint64_t rtt_wr_00_ext                : 1;  /**< RTT_WR rank 0 extension bit for DDR4; effectively [RTT_WR_00]<2>. */
 	uint64_t db_output_impedance          : 3;  /**< Reserved. */
 	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM rank 3. LMC writes this value to MR1[RTT_NOM] in the rank 3 (i.e. DIMM1_CS1) DDR3
                                                          parts when selected during power-up/init, write-leveling, and, if
@@ -9970,8 +10006,8 @@ union cvmx_lmcx_mpr_data0 {
 	uint64_t u64;
 	struct cvmx_lmcx_mpr_data0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t mpr_data                     : 64; /**< MPR data bits<63:0>. Bits<7:0> represent the MPR data for the lowest-order *4 device (*4
-                                                         device 0); bits<15:8> represent *4 device 1; ..., bits<63:56> are for *4 device 7.
+	uint64_t mpr_data                     : 64; /**< MPR data bits<63:0>. Bits<7:0> represent the MPR data for the lowest-order x4 device (x4
+                                                         device 0); bits<15:8> represent x4 device 1; ..., bits<63:56> are for x4 device 7.
                                                          This field is also used to store the results after running the general R/W training
                                                          sequence (LMC()_SEQ_CTL[SEQ_SEL] = 0xE).
                                                          The format of the stored results is controlled by LMC()_DBTRAIN_CTL[RW_TRAIN].
@@ -10002,8 +10038,8 @@ union cvmx_lmcx_mpr_data1 {
 	uint64_t u64;
 	struct cvmx_lmcx_mpr_data1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t mpr_data                     : 64; /**< MPR data bits<127:64>. Bits<7:0> represent the MPR data for *4 device 8; bits<15:8>
-                                                         represent *4 device 9; ...; bits<63:56> are for *4 device 15.
+	uint64_t mpr_data                     : 64; /**< MPR data bits<127:64>. Bits<7:0> represent the MPR data for x4 device 8; bits<15:8>
+                                                         represent x4 device 9; ...; bits<63:56> are for x4 device 15.
                                                          This field is also used to store the results after running the general R/W training
                                                          sequence (LMC()_SEQ_CTL[SEQ_SEL] = 0xE).
                                                          The format of the stored results is controlled by LMC()_DBTRAIN_CTL[RW_TRAIN].
@@ -10036,8 +10072,8 @@ union cvmx_lmcx_mpr_data2 {
 	struct cvmx_lmcx_mpr_data2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t mpr_data                     : 16; /**< MPR data bits<143:128>. Bits<7:0> represent the MPR data for *4 device 16; bits<15:8>
-                                                         represent *4 device 17.
+	uint64_t mpr_data                     : 16; /**< MPR data bits<143:128>. Bits<7:0> represent the MPR data for x4 device 16; bits<15:8>
+                                                         represent x4 device 17.
                                                          This field is also used to store the results after running the general R/W training
                                                          sequence (LMC()_SEQ_CTL[SEQ_SEL] = 0xE).
                                                          The format of the stored results is controlled by LMC()_DBTRAIN_CTL[RW_TRAIN].
@@ -10072,7 +10108,7 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t mr_wr_secure_key_ena         : 1;  /**< When set, this enables the issuing of security key with the
                                                          unique address field A[17:0] set by LMC()_MR_MPR_CTL[MR_WR_ADDR]
                                                          during the MRW sequence.
-                                                         Set this to 1 when executing DRAM post package repair manually
+                                                         Set this to one when executing DRAM post package repair manually
                                                          by using MRW operation. */
 	uint64_t pba_func_space               : 3;  /**< Set the function space selector during PBA mode of the MRW
                                                          sequence. */
@@ -10087,25 +10123,25 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. */
 	uint64_t mpr_byte_select              : 4;  /**< Reserved. */
 	uint64_t mpr_bit_select               : 2;  /**< Select which of four bits to read for each nibble of DRAM data. Typically all four bits
-                                                         from a *4 device, or all eight bits from a *8 device, or all 16 bits from a *16 device
+                                                         from a x4 device, or all eight bits from a x8 device, or all 16 bits from a x16 device
                                                          carry the same data, but this field allows selection of which device bit will be used to
                                                          read the MPR data. */
 	uint64_t mpr_wr                       : 1;  /**< MPR sequence will perform a write operation when set. */
 	uint64_t mpr_loc                      : 2;  /**< MPR location select for MPR sequence. Only makes a difference for DDR4. */
 	uint64_t mr_wr_pda_enable             : 1;  /**< PDA write enable. When set, MRW operations use PDA, enabled by MR_WR_PDA_MASK per device.
                                                          Only available for DDR4 devices. */
-	uint64_t mr_wr_pda_mask               : 18; /**< PDA mask. If MR_WR_PDA_ENABLE = 1 and there is a 1 in the bit for this mask value, then
+	uint64_t mr_wr_pda_mask               : 18; /**< PDA mask. If MR_WR_PDA_ENABLE = 1 and there is a one in the bit for this mask value, then
                                                          the corresponding DRAM device is enabled for the PDA MR write operation.
-                                                         Bit<23> corresponds to the lowest order, *4 device, and bit<40> corresponds to the highest
-                                                         order *4 device, for a total of up to 18 devices. */
+                                                         Bit<23> corresponds to the lowest order, x4 device, and bit<40> corresponds to the highest
+                                                         order x4 device, for a total of up to 18 devices. */
 	uint64_t mr_wr_rank                   : 2;  /**< Selects the DRAM rank for either MRW or MPR sequences. */
 	uint64_t mr_wr_sel                    : 3;  /**< Selects which MR to write with the MR write sequence.
                                                          Which pins to drive and how to drive them is automatically controlled through the DDR3/4
                                                          mode setting. Bits<19:18> are also used to select the MPR page for an MPR sequence.
                                                          A value of 0x7 selects an RCW write for both DDR4 and DDR3 MRW operations. */
-	uint64_t mr_wr_addr                   : 18; /**< Sets a value for A<17:0> for MR write operations. Note that many of these bits must be 0
-                                                         for various MRs. Bits<7:0> are also used for write data on an MPR sequence write
-                                                         operation. */
+	uint64_t mr_wr_addr                   : 18; /**< Sets a value for A<17:0> for MR write operations. Note that many of these bits
+                                                         must be zero for various MRs. Bits<7:0> are also used for write data on an MPR
+                                                         sequence write operation. */
 #else
 	uint64_t mr_wr_addr                   : 18;
 	uint64_t mr_wr_sel                    : 3;
@@ -10188,8 +10224,8 @@ union cvmx_lmcx_ns_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
 	uint64_t ns_scramble_dis              : 1;  /**< When set, this field disables data scrambling on nonsecure accesses only.
-                                                         When data scrambling is enabled by setting CONTROL[SCRAMBLE_ENA] to 1, this
-                                                         field needs to be cleared to 0 in order to enable data scrambling on
+                                                         When data scrambling is enabled by setting CONTROL[SCRAMBLE_ENA] to one, this
+                                                         field needs to be cleared to zero in order to enable data scrambling on
                                                          nonsecure mode. */
 	uint64_t reserved_18_24               : 7;
 	uint64_t adr_offset                   : 18; /**< Sets the offset to the upper 18 bits of L2C-LMC address when a nonsecure mode
@@ -10335,18 +10371,18 @@ typedef union cvmx_lmcx_nxm cvmx_lmcx_nxm_t;
 /**
  * cvmx_lmc#_nxm_fadr
  *
- * This register captures only the first transaction with a NXM error while an interrupt is
- * pending, and only captures a subsequent event once the interrupt is cleared by writing a 1 to
- * LMC()_INT[NXM_ERR]. It captures the actual L2C-LMC address provided to the LMC that caused
- * the NXM error. A read or write NXM error is captured only if enabled using the NXM event
- * enables.
+ * This register captures only the first transaction with a NXM error while an
+ * interrupt is pending, and only captures a subsequent event once the interrupt is
+ * cleared by writing a one to LMC()_INT[NXM_ERR]. It captures the actual L2C-LMC
+ * address provided to the LMC that caused the NXM error. A read or write NXM error is
+ * captured only if enabled using the NXM event enables.
  */
 union cvmx_lmcx_nxm_fadr {
 	uint64_t u64;
 	struct cvmx_lmcx_nxm_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
-	uint64_t nxm_faddr_ext                : 1;  /**< Extended bit for the Failing L2C-LMC address (bit 37). */
+	uint64_t nxm_faddr_ext                : 1;  /**< Extended bit for the failing L2C-LMC address (bit 37). */
 	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
                                                          0 = L2C.
                                                          1 = Reserved. */
@@ -11096,7 +11132,7 @@ union cvmx_lmcx_ppr_ctl {
 	uint64_t lrank_sel                    : 3;  /**< Selects which logical rank to perform the post package repair sequence.
                                                          Package ranks are selected by LMC()_MR_MPR_CTL[MR_WR_RANK]. */
 	uint64_t skip_issue_security          : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to skip
-                                                         issuing four consecutive MR0 commands that suppliy the security key. */
+                                                         issuing four consecutive MR0 commands that supply the security key. */
 	uint64_t sppr                         : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to run
                                                          the soft PPR mode. */
 	uint64_t tpgm                         : 10; /**< Indicates the programming time (tPGM) constraint used when running PPR sequence.
@@ -11106,7 +11142,7 @@ union cvmx_lmcx_ppr_ctl {
                                                          RNDUP[TPGM(ns) / TCYC(ns))].
                                                          [TPGM] is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not data
                                                          rate). */
-	uint64_t tpgm_exit                    : 5;  /**< Indicates PPR exit time (tPGM_Exit) contrainst used when running PPR sequence.
+	uint64_t tpgm_exit                    : 5;  /**< Indicates PPR exit time (tPGM_Exit) constraint used when running PPR sequence.
                                                          Set this field as follows:
                                                          _ RNDUP[TPGM_EXIT(ns) / TCYC(ns)]
                                                          where [TPGM_EXIT] is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency
@@ -11141,7 +11177,7 @@ union cvmx_lmcx_ppr_ctl {
                                                          RNDUP[TPGM(ns) / TCYC(ns))].
                                                          [TPGM] is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not data
                                                          rate). */
-	uint64_t tpgm_exit                    : 5;  /**< Indicates PPR exit time (tPGM_Exit) contrainst used when running PPR sequence.
+	uint64_t tpgm_exit                    : 5;  /**< Indicates PPR exit time (tPGM_Exit) constraint used when running PPR sequence.
                                                          Set this field as follows:
                                                          _ RNDUP[TPGM_EXIT(ns) / TCYC(ns)]
                                                          where [TPGM_EXIT] is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency
@@ -11307,7 +11343,8 @@ union cvmx_lmcx_ref_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t ref_pend_max_clr             : 1;  /**< Indicates that the number of pending refreshes has reached 7, requiring
-                                                         software to clear the flag by setting this field to 1. */
+                                                         software to clear the flag by setting this field to 1.
+                                                         This is only useful when LMC()_EXT_CONFIG[REF_BLOCK] mode is engaged. */
 	uint64_t ref_count                    : 3;  /**< Reads back the number of pending refreshes that LMC has yet to execute. */
 #else
 	uint64_t ref_count                    : 3;
@@ -11410,14 +11447,14 @@ union cvmx_lmcx_retry_config {
 	uint64_t max_errors                   : 24; /**< Maximum number of errors before errors are ignored. */
 	uint64_t reserved_13_31               : 19;
 	uint64_t error_continue               : 1;  /**< If LMC()_RETRY_CONFIG[AUTO_ERROR_CONTINUE] is cleared, LMC will wait
-                                                         for a 1 to be written to LMC()_RETRY_CONFIG[ERROR_CONTINUE] before
+                                                         for a one to be written to LMC()_RETRY_CONFIG[ERROR_CONTINUE] before
                                                          continuing operations after an error. */
 	uint64_t reserved_9_11                : 3;
 	uint64_t auto_error_continue          : 1;  /**< When set, LMC will automatically proceed with error handling and normal
                                                          operation after an error occurs.  If clear, LMC will cease all operations
                                                          except for refresh as soon as possible, and will not continue with error
                                                          handling or normal operation until LMC()_RETRY_CONFIG[ERROR_CONTINUE]
-                                                         is written with a 1. */
+                                                         is written with a one. */
 	uint64_t reserved_5_7                 : 3;
 	uint64_t pulse_count_auto_clr         : 1;  /**< When set, LMC()_RETRY_STATUS[ERROR_PULSE_COUNT_VALID] will clear
                                                          whenever the error interrupt is cleared. */
@@ -11456,14 +11493,14 @@ union cvmx_lmcx_retry_status {
 	uint64_t clear_error_pulse_count      : 1;  /**< Clear the error count, one shot operation. */
 	uint64_t reserved_57_61               : 5;
 	uint64_t error_pulse_count_valid      : 1;  /**< When set and the count is valid, indicates that the counter has saturated,
-                                                         which effectively indicates that a command error has occured and not a CRC
+                                                         which effectively indicates that a command error has occurred and not a CRC
                                                          error. */
 	uint64_t error_pulse_count_sat        : 1;  /**< When set and the count is valid, indicates that the counter has saturated,
-                                                         which effectively indicates that a command error has occured and not a CRC
+                                                         which effectively indicates that a command error has occurred and not a CRC
                                                          error. */
 	uint64_t reserved_52_54               : 3;
 	uint64_t error_pulse_count            : 4;  /**< Count of cycles in last error pulse since clear.  This count will be cleared
-                                                         either by clearing the interrupt or writing a 1 to the pulse count clear bit. */
+                                                         either by clearing the interrupt or writing a one to the pulse count clear bit. */
 	uint64_t reserved_45_47               : 3;
 	uint64_t error_sequence               : 5;  /**< Sequence number for sequence that was running when error occurred. */
 	uint64_t reserved_33_39               : 7;
@@ -11507,17 +11544,17 @@ union cvmx_lmcx_rlevel_ctl {
 	uint64_t tccd_sel                     : 1;  /**< When set, the read leveling sequence uses MODEREG_PARAMS3[TCCD_L] to
                                                          space out back-to-back read commands. Otherwise the back-to-back
                                                          reads commands are spaced out by a default 4 cycles. */
-	uint64_t pattern                      : 8;  /**< Sets the data pattern used to match in read-leveling operations. */
+	uint64_t pattern                      : 8;  /**< Sets the data pattern used to match in read leveling operations. */
 	uint64_t reserved_22_23               : 2;
 	uint64_t delay_unload_3               : 1;  /**< Reserved, must be set. */
 	uint64_t delay_unload_2               : 1;  /**< Reserved, must be set. */
 	uint64_t delay_unload_1               : 1;  /**< Reserved, must be set. */
 	uint64_t delay_unload_0               : 1;  /**< Reserved, must be set. */
-	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which read-leveling feedback is returned when [OR_DIS] is set to 1. */
-	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the read-leveling bitmask. [OR_DIS]
+	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which read leveling feedback is returned when [OR_DIS] is set to 1. */
+	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the read leveling bitmask. [OR_DIS]
                                                          should normally not be set. */
-	uint64_t offset_en                    : 1;  /**< When set, LMC attempts to select the read-leveling setting that is
-                                                         LMC()_RLEVEL_CTL[OFFSET] settings earlier than the last passing read-leveling setting
+	uint64_t offset_en                    : 1;  /**< When set, LMC attempts to select the read leveling setting that is
+                                                         LMC()_RLEVEL_CTL[OFFSET] settings earlier than the last passing read leveling setting
                                                          in the largest contiguous sequence of passing settings. When clear, or if the setting
                                                          selected by LMC()_RLEVEL_CTL[OFFSET] did not pass, LMC selects the middle setting in
                                                          the largest contiguous sequence of passing settings, rounding earlier when necessary. */
@@ -11660,12 +11697,12 @@ typedef union cvmx_lmcx_rlevel_ctl cvmx_lmcx_rlevel_ctl_t;
 /**
  * cvmx_lmc#_rlevel_dbg
  *
- * A given read of LMC()_RLEVEL_DBG returns the read-leveling pass/fail results for all
+ * A given read of LMC()_RLEVEL_DBG returns the read leveling pass/fail results for all
  * possible delay settings (i.e. the BITMASK) for only one byte in the last rank that
- * the hardware ran read-leveling on. LMC()_RLEVEL_CTL[BYTE] selects the particular
+ * the hardware ran read leveling on. LMC()_RLEVEL_CTL[BYTE] selects the particular
  * byte. To get these pass/fail results for a different rank, you must run the hardware
- * read-leveling again. For example, it is possible to get the [BITMASK] results for
- * every byte of every rank if you run read-leveling separately for each rank, probing
+ * read leveling again. For example, it is possible to get the [BITMASK] results for
+ * every byte of every rank if you run read leveling separately for each rank, probing
  * LMC()_RLEVEL_DBG between each read- leveling.
  */
 union cvmx_lmcx_rlevel_dbg {
@@ -11699,16 +11736,16 @@ typedef union cvmx_lmcx_rlevel_dbg cvmx_lmcx_rlevel_dbg_t;
  *
  * Four of these CSRs exist per LMC, one for each rank. Read level setting is measured
  * in units of 1/4 CK, so the BYTEn values can range over 16 CK cycles. Each CSR is
- * written by hardware during a read-leveling sequence for the rank. (Hardware sets
- * [STATUS] to 3 after hardware read-leveling completes for the rank.)
+ * written by hardware during a read leveling sequence for the rank. (Hardware sets
+ * [STATUS] to 3 after hardware read leveling completes for the rank.)
  *
  * If hardware is unable to find a match per LMC()_RLEVEL_CTL[OFFSET_EN] and
  * LMC()_RLEVEL_CTL[OFFSET], then hardware sets LMC()_RLEVEL_RANK()[BYTEn<5:0>] to
  * 0x0.
  *
- * Each CSR may also be written by software, but not while a read-leveling sequence is
+ * Each CSR may also be written by software, but not while a read leveling sequence is
  * in progress. (Hardware sets [STATUS] to 1 after a CSR write.) Software initiates a
- * hardware read-leveling sequence by programming LMC()_RLEVEL_CTL and writing
+ * hardware read leveling sequence by programming LMC()_RLEVEL_CTL and writing
  * [INIT_START] = 1 with [SEQ_SEL]=1. See LMC()_RLEVEL_CTL.
  *
  * LMC()_RLEVEL_RANKi values for ranks i without attached DRAM should be set such that
@@ -11721,12 +11758,12 @@ union cvmx_lmcx_rlevel_rankx {
 	struct cvmx_lmcx_rlevel_rankx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
-	uint64_t status                       : 2;  /**< Indicates status of the read-leveling and where the BYTEn programmings in <53:0> came
+	uint64_t status                       : 2;  /**< Indicates status of the read leveling and where the BYTEn programmings in <53:0> came
                                                          from:
                                                          0x0 = BYTEn values are their reset value.
                                                          0x1 = BYTEn values were set via a CSR write to this register.
-                                                         0x2 = read-leveling sequence currently in progress (BYTEn values are unpredictable).
-                                                         0x3 = BYTEn values came from a complete read-leveling sequence. */
+                                                         0x2 = Read leveling sequence currently in progress (BYTEn values are unpredictable).
+                                                         0x3 = BYTEn values came from a complete read leveling sequence. */
 	uint64_t byte8                        : 6;  /**< "Read level setting.
                                                          When ECC DRAM is not present in 64-bit mode (i.e. when DRAM is not attached to chip
                                                          signals DDR#_CBS_0_* and DDR#_CB<7:0>), software should write BYTE8 to a value that does
@@ -12153,9 +12190,8 @@ union cvmx_lmcx_seq_ctl {
 	struct cvmx_lmcx_seq_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t seq_complete                 : 1;  /**< Sequence complete. This bit is cleared when [INIT_START] is set to a 1 and then is set to
-                                                         1
-                                                         when the sequence is completed. */
+	uint64_t seq_complete                 : 1;  /**< Sequence complete. This bit is cleared when [INIT_START] is set to a one and
+                                                         then is set to one when the sequence is completed. */
 	uint64_t seq_sel                      : 4;  /**< Selects the sequence that LMC runs after a 0->1 transition on [INIT_START], as
                                                          enumerated by LMC_SEQ_SEL_E.
                                                          LMC writes the LMC()_MODEREG_PARAMS0 and LMC()_MODEREG_PARAMS1 CSR field values
@@ -12209,7 +12245,7 @@ union cvmx_lmcx_slot_ctl0 {
 	struct cvmx_lmcx_slot_ctl0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
-	uint64_t w2r_l_init_ext               : 1;  /**< A 1-bit extenstion to the [W2R_L_INIT] register. */
+	uint64_t w2r_l_init_ext               : 1;  /**< A 1-bit extension to the [W2R_L_INIT] register. */
 	uint64_t w2r_init_ext                 : 1;  /**< A 1-bit extension to the [W2R_INIT] register. */
 	uint64_t w2w_l_init                   : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
                                                          accesses to the same rank and DIMM, and same BG for DDR4. */
@@ -12452,8 +12488,8 @@ union cvmx_lmcx_slot_ctl3 {
 	struct cvmx_lmcx_slot_ctl3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
-	uint64_t w2r_l_xrank_init_ext         : 1;  /**< A 1-bit extension to the [W2R_L_XRANK_INIT] register. */
-	uint64_t w2r_xrank_init_ext           : 1;  /**< A 1-bit extension to the [W2R_XRANK_INIT] register. */
+	uint64_t w2r_l_xrank_init_ext         : 1;  /**< A 1-bit extension to [W2R_L_XRANK_INIT]; effectively [W2R_L_XRANK_INIT]<6>. */
+	uint64_t w2r_xrank_init_ext           : 1;  /**< A 1-bit extension to the [W2R_XRANK_INIT]; effectively [W2R_XRANK_INIT]<6>. */
 	uint64_t w2w_l_xrank_init             : 6;  /**< Write-to-write spacing control for back-to-back write followed by write cache block
                                                          accesses to a different logical rank, and same BG for DDR4. */
 	uint64_t w2r_l_xrank_init             : 6;  /**< Write-to-read spacing control for back-to-back write followed by read cache block accesses
@@ -12822,15 +12858,15 @@ union cvmx_lmcx_timing_params1 {
 	struct cvmx_lmcx_timing_params1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
-	uint64_t txp_ext                      : 1;  /**< A 1-bit extension to the TXP register. */
-	uint64_t trcd_ext                     : 1;  /**< A 1-bit extension to the TRCD register. */
+	uint64_t txp_ext                      : 1;  /**< A 1-bit MSB extension to [TXP], effectively [TXP]<3>. */
+	uint64_t trcd_ext                     : 1;  /**< A 1-bit MSB extension to [TRCD], effectively [TRCD]<4>. */
 	uint64_t tpdm_full_cycle_ena          : 1;  /**< When set, this field enables the addition of a one cycle delay to the
                                                          write/read latency calculation. This is to compensate the case when
                                                          tPDM delay in the RCD of an RDIMM is greater than one-cycle.
                                                          Only valid in RDIMM  (LMC()_CTL[RDIMM_ENA]=1). */
 	uint64_t trfc_dlr                     : 7;  /**< Indicates TRFC_DLR constraints. Set this field as follows:
                                                          _ RNDUP[TRFC_DLR(ns) / (8 * TCYC(ns))]
-                                                         where TRFC_DLR is from the JEDEC 3D Stacked SDRAM spec, and TCYC(ns) is the DDR clock
+                                                         where TRFC_DLR is from the JEDEC 3D stacked SDRAM spec, and TCYC(ns) is the DDR clock
                                                          frequency (not data rate).
                                                          TYP = 90-120 ns.
                                                          0x0 = reserved.
@@ -13188,8 +13224,8 @@ union cvmx_lmcx_timing_params1 {
 	struct cvmx_lmcx_timing_params1_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_59_63               : 5;
-	uint64_t txp_ext                      : 1;  /**< A 1-bit extension to the TXP register. */
-	uint64_t trcd_ext                     : 1;  /**< A 1-bit extension to the TRCD register. */
+	uint64_t txp_ext                      : 1;  /**< A 1-bit MSB extension to [TXP], effectively [TXP]<3>. */
+	uint64_t trcd_ext                     : 1;  /**< A 1-bit MSB extension to [TRCD], effectively [TRCD]<4>. */
 	uint64_t tpdm_full_cycle_ena          : 1;  /**< When set, this field enables the addition of a one cycle delay to the
                                                          write/read latency calculation. This is to compensate the case when
                                                          tPDM delay in the RCD of an RDIMM is greater than one-cycle.
@@ -13331,9 +13367,9 @@ union cvmx_lmcx_timing_params2 {
 	struct cvmx_lmcx_timing_params2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t trrd_l_ext                   : 1;  /**< MSB of TWTR_L constraints. Set this field
+	uint64_t trrd_l_ext                   : 1;  /**< Extends [TWTR_L] constraints, effectively [TWTR_L]<4>. Set this field
                                                          when requiring tRRD_L of more than 9 nCK. Otherwise
-                                                         this bit must be 0. */
+                                                         this bit must be zero. */
 	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
                                                          _ RNDUP[TRTP(ns) / TCYC(ns)] - 1,
                                                          For DDR3, typical = max(4 nCK, 7.5ns).
@@ -13490,12 +13526,12 @@ union cvmx_lmcx_wlevel_ctl {
                                                          0x5 = LMC writes 0x6 (Rsvd) to MR1[Rtt_Nom].
                                                          0x6 = LMC writes 0x7 (Rsvd) to MR1[Rtt_Nom].
                                                          0x7 = LMC writes 0x0 (Disabled) to MR1[Rtt_Nom]. */
-	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which write-leveling feedback is returned when OR_DIS is set to 1. */
-	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the write-leveling bitmask. */
-	uint64_t sset                         : 1;  /**< Run write-leveling on the current setting only. */
-	uint64_t lanemask                     : 9;  /**< One-shot mask to select byte lane to be leveled by the write-leveling sequence. Used with
-                                                         *16 parts where the upper and lower byte lanes need to be leveled independently.
-                                                         This field is also used for byte lane masking during read-leveling sequence. */
+	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which write leveling feedback is returned when OR_DIS is set to one. */
+	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the write leveling bitmask. */
+	uint64_t sset                         : 1;  /**< Run write leveling on the current setting only. */
+	uint64_t lanemask                     : 9;  /**< One-shot mask to select byte lane to be leveled by the write leveling sequence. Used with
+                                                         x16 parts where the upper and lower byte lanes need to be leveled independently.
+                                                         This field is also used for byte lane masking during read leveling sequence. */
 #else
 	uint64_t lanemask                     : 9;
 	uint64_t sset                         : 1;
@@ -13537,12 +13573,12 @@ typedef union cvmx_lmcx_wlevel_ctl cvmx_lmcx_wlevel_ctl_t;
 /**
  * cvmx_lmc#_wlevel_dbg
  *
- * A given write of LMC()_WLEVEL_DBG returns the write-leveling pass/fail results for all
+ * A given write of LMC()_WLEVEL_DBG returns the write leveling pass/fail results for all
  * possible delay settings (i.e. the BITMASK) for only one byte in the last rank that the
- * hardware write-leveled. LMC()_WLEVEL_DBG[BYTE] selects the particular byte. To get these
- * pass/fail results for a different rank, you must run the hardware write-leveling again. For
+ * hardware write leveled. LMC()_WLEVEL_DBG[BYTE] selects the particular byte. To get these
+ * pass/fail results for a different rank, you must run the hardware write leveling again. For
  * example, it is possible to get the [BITMASK] results for every byte of every rank if you run
- * write-leveling separately for each rank, probing LMC()_WLEVEL_DBG between each write-
+ * write leveling separately for each rank, probing LMC()_WLEVEL_DBG between each write-
  * leveling.
  */
 union cvmx_lmcx_wlevel_dbg {
@@ -13556,7 +13592,7 @@ union cvmx_lmcx_wlevel_dbg {
                                                          passed for
                                                          0 <= n <= 7. [BITMASK] contains the first 8 results of the total 16 collected by LMC
                                                          during
-                                                         the write-leveling sequence.
+                                                         the write leveling sequence.
                                                          If LMC()_WLEVEL_CTL[SSET]=1, [BITMASK]<0>=0 means curr write level setting failed;
                                                          [BITMASK]<0>=1 means curr write level setting passed. */
 	uint64_t byte                         : 4;  /**< 0 <= BYTE <= 8. */
@@ -13587,12 +13623,12 @@ typedef union cvmx_lmcx_wlevel_dbg cvmx_lmcx_wlevel_dbg_t;
  *
  * Four of these CSRs exist per LMC, one for each rank. Write level setting is measured in units
  * of 1/8 CK, so the below BYTEn values can range over 4 CK cycles. Assuming
- * LMC()_WLEVEL_CTL[SSET]=0, the BYTEn<2:0> values are not used during write-leveling, and
- * they are overwritten by the hardware as part of the write-leveling sequence. (Hardware sets
- * [STATUS] to 3 after hardware write-leveling completes for the rank). Software needs to set
+ * LMC()_WLEVEL_CTL[SSET]=0, the BYTEn<2:0> values are not used during write leveling, and
+ * they are overwritten by the hardware as part of the write leveling sequence. (Hardware sets
+ * [STATUS] to 3 after hardware write leveling completes for the rank). Software needs to set
  * BYTEn<4:3> bits.
  *
- * Each CSR may also be written by software, but not while a write-leveling sequence is in
+ * Each CSR may also be written by software, but not while a write leveling sequence is in
  * progress. (Hardware sets [STATUS] to 1 after a CSR write.) Software initiates a hardware
  * write-
  * leveling sequence by programming LMC()_WLEVEL_CTL and writing RANKMASK and INIT_START=1 with
@@ -13601,7 +13637,7 @@ typedef union cvmx_lmcx_wlevel_dbg cvmx_lmcx_wlevel_dbg_t;
  * LMC will then step through and accumulate write leveling results for 8 unique delay settings
  * (twice), starting at a delay of LMC()_WLEVEL_RANK() [BYTEn<4:3>]* 8 CK increasing by
  * 1/8 CK each setting. Hardware will then set LMC()_WLEVEL_RANK()[BYTEn<2:0>] to
- * indicate the first write leveling result of '1' that followed a result of '0' during the
+ * indicate the first write leveling result of 1 that followed a result of 0 during the
  * sequence by searching for a '1100' pattern in the generated bitmask, except that LMC will
  * always write LMC()_WLEVEL_RANK()[BYTEn<0>]=0. If hardware is unable to find a match
  * for a '1100' pattern, then hardware sets LMC()_WLEVEL_RANK() [BYTEn<2:0>] to 0x4. See
@@ -13618,12 +13654,12 @@ union cvmx_lmcx_wlevel_rankx {
 	struct cvmx_lmcx_wlevel_rankx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_47_63               : 17;
-	uint64_t status                       : 2;  /**< Indicates status of the write-leveling and where the BYTE* programmings in <44:0> came
+	uint64_t status                       : 2;  /**< Indicates status of the write leveling and where the BYTE* programmings in <44:0> came
                                                          from:
                                                          0x0 = BYTE* values are their reset value.
                                                          0x1 = BYTE* values were set via a CSR write to this register.
-                                                         0x2 = write-leveling sequence currently in progress (BYTE* values are unpredictable).
-                                                         0x3 = BYTE* values came from a complete write-leveling sequence, irrespective of which
+                                                         0x2 = Write leveling sequence currently in progress (BYTE* values are unpredictable).
+                                                         0x3 = BYTE* values came from a complete write leveling sequence, irrespective of which
                                                          lanes are masked via LMC()_WLEVEL_CTL[LANEMASK]. */
 	uint64_t byte8                        : 5;  /**< "Write level setting. Bit 0 of BYTE8 must be zero during normal operation. When ECC DRAM
                                                          is not present in 64-bit mode (i.e. when DRAM is not attached to chip signals DDR#_CBS_0_*
@@ -13806,7 +13842,8 @@ typedef union cvmx_lmcx_wodt_ctl1 cvmx_lmcx_wodt_ctl1_t;
  * designers may prefer different combinations of ODT ONs for write operations into different
  * ranks. CNXXXX supports full programmability by way of the mask register below. Each rank
  * position has its own 8-bit programmable field. When the controller does a write to that rank,
- * it sets the 4 ODT pins to the mask pins below. For example, when doing a write into Rank0, a
+ * it sets the four ODT pins to the mask pins below. For example, when doing a write into Rank0,
+ * a
  * system designer may desire to terminate the lines with the resistor on DIMM0/Rank1. The mask
  * [WODT_D0_R0] would then be [00000010].
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 776ad5251e57..13240f9129bd 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -3408,11 +3408,11 @@ union cvmx_mio_boot_pin_defs {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_33_63               : 31;
 	uint64_t dlm_supply                   : 1;  /**< DLM Power Supply Setting based on DLMC_VPH_SELECT_18 pin 1 = 1.8V. All others = Reserved. */
-	uint64_t rgm_supply                   : 2;  /**< RGMii Power Supply Setting based on VDD_RGM_SUPPLY_SELECT pin 01 = 1.8V 10 = 2.5V All
+	uint64_t rgm_supply                   : 2;  /**< RGMii Power Supply Setting based on VDD_RGM_SUPPLY_SELECT pin 10 = 2.5V All
                                                          others = Reserved */
-	uint64_t smi_supply                   : 3;  /**< SMI Power Supply Setting based on VDD_SMI_SUPPLY_SELECT pin 001 = 1.8V 010 = 2.5V 100 =
+	uint64_t smi_supply                   : 3;  /**< SMI Power Supply Setting based on VDD_SMI_SUPPLY_SELECT pin 010 = 2.5V 100 =
                                                          3.3V All others = Reserved */
-	uint64_t io_supply                    : 3;  /**< I/O Power Supply Setting based on VDD_IO_SUPPLY_SELECT pin 001 = 1.8V 010 = 2.5V 100 =
+	uint64_t io_supply                    : 3;  /**< I/O Power Supply Setting based on VDD_IO_SUPPLY_SELECT pin 010 = 2.5V 100 =
                                                          3.3V All others = Reserved */
 	uint64_t reserved_17_23               : 7;
 	uint64_t ref_sel                      : 1;  /**< Reference Clock Selection based on UART0_RTS_N pin at powerup 0 = DLM_REF_CLK[1] pins div
@@ -3447,16 +3447,13 @@ union cvmx_mio_boot_pin_defs {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
 	uint64_t rgm_supply                   : 2;  /**< RGMII power supply setting based on VDD_RGM_SUPPLY_SELECT pin:
-                                                         0x1 = 1.8V.
                                                          0x2 = 2.5V.
                                                          _ All other values reserved. */
 	uint64_t smi_supply                   : 3;  /**< SMI power supply setting based on VDD_SMI_SUPPLY_SELECT pin:
-                                                         0x1 = 1.8V.
                                                          0x2 = 2.5V.
                                                          0x4 = 3.3V.
                                                          _ All other values reserved. */
 	uint64_t io_supply                    : 3;  /**< I/O power supply setting based on VDD_IO_SUPPLY_SELECT pin:
-                                                         0x1 = 1.8V.
                                                          0x2 = 2.5V.
                                                          0x4 = 3.3V.
                                                          _ All other values reserved. */
@@ -3507,12 +3504,10 @@ union cvmx_mio_boot_pin_defs {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t smi_supply                   : 3;  /**< SMI power supply setting based on VDD_SMI_SUPPLY_SELECT pin:
-                                                         0x1 = 1.8V.
                                                          0x2 = 2.5V.
                                                          0x4 = 3.3V.
                                                          _ All other values reserved. */
 	uint64_t io_supply                    : 3;  /**< I/O power supply setting based on VDD_IO_SUPPLY_SELECT pin:
-                                                         0x1 = 1.8V.
                                                          0x2 = 2.5V.
                                                          0x4 = 3.3V.
                                                          _ All other values reserved. */
@@ -3906,8 +3901,8 @@ union cvmx_mio_emm_access_wdog {
 	struct cvmx_mio_emm_access_wdog_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t clk_cnt                      : 32; /**< Number of coprocessor-clocks to allow for a store operation to the device to complete
-                                                         before hardware will halt the operation.
+	uint64_t clk_cnt                      : 32; /**< Number of coprocessor-clock cycles to allow for a store operation to the device
+                                                         to complete before hardware will halt the operation.
                                                          Hardware will inject an error on the next 512-byte block boundary.   The pending DMA
                                                          operation can be resumed or terminated. A value of zero disables timer. */
 #else
@@ -4005,9 +4000,9 @@ union cvmx_mio_emm_cfg {
 	uint64_t bus_ena                      : 4;  /**< eMMC bus enable mask.
                                                          Setting bits 0..2 enable the corresponding EMMC bus by allowing EMMC_CMD[BUS_ENA]
                                                          operation. Bit 3 is reserved.
-                                                         Clearing all bits of this field will reset the other MIO_EMM_* registers.  It might be
+                                                         Clearing all bits of this field will reset the other MIO_EMM_* registers. It might be
                                                          necessary
-                                                         to set and and clear the bits several times to insure the MIO_EMM_* registers have been
+                                                         to set and and clear the bits several times to ensure the MIO_EMM_* registers have been
                                                          reset properly.
                                                          Setting one or more bits will enable EMMC_CLK operation. */
 #else
@@ -4043,7 +4038,7 @@ union cvmx_mio_emm_cmd {
                                                          0 = Command doesn't complete until card has dropped the BUSY signal.
                                                          1 = Complete command regardless of the BUSY signal. Status of signal can be read in
                                                          MIO_EMM_RSP_STS[RSP_BUSYBIT]. */
-	uint64_t bus_id                       : 2;  /**< Specify the eMMC bus */
+	uint64_t bus_id                       : 2;  /**< Specify the eMMC bus. */
 	uint64_t cmd_val                      : 1;  /**< Request valid. Software writes this bit to a 1. Hardware clears it when the operation completes. */
 	uint64_t reserved_56_58               : 3;
 	uint64_t dbuf                         : 1;  /**< Specify the data buffer to be used for a block transfer. */
@@ -4066,8 +4061,8 @@ union cvmx_mio_emm_cmd {
                                                          0x4 = R4, 48 bits.
                                                          0x5 = R5, 48 bits.
                                                          0x6, 0x7 = Reserved. */
-	uint64_t cmd_idx                      : 6;  /**< eMMC command */
-	uint64_t arg                          : 32; /**< eMMC command argument */
+	uint64_t cmd_idx                      : 6;  /**< eMMC command. */
+	uint64_t arg                          : 32; /**< eMMC command argument. */
 #else
 	uint64_t arg                          : 32;
 	uint64_t cmd_idx                      : 6;
@@ -4152,7 +4147,7 @@ union cvmx_mio_emm_dma {
                                                          0 = DMA doesn't complete until card has dropped the BUSY signal.
                                                          1 = Complete DMA after last transfer regardless of the BUSY signal. Status of signal can
                                                          be read in MIO_EMM_RSP_STS[RSP_BUSYBIT]. */
-	uint64_t bus_id                       : 2;  /**< Specify the eMMC bus */
+	uint64_t bus_id                       : 2;  /**< Specify the eMMC bus. */
 	uint64_t dma_val                      : 1;  /**< Software writes this bit to a 1 to indicate that hardware should perform the DMA transfer.
                                                          Hardware clears this bit when the DMA operation completes or is terminated. */
 	uint64_t sector                       : 1;  /**< Specify CARD_ADDR and eMMC are using sector (512 B) addressing. */
@@ -4162,7 +4157,7 @@ union cvmx_mio_emm_dma {
                                                          block transfer. Zero indicates to wait for the entire block. */
 	uint64_t rel_wr                       : 1;  /**< Set the reliable write parameter when performing CMD23 (SET_BLOCK_COUNT) for a multiple block. */
 	uint64_t rw                           : 1;  /**< Read/write bit (0 = read, 1 = write). */
-	uint64_t multi                        : 1;  /**< Perform operation using a multiple block command instead of a series of single block commands. */
+	uint64_t multi                        : 1;  /**< Perform operation using a multiple-block command instead of a series of single-block commands. */
 	uint64_t block_cnt                    : 16; /**< Number of blocks to read/write. Hardware decrements the block count after each successful
                                                          block transfer. */
 	uint64_t card_addr                    : 32; /**< Data address for media <= 2 GB is a 32-bit byte address, and data address for media > 2 GB
@@ -4271,7 +4266,7 @@ union cvmx_mio_emm_dma_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t en                           : 1;  /**< DMA engine enable. */
 	uint64_t rw                           : 1;  /**< DMA engine R/W bit: 0 = read, 1 = write. */
-	uint64_t clr                          : 1;  /**< DMA engine abort. When set to 1, DMA is aborted and EN is cleared on completion. */
+	uint64_t clr                          : 1;  /**< DMA engine abort. When set to 1, DMA is aborted and [EN] is cleared on completion. */
 	uint64_t reserved_60_60               : 1;
 	uint64_t swap32                       : 1;  /**< DMA engine 32-bit swap. */
 	uint64_t swap16                       : 1;  /**< DMA engine enable 16-bit swap. */
@@ -4330,7 +4325,7 @@ typedef union cvmx_mio_emm_dma_fifo_adr cvmx_mio_emm_dma_fifo_adr_t;
 /**
  * cvmx_mio_emm_dma_fifo_cfg
  *
- * This register controls DMA FIFO Operations.
+ * This register controls DMA FIFO operations.
  *
  */
 union cvmx_mio_emm_dma_fifo_cfg {
@@ -4338,19 +4333,19 @@ union cvmx_mio_emm_dma_fifo_cfg {
 	struct cvmx_mio_emm_dma_fifo_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_17_63               : 47;
-	uint64_t clr                          : 1;  /**< DMA FIFO Clear. When set erases all commands in the DMA FIFO. Must be zero for normal operation. */
+	uint64_t clr                          : 1;  /**< DMA FIFO clear. When set, erases all commands in the DMA FIFO. Must be zero for normal operation. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t int_lvl                      : 5;  /**< Interrupt threshold indicating the number of entries remaining in the
                                                          DMA FIFO.  An interrupt occurs if the FIFO is read at the level specified.
-                                                         A value of 0 disables the interrupt.  A value of 17 or greater will cause an
+                                                         A value of 0 disables the interrupt.  A value of 17 or greater causes an
                                                          interrupt only if the FIFO is overflowed.
                                                          See MIO_EMM_DMA_INT[FIFO]. */
 	uint64_t reserved_5_7                 : 3;
-	uint64_t count                        : 5;  /**< Number of entries in the DMA FIFO. This count is incremented by writes to the
-                                                         MIO_EMM_DMA_FIFO_CMD register and decremented each time the internal DMA engine completes
+	uint64_t count                        : 5;  /**< Number of entries in the DMA FIFO. This count is incremented by writes to
+                                                         MIO_EMM_DMA_FIFO_CMD and decremented each time the internal DMA engine completes
                                                          the previous command successfully.
                                                          Up to 16 entries can be placed in the FIFO. Entries written to a full FIFO will
-                                                         potentially corrupt existing entries.  Care must be taken by software to insure
+                                                         potentially corrupt existing entries.  Care must be taken by software to ensure
                                                          that this condition does not occur. */
 #else
 	uint64_t count                        : 5;
@@ -4377,8 +4372,8 @@ typedef union cvmx_mio_emm_dma_fifo_cfg cvmx_mio_emm_dma_fifo_cfg_t;
  * MIO_EMM_DMA_FIFO_ADR contents into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT]
  * field.
  *
- * Note: This register has a similar format to the MIO_EMM_DMA_CFG register with the exception
- * that the EN and CLR fields are absent. These are supported in the MIO_EMM_DMA_FIFO_CFG.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the exception
+ * that the EN and CLR fields are absent. These are supported in MIO_EMM_DMA_FIFO_CFG.
  */
 union cvmx_mio_emm_dma_fifo_cmd {
 	uint64_t u64;
@@ -4812,7 +4807,7 @@ union cvmx_mio_emm_rsp_sts {
                                                          MIO_EMM_DMA[DAT_NULL] = 1. Hardware will then clear [DMA_PEND] and perform the DMA
                                                          operation. */
 	uint64_t acc_timeout                  : 1;  /**< The store operation to the device took longer than MIO_EMM_ACCESS_WDOG[CLK_CNT]
-                                                         coprocessor-clocks to complete.
+                                                         coprocessor-clock cycles to complete.
                                                          Valid when [DMA_PEND] is set. */
 	uint64_t reserved_29_54               : 26;
 	uint64_t dbuf_err                     : 1;  /**< For [CMD_TYPE] = 1, indicates that a DMA read data arrived from the card without a free
@@ -5026,7 +5021,7 @@ union cvmx_mio_emm_switch {
 	struct cvmx_mio_emm_switch_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
-	uint64_t bus_id                       : 2;  /**< Specifies the eMMC bus id. */
+	uint64_t bus_id                       : 2;  /**< Specifies the eMMC bus ID. */
 	uint64_t switch_exe                   : 1;  /**< When clear, the operating modes are updated directly without performing any
                                                          SWITCH operations. This allows software to perform the SWITCH operations manually, then
                                                          update the hardware.
@@ -5108,7 +5103,7 @@ union cvmx_mio_emm_wdog {
                                                          it wants to free up buffer space.
                                                          The second case is when the last block of a write or multi write is being transferred and
                                                          the card elects to perform some background tasks. The same stall mechanism with
-                                                         emmc_data<0> is used but this can last for an extend time period. */
+                                                         EMMC_DAT<0> is used, but this can last for an extended time period. */
 #else
 	uint64_t clk_cnt                      : 26;
 	uint64_t reserved_26_63               : 38;
@@ -9985,7 +9980,7 @@ typedef union cvmx_mio_rst_int_en cvmx_mio_rst_int_en_t;
 /**
  * cvmx_mio_tws#_int
  *
- * This register contains the TWSI interrupt-enable mask and the interrupt-source bits.
+ * This register contains the TWSI interrupt-source and SDA/SCL override bits.
  *
  */
 union cvmx_mio_twsx_int {
@@ -10163,7 +10158,7 @@ union cvmx_mio_twsx_sw_twsi {
                                                          is updated in this case.
                                                          When this bit is clear, a write operation initiates either a master-mode operation or a
                                                          TWSI configuration register access. */
-	uint64_t eia                          : 1;  /**< Extended internal address. Sends an additional internal address byte (the MSB of IA is
+	uint64_t eia                          : 1;  /**< Extended internal address. Sends an additional internal address byte (the MSB of [IA] is
                                                          from MIO_TWS()_SW_TWSI_EXT[IA]). */
 	uint64_t op                           : 4;  /**< Opcode field. When the register is written with [SLONLY] = 0, this field initiates one of
                                                          the following read or write operations:
@@ -10201,11 +10196,11 @@ union cvmx_mio_twsx_sw_twsi {
                                                          0x0 = TWSI slave address register (TWSI_SLAVE_ADD).
                                                          0x1 = TWSI data register (TWSI_DATA).
                                                          0x2 = TWSI control register (TWSI_CTL).
-                                                         0x3 = (when R =  0) TWSI clock control register (TWSI_CLKCTL).
-                                                         0x3 = (when R = 1) TWSI status register (TWSI_STAT).
+                                                         0x3 = (when [R] = 0) TWSI clock control register (TWSI_CLKCTL).
+                                                         0x3 = (when [R] = 1) TWSI status register (TWSI_STAT).
                                                          0x4 = TWSI extended slave register (TWSI_SLAVE_ADD_EXT).
                                                          0x7 = TWSI soft reset register (TWSI_RST).
-                                                         Also provides the lower 3 bits of internal address when launching a combined master-mode
+                                                         Also provides the lower three bits of internal address when launching a combined master-mode
                                                          operation. */
 	uint64_t d                            : 32; /**< Data field.
                                                          Used on a write operation when:
@@ -10267,7 +10262,7 @@ typedef union cvmx_mio_twsx_sw_twsi cvmx_mio_twsx_sw_twsi_t;
  * The IA field is sent as the first byte of internal address when performing master-mode
  * combined-read/write-with-IA operations and MIO_TWS()_SW_TWSI[EIA] is set. The D field
  * extends the data field of MIO_TWS()_SW_TWSI for a total of 8 bytes (SOVR must be set to
- * perform operations greater than 4 bytes).
+ * perform operations greater than four bytes).
  */
 union cvmx_mio_twsx_sw_twsi_ext {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
index e09a6b78c4b1..c031f6c9ba8f 100644
--- a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -219,7 +219,7 @@ union cvmx_ndf_bt_pg_info {
 	struct cvmx_ndf_bt_pg_info_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_11_63               : 53;
-	uint64_t t_mult                       : 4;  /**< The boot-time TIM_MULT field of the SET_TM_PAR command. */
+	uint64_t t_mult                       : 4;  /**< The boot-time TIM_MULT field of the SET_TM_PARAM command. */
 	uint64_t adr_cyc                      : 4;  /**< Number of column-address cycles. Legal values are 0x3 - 0x8. Values written to this field
                                                          smaller than 0x3 are converted to 0x3; values larger than 0x8 are converted to 0x8. */
 	uint64_t size                         : 3;  /**< Number of bytes per page in the NAND flash device = 2^SIZE+1 * 256.
@@ -607,7 +607,7 @@ union cvmx_ndf_misc {
                                                          NDF_CMD queue. Bytes become unfilled as commands complete execution and exit. (FIFO is 256
                                                          bytes when BT_DIS = 0 and 1536 bytes when BT_DIS = 1.) */
 	uint64_t rd_done                      : 1;  /**< Read done. This bit is set to 1 by hardware when it reads the last eight bytes out of the
-                                                         NDF_CMD queue in response to RD_CMD being set to 1 by software. */
+                                                         NDF_CMD queue in response to [RD_CMD] being set to 1 by software. */
 	uint64_t rd_val                       : 1;  /**< This read-only bit is set to 1 by hardware when it reads the next eight bytes from NDF_CMD
                                                          queue in response to RD_CMD being set to 1. A software read of NDF_CMD clears this bit to
                                                          0. */
diff --git a/arch/mips/include/asm/octeon/cvmx-npei-defs.h b/arch/mips/include/asm/octeon/cvmx-npei-defs.h
index c7f78e0d835a..09b0f714000d 100644
--- a/arch/mips/include/asm/octeon/cvmx-npei-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-npei-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-npi-defs.h b/arch/mips/include/asm/octeon/cvmx-npi-defs.h
index df64e846be62..17c6ae3097f3 100644
--- a/arch/mips/include/asm/octeon/cvmx-npi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-npi-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 1c695a4f2f1b..a1f8524c0f16 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -553,14 +553,17 @@ union cvmx_oclax_cdhx_ctl {
 	uint64_t reserved_6_63                : 58;
 	uint64_t dup                          : 1;  /**< Retain duplicates in the data stream. */
 	uint64_t dis_stamp                    : 1;  /**< Remove time stamps from data stream. */
-	uint64_t cap_ctl                      : 4;  /**< Minterms that will cause data to be captured. These minterms are the four inputs to a 4-1
-                                                         mux selected by PLA1 and 0. The output is thus calculated from the equation:
+	uint64_t cap_ctl                      : 4;  /**< Minterms that will cause data to be captured. These minterms are the four inputs
+                                                         to a four-to-one mux selected by PLA1 and zero. The output is thus calculated
+                                                         from the equation:
+                                                         <pre>
                                                            fsmcap0 = OCLA(0..2)_FSM(0)_STATE[state0][CAP].
                                                            fsmcap1 = OCLA(0..2)_FSM(1)_STATE[state1][CAP].
                                                            out = (   (<3> & fsmcap1 & fsmcap0)
-                                                         _        || (<2> & fsmcap1 & !fsmcap0)
-                                                         _        || (<1> & !fsmcap1 & fsmcap0)
-                                                         _        || (<0> & !fsmcap1 & !fsmcap0)).
+                                                                  || (<2> & fsmcap1 & !fsmcap0)
+                                                                  || (<1> & !fsmcap1 & fsmcap0)
+                                                                  || (<0> & !fsmcap1 & !fsmcap0)).
+                                                         </pre>
                                                          Common examples:
                                                          0x0 = No capture.
                                                          0xA = Capture when fsmcap0 requests capture.
@@ -677,7 +680,7 @@ union cvmx_oclax_eco {
 	struct cvmx_oclax_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< N/A */
+	uint64_t eco_rw                       : 32; /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -891,7 +894,7 @@ typedef union cvmx_oclax_fsmx_orx cvmx_oclax_fsmx_orx_t;
 /**
  * cvmx_ocla#_fsm#_state#
  *
- * See State Outputs for more details on each of these actions.
+ * See the OCLA chapter text for more details on each of these actions.
  *
  */
 union cvmx_oclax_fsmx_statex {
@@ -910,8 +913,7 @@ union cvmx_oclax_fsmx_statex {
 	uint64_t reserved_12_15               : 4;
 	uint64_t clr_cnt                      : 4;  /**< In this state clear match counter. */
 	uint64_t reserved_4_7                 : 4;
-	uint64_t inc_cnt                      : 4;  /**< In this state increment match counter. See State Outputs for more information on this or
-                                                         any of the bits above. */
+	uint64_t inc_cnt                      : 4;  /**< In this state increment match counter. */
 #else
 	uint64_t inc_cnt                      : 4;
 	uint64_t reserved_4_7                 : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 38ec408f2e96..c589209840d6 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -981,21 +981,27 @@ union cvmx_ocx_com_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_55_63               : 9;
 	uint64_t io_badid                     : 1;  /**< I/O request or response cannot be sent because a link was not found with a packet node ID
-                                                         matching the OCX_COM_LINK(0..2)_CTL[ID]
-                                                         with OCX_COM_LINK(0..2)_CTL[VALID] bit set. Transaction has been dropped. */
+                                                         matching the OCX_COM_LINK(0..2)_CTL[ID] with OCX_COM_LINK(0..2)_CTL[VALID] bit set.
+                                                         Transaction has been dropped.  Should not occur during normal operation. This may indicate
+                                                         a software/configuration failure and may be considered fatal. */
 	uint64_t mem_badid                    : 1;  /**< Memory request or response cannot be sent because a link was not found with a packet node
-                                                         ID matching the OCX_COM_LINK(0..2)_CTL[ID]
-                                                         with OCX_COM_LINK(0..2)_CTL[VALID] bit set. Transaction has been dropped. */
+                                                         ID matching the OCX_COM_LINK(0..2)_CTL[ID] with OCX_COM_LINK(0..2)_CTL[VALID] bit set.
+                                                         Transaction has been dropped.  Should not occur during normal operation. This may indicate
+                                                         a software/configuration failure and may be considered fatal. */
 	uint64_t copr_badid                   : 1;  /**< Scheduler add work or buffer pool return cannot be sent because a link was not found with
-                                                         a node ID matching the
-                                                         OCX_COM_LINK(0..2)_CTL[ID] with OCX_COM_LINK(0..2)_CTL[VALID] bit set.  Transaction has
-                                                         been dropped. */
+                                                         a node ID matching the OCX_COM_LINK(0..2)_CTL[ID] with OCX_COM_LINK(0..2)_CTL[VALID] bit
+                                                         set.
+                                                         Transaction has been dropped.  Should not occur during normal operation. This may indicate
+                                                         a software/configuration failure and may be considered fatal. */
 	uint64_t win_req_badid                : 1;  /**< Window request specified in SLI_WIN_RD_ADDR, SLI_WIN_WR_ADDR, OCX_WIN_CMD or OCX_PP_CMD
                                                          cannot be sent because a link was not found with a request node ID matching the
-                                                         OCX_COM_LINK(0..2)_CTL[ID]
-                                                         with OCX_COM_LINK(0..2)_CTL[VALID] bit set.  Transaction has been dropped. */
+                                                         OCX_COM_LINK(0..2)_CTL[ID] with OCX_COM_LINK(0..2)_CTL[VALID] bit set.  Transaction has
+                                                         been
+                                                         dropped.  Should not occur during normal operation. This may indicate a
+                                                         software/configuration failure and may be considered fatal. */
 	uint64_t win_req_tout                 : 1;  /**< Window or core request was dropped because it could not be send during the period
-                                                         specified by OCX_WIN_TIMER. */
+                                                         specified by OCX_WIN_TIMER.  Should not occur during normal operation. This may indicate a
+                                                         software/configuration failure and may be considered fatal. */
 	uint64_t win_req_xmit                 : 1;  /**< Window request specified in SLI_WIN_RD_ADDR, SLI_WIN_WR_ADDR, OCX_WIN_CMD or OCX_PP_CMD
                                                          has been scheduled for transmission. If the command was not expecting a response, then a
                                                          new command may be issued. */
@@ -1090,25 +1096,38 @@ union cvmx_ocx_com_linkx_int {
 	struct cvmx_ocx_com_linkx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t bad_word                     : 1;  /**< Illegal word decoded on at least one lane of link. */
-	uint64_t align_fail                   : 1;  /**< Link lanes failed to align. */
-	uint64_t align_done                   : 1;  /**< Link lane alignment is complete. */
+	uint64_t bad_word                     : 1;  /**< Illegal word decoded on at least one lane of link. These receive errors may occur during
+                                                         normal operation, and may likely occur during link bringup. Hardware normally will
+                                                         automatically correct the error. Software may choose to count the number of these errors. */
+	uint64_t align_fail                   : 1;  /**< Link lanes failed to align. These receive errors may occur during normal operation, and
+                                                         may likely occur during link bringup. Hardware normally will automatically correct the
+                                                         error. Software may choose to count the number of these errors. */
+	uint64_t align_done                   : 1;  /**< Link lane alignment is complete. These may occur during normal operation, and will occur
+                                                         during link bringup. Software should disable reception of these interrupts during normal
+                                                         operation. */
 	uint64_t up                           : 1;  /**< Link initialization is complete and is ready to pass traffic. Note this state occurs some
                                                          time after the link starts exchanging information as indicated in
-                                                         OCX_COM_LINK(0..2)_CTL[UP]. */
+                                                         OCX_COM_LINK(0..2)_CTL[UP]. These should not occur during normal operation. */
 	uint64_t stop                         : 1;  /**< Link has stopped operating. Link retry count has reached threshold specified in
                                                          OCX_COM_LINK_TIMER; outgoing traffic has been dropped and an initialization request has
-                                                         been reissued. */
-	uint64_t blk_err                      : 1;  /**< Link block error count has reached threshold specified in OCX_RLK(0..2)_BLK_ERR[LIMIT]. */
-	uint64_t reinit                       : 1;  /**< Link has received a initialization request from link partner after link has been established. */
+                                                         been reissued. These should not occur during normal operation. This may be considered
+                                                         fatal. */
+	uint64_t blk_err                      : 1;  /**< Link block error count has reached threshold specified in OCX_RLK(0..2)_BLK_ERR[LIMIT].
+                                                         These receive errors may occur during normal operation. Hardware normally will
+                                                         automatically correct the error. Software may choose to count the number of these errors. */
+	uint64_t reinit                       : 1;  /**< Link has received a initialization request from link partner after link has been
+                                                         established. These should not occur during normal operation */
 	uint64_t lnk_data                     : 1;  /**< Set by hardware when a link data block is received in OCX_RLK(0..2)_LNK_DATA. It
                                                          software's responsibility to clear the bit after reading the data. */
-	uint64_t rxfifo_dbe                   : 1;  /**< Double-bit error detected in FIFO RAMs. */
-	uint64_t rxfifo_sbe                   : 1;  /**< Single-bit error detected/corrected in FIFO RAMs. */
-	uint64_t txfifo_dbe                   : 1;  /**< Double-bit error detected in TX FIFO RAMs. */
-	uint64_t txfifo_sbe                   : 1;  /**< Single-bit error detected/corrected in TX FIFO RAMs. */
-	uint64_t replay_dbe                   : 1;  /**< Double-bit error detected in REPLAY BUFFER RAMs. */
-	uint64_t replay_sbe                   : 1;  /**< Single-bit error detected/corrected in REPLAY BUFFER RAMs. */
+	uint64_t rxfifo_dbe                   : 1;  /**< Double-bit error detected in FIFO RAMs. This error may be considered fatal. */
+	uint64_t rxfifo_sbe                   : 1;  /**< Single-bit error detected/corrected in FIFO RAMs. Hardware automatically corrected the
+                                                         error. Software may choose to count the number of these single-bit errors. */
+	uint64_t txfifo_dbe                   : 1;  /**< Double-bit error detected in TX FIFO RAMs. This error may be considered fatal. */
+	uint64_t txfifo_sbe                   : 1;  /**< Single-bit error detected/corrected in TX FIFO RAMs. Hardware automatically corrected the
+                                                         error. Software may choose to count the number of these single-bit errors. */
+	uint64_t replay_dbe                   : 1;  /**< Double-bit error detected in REPLAY BUFFER RAMs. This error may be considered fatal. */
+	uint64_t replay_sbe                   : 1;  /**< Single-bit error detected/corrected in REPLAY BUFFER RAMs. Hardware automatically
+                                                         corrected the error. Software may choose to count the number of these single-bit errors. */
 #else
 	uint64_t replay_sbe                   : 1;
 	uint64_t replay_dbe                   : 1;
@@ -1373,18 +1392,38 @@ union cvmx_ocx_lnex_int {
 	struct cvmx_ocx_lnex_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t disp_err                     : 1;  /**< RX disparity error encountered. */
+	uint64_t disp_err                     : 1;  /**< RX disparity error encountered. These receive errors may occur during normal operation,
+                                                         and may likely occur during link bringup. Hardware normally will automatically correct the
+                                                         error. Software may choose to count the number of these errors. */
 	uint64_t bad_64b67b                   : 1;  /**< Bad 64B/67B codeword encountered. Once the bad word reaches the link, as denoted by
-                                                         OCX_COM_LINK(0..2)_INT[BAD_WORD], a retry handshake is initiated. */
+                                                         OCX_COM_LINK(0..2)_INT[BAD_WORD], a retry handshake is initiated. These receive errors may
+                                                         occur during normal operation, and may likely occur during link bringup. Hardware normally
+                                                         will automatically correct the error. Software may choose to count the number of these
+                                                         errors. */
 	uint64_t stat_cnt_ovfl                : 1;  /**< RX lane statistic counter overflow. */
-	uint64_t stat_msg                     : 1;  /**< Status bits for the link or a lane transitioned from a 1 (healthy) to a 0 (problem). */
-	uint64_t dskew_fifo_ovfl              : 1;  /**< RX deskew FIFO overflow occurred. */
-	uint64_t scrm_sync_loss               : 1;  /**< 4 consecutive bad sync words or 3 consecutive scramble state mismatches. */
-	uint64_t ukwn_cntl_word               : 1;  /**< Unknown framing control word. Block type does not match any of (SYNC, SCRAM, SKIP, DIAG). */
-	uint64_t crc32_err                    : 1;  /**< Diagnostic CRC32 errors. */
+	uint64_t stat_msg                     : 1;  /**< Status bits for the link or a lane transitioned from a 1 (healthy) to a 0 (problem). These
+                                                         should not occur during normal operation. This may be considered fatal, depending on the
+                                                         software protocol. */
+	uint64_t dskew_fifo_ovfl              : 1;  /**< RX deskew FIFO overflow occurred. These receive errors may occur during normal operation,
+                                                         and may likely occur during link bringup. Hardware normally will automatically correct the
+                                                         error. Software may choose to count the number of these errors. */
+	uint64_t scrm_sync_loss               : 1;  /**< 4 consecutive bad sync words or 3 consecutive scramble state mismatches. These receive
+                                                         errors should not occur during normal operation, but may likely occur during link bringup.
+                                                         Hardware normally will automatically correct the error. Software may choose to count the
+                                                         number of these errors. */
+	uint64_t ukwn_cntl_word               : 1;  /**< Unknown framing control word. Block type does not match any of (SYNC, SCRAM, SKIP, DIAG).
+                                                         These receive errors may occur during normal operation. Hardware normally will
+                                                         automatically correct the error. Software may choose to count the number of these errors. */
+	uint64_t crc32_err                    : 1;  /**< Diagnostic CRC32 errors. These receive errors may occur during normal operation, typically
+                                                         in the presence of other errors, and may likely occur during link bringup. Hardware
+                                                         normally will automatically correct the error. Software may choose to count the number of
+                                                         these errors. */
 	uint64_t bdry_sync_loss               : 1;  /**< RX logic lost word boundary sync after 16 tries. Hardware automatically attempts to regain
-                                                         word boundary sync. */
-	uint64_t serdes_lock_loss             : 1;  /**< RX SerDes loses lock. */
+                                                         word boundary sync. These receive errors should not occur during normal operation, but may
+                                                         likely occur during link bringup. Hardware normally will automatically correct the error.
+                                                         Software may choose to count the number of these errors. */
+	uint64_t serdes_lock_loss             : 1;  /**< RX SerDes loses lock. These receive errors should not occur during normal operation. This
+                                                         may be considered fatal. */
 #else
 	uint64_t serdes_lock_loss             : 1;
 	uint64_t bdry_sync_loss               : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-pci-defs.h b/arch/mips/include/asm/octeon/cvmx-pci-defs.h
index 588183d45760..b1112db03506 100644
--- a/arch/mips/include/asm/octeon/cvmx-pci-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pci-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index da8324181e1e..bc0f2e86941e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -6949,7 +6949,7 @@ union cvmx_pcieepx_cfg000 {
 	uint32_t u32;
 	struct cvmx_pcieepx_cfg000_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t devid                        : 16; /**< Device ID for CNF75XX, writable through PEM()_CFG_WR.
+	uint32_t devid                        : 16; /**< Device ID for CNXXXX, writable through PEM()_CFG_WR.
                                                          For EEPROM loads, also see VENDID of this register. */
 	uint32_t vendid                       : 16; /**< Cavium's vendor ID, writable through PEM()_CFG_WR.
                                                          During an EPROM Load, if a value of 0xFFFF is loaded to this field and
@@ -13746,19 +13746,15 @@ union cvmx_pcieepx_cfg515 {
                                                          indicates full swing. When set to 0, indicates low swing. */
 	uint32_t dsc                          : 1;  /**< Directed speed change. A write of 1 initiates a speed change.
                                                          When the speed change occurs, the controller will clear the contents of this field. */
-	uint32_t le                           : 9;  /**< Lane enable. Indicates the number of lanes to check for exit from electrical idle in
-                                                         Polling.Active and Polling.Compliance. 0x1 = x1, 0x2 = x2, etc. Used to limit the maximum
-                                                         link width to ignore broken lanes that detect a receiver, but will not exit electrical
-                                                         idle and would otherwise prevent a valid link from being configured. */
+	uint32_t reserved_8_16                : 9;
 	uint32_t n_fts                        : 8;  /**< N_FTS. Sets the number of fast training sequences (N_FTS) that the core advertises as its
                                                          N_FTS during GEN2 Link training. This value is used to inform the link partner about the
                                                          PHY's ability to recover synchronization after a low power state.
-                                                         Do not set [N_FTS] to zero; doing so can cause the LTSSM to go into the recovery state
-                                                         when
-                                                         exiting from L0s. */
+                                                         Do not set [N_FTS] to zero; doing so can cause the LTSSM to go into the recovery
+                                                         state when exiting from L0s. */
 #else
 	uint32_t n_fts                        : 8;
-	uint32_t le                           : 9;
+	uint32_t reserved_8_16                : 9;
 	uint32_t dsc                          : 1;
 	uint32_t cpyts                        : 1;
 	uint32_t ctcrb                        : 1;
@@ -13766,19 +13762,106 @@ union cvmx_pcieepx_cfg515 {
 	uint32_t reserved_21_31               : 11;
 #endif
 	} s;
-	struct cvmx_pcieepx_cfg515_s          cn61xx;
-	struct cvmx_pcieepx_cfg515_s          cn63xx;
-	struct cvmx_pcieepx_cfg515_s          cn63xxp1;
-	struct cvmx_pcieepx_cfg515_s          cn66xx;
-	struct cvmx_pcieepx_cfg515_s          cn68xx;
-	struct cvmx_pcieepx_cfg515_s          cn68xxp1;
-	struct cvmx_pcieepx_cfg515_s          cn70xx;
-	struct cvmx_pcieepx_cfg515_s          cn70xxp1;
-	struct cvmx_pcieepx_cfg515_s          cn73xx;
-	struct cvmx_pcieepx_cfg515_s          cn78xx;
-	struct cvmx_pcieepx_cfg515_s          cn78xxp1;
-	struct cvmx_pcieepx_cfg515_s          cnf71xx;
-	struct cvmx_pcieepx_cfg515_s          cnf75xx;
+	struct cvmx_pcieepx_cfg515_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_21_31               : 11;
+	uint32_t s_d_e                        : 1;  /**< SEL_DE_EMPHASIS
+                                                         Used to set the de-emphasis level for upstream ports. */
+	uint32_t ctcrb                        : 1;  /**< Config Tx Compliance Receive Bit
+                                                         When set to 1, signals LTSSM to transmit TS ordered sets
+                                                         with the compliance receive bit assert (equal to 1). */
+	uint32_t cpyts                        : 1;  /**< Config PHY Tx Swing
+                                                         Indicates the voltage level the PHY should drive. When set to
+                                                         1, indicates Full Swing. When set to 0, indicates Low Swing */
+	uint32_t dsc                          : 1;  /**< Directed Speed Change
+                                                         o a write of '1' will initiate a speed change
+                                                         o always reads a zero */
+	uint32_t le                           : 9;  /**< Lane Enable
+                                                         Indicates the number of lanes to check for exit from electrical
+                                                         idle in Polling.Active and Polling.Compliance. 1 = x1, 2 = x2,
+                                                         etc. Used to limit the maximum link width to ignore broken
+                                                         lanes that detect a receiver, but will not exit electrical
+                                                         idle and
+                                                         would otherwise prevent a valid link from being configured. */
+	uint32_t n_fts                        : 8;  /**< N_FTS
+                                                         Sets the Number of Fast Training Sequences (N_FTS) that
+                                                         the core advertises as its N_FTS during GEN2 Link training.
+                                                         This value is used to inform the Link partner about the PHYs
+                                                         ability to recover synchronization after a low power state.
+                                                         Note: Do not set N_FTS to zero; doing so can cause the
+                                                               LTSSM to go into the recovery state when exiting from
+                                                               L0s. */
+#else
+	uint32_t n_fts                        : 8;
+	uint32_t le                           : 9;
+	uint32_t dsc                          : 1;
+	uint32_t cpyts                        : 1;
+	uint32_t ctcrb                        : 1;
+	uint32_t s_d_e                        : 1;
+	uint32_t reserved_21_31               : 11;
+#endif
+	} cn61xx;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn63xx;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn63xxp1;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn66xx;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn68xx;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn68xxp1;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn70xx;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn70xxp1;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn73xx;
+	struct cvmx_pcieepx_cfg515_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_21_31               : 11;
+	uint32_t s_d_e                        : 1;  /**< SEL_DE_EMPHASIS. Used to set the deemphasis level for upstream ports. */
+	uint32_t ctcrb                        : 1;  /**< Config TX compliance receive bit. When set to 1, signals LTSSM to transmit TS ordered sets
+                                                         with the compliance receive bit assert (equal to 1). */
+	uint32_t cpyts                        : 1;  /**< Config PHY TX swing. Indicates the voltage level that the PHY should drive. When set to 1,
+                                                         indicates full swing. When set to 0, indicates low swing. */
+	uint32_t dsc                          : 1;  /**< Directed speed change. A write of 1 initiates a speed change.
+                                                         When the speed change occurs, the controller will clear the contents of this field. */
+	uint32_t alaneflip                    : 1;  /**< Enable auto flipping of the lanes. */
+	uint32_t pdetlane                     : 3;  /**< Predetermined lane for auto flip. This field defines which
+                                                         physical lane is connected to logical Lane0 by the flip
+                                                         operation performed in detect.
+                                                           0x0 = Auto flipping not supported.
+                                                           0x1 = Connect logical Lane0 to physical lane 1.
+                                                           0x2 = Connect logical Lane0 to physical lane 3.
+                                                           0x3 = Connect logical Lane0 to physical lane 7.
+                                                           0x4 = Connect logical Lane0 to physical lane 15.
+                                                           0x5 - 0x7 = Reserved. */
+	uint32_t nlanes                       : 5;  /**< Predetermined number of lanes.  Defines the number of
+                                                         lanes which are connected and not bad. Used to limit the
+                                                         effective link width to ignore "broken" or "unused" lanes that
+                                                         detect a receiver. Indicates the number of lanes to check for
+                                                         exit from electrical idle in Polling.Active and L2.Idle.
+                                                         0x1 = 1 lane.
+                                                         0x2 = 2 lanes.
+                                                         0x3 = 3 lanes.
+                                                         - ...
+                                                         0x8 = 8 lanes.
+                                                         0x9-0x1F = Reserved.
+                                                         When there are unused lanes in the system, then this value must reflect the
+                                                         number of lanes. PCIEEP()_CFG452[LME] must also be changed likewise. */
+	uint32_t n_fts                        : 8;  /**< N_FTS. Sets the number of fast training sequences (N_FTS) that the core advertises as its
+                                                         N_FTS during GEN2 Link training. This value is used to inform the link partner about the
+                                                         PHY's ability to recover synchronization after a low power state.
+                                                         Do not set [N_FTS] to zero; doing so can cause the LTSSM to go into the recovery
+                                                         state when exiting from L0s. */
+#else
+	uint32_t n_fts                        : 8;
+	uint32_t nlanes                       : 5;
+	uint32_t pdetlane                     : 3;
+	uint32_t alaneflip                    : 1;
+	uint32_t dsc                          : 1;
+	uint32_t cpyts                        : 1;
+	uint32_t ctcrb                        : 1;
+	uint32_t s_d_e                        : 1;
+	uint32_t reserved_21_31               : 11;
+#endif
+	} cn78xx;
+	struct cvmx_pcieepx_cfg515_cn61xx     cn78xxp1;
+	struct cvmx_pcieepx_cfg515_cn61xx     cnf71xx;
+	struct cvmx_pcieepx_cfg515_cn78xx     cnf75xx;
 };
 typedef union cvmx_pcieepx_cfg515 cvmx_pcieepx_cfg515_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 4238ac7eae16..11212b71e628 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -6300,8 +6300,7 @@ union cvmx_pciercx_cfg028 {
 	uint32_t reserved_30_31               : 2;
 	uint32_t imn                          : 5;  /**< Interrupt message number. Updated by hardware, writable through
                                                          PEM()_CFG_WR. However, the application must not change this field. */
-	uint32_t si                           : 1;  /**< Slot implemented. This bit is writable through PEM()_CFG_WR. However, it must 0 for an
-                                                         endpoint device. Therefore, the application must not write a 1 to this bit. */
+	uint32_t si                           : 1;  /**< Slot implemented. This bit is writable through PEM()_CFG_WR. */
 	uint32_t dpt                          : 4;  /**< Device port type. */
 	uint32_t pciecv                       : 4;  /**< PCI Express capability version. */
 	uint32_t ncp                          : 8;  /**< Next capability pointer. Points to the MSI-X capability by default, writable through
@@ -6710,7 +6709,8 @@ union cvmx_pciercx_cfg032 {
                                                          link capabilities register. */
 	uint32_t es                           : 1;  /**< Extended synch. */
 	uint32_t ccc                          : 1;  /**< Common clock configuration. */
-	uint32_t rl                           : 1;  /**< Retrain link. */
+	uint32_t rl                           : 1;  /**< Retrain link.
+                                                         As per the PCIe specification this bit always reads as zero. */
 	uint32_t ld                           : 1;  /**< Link disable. */
 	uint32_t rcb                          : 1;  /**< Read completion boundary (RCB), writable through
                                                          PEM()_CFG_WR. However, the application must not change this field because an RCB of 64
@@ -6770,8 +6770,7 @@ union cvmx_pciercx_cfg033 {
 	uint32_t u32;
 	struct cvmx_pciercx_cfg033_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t ps_num                       : 13; /**< Physical slot number, writable through PEM()_CFG_WR. However, the application must not
-                                                         change this field. */
+	uint32_t ps_num                       : 13; /**< Physical slot number, writable through PEM()_CFG_WR. */
 	uint32_t nccs                         : 1;  /**< No command complete support, writable through PEM()_CFG_WR. However, the application
                                                          must not change this field. */
 	uint32_t emip                         : 1;  /**< Electromechanical interlock present, writable through PEM()_CFG_WR. However, the
@@ -10886,19 +10885,15 @@ union cvmx_pciercx_cfg515 {
                                                          indicates full swing. When set to 0, indicates low swing. */
 	uint32_t dsc                          : 1;  /**< Directed speed change. A write of 1 initiates a speed change.
                                                          When the speed change occurs, the controller will clear the contents of this field. */
-	uint32_t le                           : 9;  /**< Lane enable. Indicates the number of lanes to check for exit from electrical idle in
-                                                         Polling.Active and Polling.Compliance. 0x1 = x1, 0x2 = x2, etc. Used to limit the maximum
-                                                         link width to ignore broken lanes that detect a receiver, but will not exit electrical
-                                                         idle and would otherwise prevent a valid link from being configured. */
+	uint32_t reserved_8_16                : 9;
 	uint32_t n_fts                        : 8;  /**< N_FTS. Sets the number of fast training sequences (N_FTS) that the core advertises as its
                                                          N_FTS during GEN2 Link training. This value is used to inform the link partner about the
                                                          PHY's ability to recover synchronization after a low power state.
-                                                         Do not set [N_FTS] to zero; doing so can cause the LTSSM to go into the recovery state
-                                                         when
-                                                         exiting from L0s. */
+                                                         Do not set [N_FTS] to zero; doing so can cause the LTSSM to go into the recovery
+                                                         state when exiting from L0s. */
 #else
 	uint32_t n_fts                        : 8;
-	uint32_t le                           : 9;
+	uint32_t reserved_8_16                : 9;
 	uint32_t dsc                          : 1;
 	uint32_t cpyts                        : 1;
 	uint32_t ctcrb                        : 1;
@@ -10906,19 +10901,106 @@ union cvmx_pciercx_cfg515 {
 	uint32_t reserved_21_31               : 11;
 #endif
 	} s;
-	struct cvmx_pciercx_cfg515_s          cn61xx;
-	struct cvmx_pciercx_cfg515_s          cn63xx;
-	struct cvmx_pciercx_cfg515_s          cn63xxp1;
-	struct cvmx_pciercx_cfg515_s          cn66xx;
-	struct cvmx_pciercx_cfg515_s          cn68xx;
-	struct cvmx_pciercx_cfg515_s          cn68xxp1;
-	struct cvmx_pciercx_cfg515_s          cn70xx;
-	struct cvmx_pciercx_cfg515_s          cn70xxp1;
-	struct cvmx_pciercx_cfg515_s          cn73xx;
-	struct cvmx_pciercx_cfg515_s          cn78xx;
-	struct cvmx_pciercx_cfg515_s          cn78xxp1;
-	struct cvmx_pciercx_cfg515_s          cnf71xx;
-	struct cvmx_pciercx_cfg515_s          cnf75xx;
+	struct cvmx_pciercx_cfg515_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_21_31               : 11;
+	uint32_t s_d_e                        : 1;  /**< SEL_DE_EMPHASIS
+                                                         Used to set the de-emphasis level for upstream ports. */
+	uint32_t ctcrb                        : 1;  /**< Config Tx Compliance Receive Bit
+                                                         When set to 1, signals LTSSM to transmit TS ordered sets
+                                                         with the compliance receive bit assert (equal to 1). */
+	uint32_t cpyts                        : 1;  /**< Config PHY Tx Swing
+                                                         Indicates the voltage level the PHY should drive. When set to
+                                                         1, indicates Full Swing. When set to 0, indicates Low Swing */
+	uint32_t dsc                          : 1;  /**< Directed Speed Change
+                                                         o a write of '1' will initiate a speed change
+                                                         o always reads a zero */
+	uint32_t le                           : 9;  /**< Lane Enable
+                                                         Indicates the number of lanes to check for exit from electrical
+                                                         idle in Polling.Active and Polling.Compliance. 1 = x1, 2 = x2,
+                                                         etc. Used to limit the maximum link width to ignore broken
+                                                         lanes that detect a receiver, but will not exit electrical
+                                                         idle and
+                                                         would otherwise prevent a valid link from being configured. */
+	uint32_t n_fts                        : 8;  /**< N_FTS
+                                                         Sets the Number of Fast Training Sequences (N_FTS) that
+                                                         the core advertises as its N_FTS during GEN2 Link training.
+                                                         This value is used to inform the Link partner about the PHYs
+                                                         ability to recover synchronization after a low power state.
+                                                         Note: Do not set N_FTS to zero; doing so can cause the
+                                                               LTSSM to go into the recovery state when exiting from
+                                                               L0s. */
+#else
+	uint32_t n_fts                        : 8;
+	uint32_t le                           : 9;
+	uint32_t dsc                          : 1;
+	uint32_t cpyts                        : 1;
+	uint32_t ctcrb                        : 1;
+	uint32_t s_d_e                        : 1;
+	uint32_t reserved_21_31               : 11;
+#endif
+	} cn61xx;
+	struct cvmx_pciercx_cfg515_cn61xx     cn63xx;
+	struct cvmx_pciercx_cfg515_cn61xx     cn63xxp1;
+	struct cvmx_pciercx_cfg515_cn61xx     cn66xx;
+	struct cvmx_pciercx_cfg515_cn61xx     cn68xx;
+	struct cvmx_pciercx_cfg515_cn61xx     cn68xxp1;
+	struct cvmx_pciercx_cfg515_cn61xx     cn70xx;
+	struct cvmx_pciercx_cfg515_cn61xx     cn70xxp1;
+	struct cvmx_pciercx_cfg515_cn61xx     cn73xx;
+	struct cvmx_pciercx_cfg515_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_21_31               : 11;
+	uint32_t s_d_e                        : 1;  /**< SEL_DE_EMPHASIS. Used to set the deemphasis level for upstream ports. */
+	uint32_t ctcrb                        : 1;  /**< Config TX compliance receive bit. When set to 1, signals LTSSM to transmit TS ordered sets
+                                                         with the compliance receive bit assert (equal to 1). */
+	uint32_t cpyts                        : 1;  /**< Config PHY TX swing. Indicates the voltage level that the PHY should drive. When set to 1,
+                                                         indicates full swing. When set to 0, indicates low swing. */
+	uint32_t dsc                          : 1;  /**< Directed speed change. A write of 1 initiates a speed change.
+                                                         When the speed change occurs, the controller will clear the contents of this field. */
+	uint32_t alaneflip                    : 1;  /**< Enable auto flipping of the lanes. */
+	uint32_t pdetlane                     : 3;  /**< Predetermined lane for auto flip. This field defines which
+                                                         physical lane is connected to logical Lane0 by the flip
+                                                         operation performed in detect.
+                                                           0x0 = Auto flipping not supported.
+                                                           0x1 = Connect logical Lane0 to physical lane 1.
+                                                           0x2 = Connect logical Lane0 to physical lane 3.
+                                                           0x3 = Connect logical Lane0 to physical lane 7.
+                                                           0x4 = Connect logical Lane0 to physical lane 15.
+                                                           0x5 - 0x7 = Reserved. */
+	uint32_t nlanes                       : 5;  /**< Predetermined number of lanes.  Defines the number of
+                                                         lanes which are connected and not bad. Used to limit the
+                                                         effective link width to ignore "broken" or "unused" lanes that
+                                                         detect a receiver. Indicates the number of lanes to check for
+                                                         exit from electrical idle in Polling.Active and L2.Idle.
+                                                         0x1 = 1 lane.
+                                                         0x2 = 2 lanes.
+                                                         0x3 = 3 lanes.
+                                                         - ...
+                                                         0x8 = 8 lanes.
+                                                         0x9-0x1F = Reserved.
+                                                         When there are unused lanes in the system, then this value must reflect the
+                                                         number of lanes. PCIEEP()_CFG452[LME] must also be changed likewise. */
+	uint32_t n_fts                        : 8;  /**< N_FTS. Sets the number of fast training sequences (N_FTS) that the core advertises as its
+                                                         N_FTS during GEN2 Link training. This value is used to inform the link partner about the
+                                                         PHY's ability to recover synchronization after a low power state.
+                                                         Do not set [N_FTS] to zero; doing so can cause the LTSSM to go into the recovery
+                                                         state when exiting from L0s. */
+#else
+	uint32_t n_fts                        : 8;
+	uint32_t nlanes                       : 5;
+	uint32_t pdetlane                     : 3;
+	uint32_t alaneflip                    : 1;
+	uint32_t dsc                          : 1;
+	uint32_t cpyts                        : 1;
+	uint32_t ctcrb                        : 1;
+	uint32_t s_d_e                        : 1;
+	uint32_t reserved_21_31               : 11;
+#endif
+	} cn78xx;
+	struct cvmx_pciercx_cfg515_cn61xx     cn78xxp1;
+	struct cvmx_pciercx_cfg515_cn61xx     cnf71xx;
+	struct cvmx_pciercx_cfg515_cn78xx     cnf75xx;
 };
 typedef union cvmx_pciercx_cfg515 cvmx_pciercx_cfg515_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
index 90d9e4078e9a..51b0385ad314 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
index 1cf50ce7c4d9..a0a3c23819fe 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 5364357469a3..b8fb33b62391 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -3333,7 +3333,7 @@ union cvmx_pemx_eco {
 	struct cvmx_pemx_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< N/A */
+	uint64_t eco_rw                       : 8;  /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -3426,12 +3426,13 @@ typedef union cvmx_pemx_flr_pf0_vf_stopreq cvmx_pemx_flr_pf0_vf_stopreq_t;
  * STOPREQ mimics the behavior of PCIEEP()_CFG001[ME] for outbound requests that will
  * master the PCIe bus (P and NP).
  *
- * Note that STOPREQ will have no effect on completions returned by CNXXXX over the S2M,
+ * STOPREQ will have no effect on completions returned by CNXXXX over the S2M,
  * nor on M2S traffic.
  *
- * Note that when a PF()_STOPREQ is set, none of the associated
- * PEM()_FLR_PF()_VF_STOPREQ[VF_STOPREQ]
- * will be set.
+ * When a PF()_STOPREQ is set, none of the associated
+ * PEM()_FLR_PF()_VF_STOPREQ[VF_STOPREQ] will be set.
+ *
+ * STOPREQ is reset when the MAC is reset, and is not reset after a chip soft reset.
  */
 union cvmx_pemx_flr_pf_stopreq {
 	uint64_t u64;
@@ -4420,7 +4421,7 @@ union cvmx_pemx_tlp_credits {
                                                             1 2-ln PEM    n     2             0xFF
                                                          </pre> */
 	uint64_t sli_np                       : 8;  /**< TLP 8B credits for nonposted TLPs in the SLI. Legal values are 0x4 to
-                                                         0x20. Pairs of PEMs share a single SLI interface.  When both PEM0 and PEM1
+                                                         0x20. Pairs of PEMs share a single SLI interface.  When both PEM(0) and PEM(1)
                                                          are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. The
                                                          reset value for this register assumes the minimum (e.g. 2-lane)
                                                          configuration. This ensures that the total allocated credits does not
@@ -4438,7 +4439,7 @@ union cvmx_pemx_tlp_credits {
                                                             1 2-ln PEM     n    2             0x20
                                                          </pre> */
 	uint64_t sli_p                        : 8;  /**< TLP 8B credits for Posted TLPs in the SLI. Legal values are 0x24 to 0xFF. Pairs
-                                                         of PEMs share a single SLI interface. Wnen both PEM(0) and PEM(1)
+                                                         of PEMs share a single SLI interface. When both PEM(0) and PEM(1)
                                                          are configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. The reset
                                                          value for this register assumes the minimum (e.g. 2-lane) configuration.
                                                          This ensures the total allocated credits does not oversubscribe the SLI.
diff --git a/arch/mips/include/asm/octeon/cvmx-pescx-defs.h b/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
index 0b5fd73a6223..d88ef4f16f48 100644
--- a/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pip-defs.h b/arch/mips/include/asm/octeon/cvmx-pip-defs.h
index 7ea4b90edb10..069c5a9b6bd5 100644
--- a/arch/mips/include/asm/octeon/cvmx-pip-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pip-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 98e45feef8fe..f757a4263f10 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1908,7 +1908,7 @@ union cvmx_pki_clx_pcamx_termx {
                                                          _ [TERM1]<n>=1, [TERM0]<n>=0: Match when data<n> == 1.
                                                          _ [TERM1]<n>=1, [TERM0]<n>=1: Reserved. */
 	uint64_t style0                       : 8;  /**< Previous interim style. The style that must have been calculated by the port
-                                                         PKI_CL()_PKIND()_STYLE[STYLE] or as modified by previous CAM hits's
+                                                         PKI_CL()_PKIND()_STYLE[STYLE] or as modified by previous CAM hits'
                                                          PKI_CL()_PCAM()_ACTION()[STYLE_ADD]. This is used to form AND style matches.
                                                          The field value is ternary, where each bit matches as follows:
                                                          _ [STYLE1]<n>=0, [STYLE0]<n>=0: Always match; data<n> don't care.
@@ -1963,7 +1963,7 @@ union cvmx_pki_clx_pkindx_cfg {
                                                          1 = MPLS label stacks are parsed and skipped over. */
 	uint64_t inst_hdr                     : 1;  /**< INST header. When set, a PKI_INST_HDR_S is present PKI_CL()_PKIND()_SKIP[INST_SKIP]
                                                          bytes into the packet received by PKI. */
-	uint64_t lg_custom                    : 1;  /**< Reserved. */
+	uint64_t lg_custom                    : 1;  /**< Enable parsing LG_CUSTOM layers. */
 	uint64_t fulc_en                      : 1;  /**< Enable Fulcrum tag parsing.
                                                          0 = Any Fulcrum header is ignored.
                                                          1 = Fulcrum header is parsed.
@@ -2059,9 +2059,10 @@ union cvmx_pki_clx_pkindx_l2_custom {
                                                          0 = Disable custom L2 header extraction.
                                                          1 = Enable custom L2 header extraction. */
 	uint64_t reserved_8_14                : 7;
-	uint64_t offset                       : 8;  /**< Scan offset. Pointer to first byte of 32-bit custom extraction header, as absolute number
-                                                         of bytes from beginning of packet. If PTP_MODE, the 8-byte timestamp is prepended to the
-                                                         packet, and must be included in counting offset bytes. */
+	uint64_t offset                       : 8;  /**< Scan offset. Pointer to first byte of 32-bit custom extraction header, as
+                                                         absolute number of bytes from beginning of packet. Must be even. If PTP_MODE,
+                                                         the 8-byte timestamp is prepended to the packet, and must be included in
+                                                         counting offset bytes. */
 #else
 	uint64_t offset                       : 8;
 	uint64_t reserved_8_14                : 7;
@@ -2092,7 +2093,7 @@ union cvmx_pki_clx_pkindx_lg_custom {
 	uint64_t offset                       : 8;  /**< Scan offset. Pointer to first byte of 32-bit custom extraction header, as
                                                          relative number of bytes from PKI_WQE_S[LCPTR], PKI_WQE_S[LDPTR],
                                                          PKI_WQE_S[LEPTR], PKI_WQE_S[LFPTR], as selected by
-                                                         PKI_CL()_PKIND()_CFG[LG_CUSTOM_LAYER]. */
+                                                         PKI_CL()_PKIND()_CFG[LG_CUSTOM_LAYER]. Must be even. */
 #else
 	uint64_t offset                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -3208,7 +3209,7 @@ union cvmx_pki_gen_int {
                                                          bit can be set when the previous reported bit is cleared. Also see PKI_PKT_ERR. Throws
                                                          PKI_INTSN_E::PKI_GEN_SOP. */
 	uint64_t bckprs                       : 1;  /**< PKI asserted backpressure. Set when PKI was unable to accept the next valid data from
-                                                         BGX/SRIO/DPI/LBK etc. over X2P due to all internal resources being used up, and PKI will
+                                                         BGX, SRIO, DPI, LBK, etc. over X2P due to all internal resources being used up, and PKI will
                                                          backpressure X2P. Throws PKI_INTSN_E::PKI_GEN_BCKPRS. */
 	uint64_t crcerr                       : 1;  /**< PKI calculated bad CRC in the L2 frame. Throws PKI_INTSN_E::PKI_GEN_CRCERR. */
 	uint64_t pktdrp                       : 1;  /**< Packet dropped due to QOS. If the QOS algorithm decides to drop a packet, PKI asserts this
@@ -4747,12 +4748,12 @@ union cvmx_pki_tag_secret {
 	struct cvmx_pki_tag_secret_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dst6                         : 16; /**< Secret for the destination tuple IPv6 tag CRC calculation. Typically identical to SRC6 to
-                                                         insure tagging is symmetric between source/destination flows. Typically different from DST
+                                                         ensure tagging is symmetric between source/destination flows. Typically different from DST
                                                          for maximum security. */
 	uint64_t src6                         : 16; /**< Secret for the source tuple IPv6 tag CRC calculation. Typically different from SRC for
                                                          maximum security. */
-	uint64_t dst                          : 16; /**< Secret for the destination tuple tag CRC calculation. Typically identical to DST6 to
-                                                         insure tagging is symmetric between source/destination flows. */
+	uint64_t dst                          : 16; /**< Secret for the destination tuple tag CRC calculation. Typically identical to SRC to
+                                                         ensure tagging is symmetric between source/destination flows. */
 	uint64_t src                          : 16; /**< Secret for the source tuple tag CRC calculation. */
 #else
 	uint64_t src                          : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 44f8454f25f1..689b1447eae1 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -3743,7 +3743,7 @@ union cvmx_pko_dqx_fifo {
 	struct cvmx_pko_dqx_fifo_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t p_con                        : 1;  /**< parent connect. Asserted when DQ is connected to its parent. */
+	uint64_t p_con                        : 1;  /**< Parent connect. Asserted when DQ is connected to its parent. */
 	uint64_t head                         : 7;  /**< DQ FIFO head pointer. */
 	uint64_t tail                         : 7;  /**< DQ FIFO tail pointer. */
 #else
@@ -5123,20 +5123,20 @@ union cvmx_pko_l1_sqx_topology {
 	uint64_t link                         : 5;  /**< Link index. Selects the MAC or NULL FIFO used by the L1 SQ.
                                                          Legal [LINK] values:
                                                          <pre>
-                                                                          Relevant
-                                                           [LINK]    PKO_MAC()_CFG CSR    Description
-                                                          -------------------------------------------------
-                                                             0         PKO_MAC0_CFG      LBK loopback
-                                                             1         PKO_MAC1_CFG      DPI packet output
-                                                             2         PKO_MAC2_CFG      BGX0  logical MAC 0
-                                                             3         PKO_MAC3_CFG      BGX0  logical MAC 1
-                                                             4         PKO_MAC4_CFG      BGX0  logical MAC 2
-                                                             5         PKO_MAC5_CFG      BGX0  logical MAC 3
-                                                             6         PKO_MAC6_CFG      SRIO0 logical MAC 0
-                                                             7         PKO_MAC7_CFG      SRIO0 logical MAC 1
-                                                             8         PKO_MAC8_CFG      SRIO1 logical MAC 0
-                                                             9         PKO_MAC9_CFG      SRIO1 logical MAC 1
-                                                            10            None           NULL FIFO
+                                                                        Relevant
+                                                          [LINK]   PKO_MAC()_CFG CSR   Description
+                                                          ------   -----------------   ------------------
+                                                            0         PKO_MAC0_CFG     LBK loopback
+                                                            1         PKO_MAC1_CFG     DPI packet output
+                                                            2         PKO_MAC2_CFG     BGX0  logical MAC 0
+                                                            3         PKO_MAC3_CFG     BGX0  logical MAC 1
+                                                            4         PKO_MAC4_CFG     BGX0  logical MAC 2
+                                                            5         PKO_MAC5_CFG     BGX0  logical MAC 3
+                                                            6         PKO_MAC6_CFG     SRIO0 logical MAC 0
+                                                            7         PKO_MAC7_CFG     SRIO0 logical MAC 1
+                                                            8         PKO_MAC8_CFG     SRIO1 logical MAC 0
+                                                            9         PKO_MAC9_CFG     SRIO1 logical MAC 1
+                                                           10            None          NULL FIFO
                                                          </pre>
                                                          When a MAC is used by the L1 SQ, [LINK] must be unique relative to
                                                          other [LINK]s. [LINK] should be 14 when the L1 SQ is not used. */
@@ -8063,8 +8063,8 @@ typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
  * to 31) prior to reconfiguration of any of the other bits.
  *
  * <pre>
- *   CSR Name        Associated MAC
- *   ---------------------------------
+ *   CSR Name       Associated MAC
+ *   ------------   -------------------
  *   PKO_MAC0_CFG   LBK loopback
  *   PKO_MAC1_CFG   DPI packet output
  *   PKO_MAC2_CFG   BGX0  logical MAC 0
@@ -8163,7 +8163,7 @@ union cvmx_pko_mci1_cred_cntx {
 	struct cvmx_pko_mci1_cred_cntx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t cred_cnt                     : 13; /**< Credit count. */
+	uint64_t cred_cnt                     : 13; /**< Credit count.  Will be reset with a write to the corrsponding PKO_MCI1_MAX_CRED. */
 #else
 	uint64_t cred_cnt                     : 13;
 	uint64_t reserved_13_63               : 51;
@@ -8185,7 +8185,8 @@ union cvmx_pko_mci1_max_credx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t max_cred_lim                 : 12; /**< Max credit limit.  Should be set to (MAC_CREDIT) / 16, where MAC_CREDIT is
-                                                         the size of the MAC FIFO. */
+                                                         the size of the MAC FIFO.  A write to this register will reset the
+                                                         corresponding PKO_MCI1_CRED_CNT. */
 #else
 	uint64_t max_cred_lim                 : 12;
 	uint64_t reserved_12_63               : 52;
@@ -16232,7 +16233,9 @@ union cvmx_pko_ptf_iobp_cfg {
 	uint64_t iobp1_ds_opt                 : 1;  /**< Optimize IOBP1 requests when data is to be dropped (NULL, RED, SEND_HDR_S[DS]=1). */
 	uint64_t iobp0_l2_allocate            : 1;  /**< Determine L2 allocation (1 = no allocation = LDT, 0 = allocation = LDD) when reading
                                                          post-PKO_SEND_JUMP_S descriptors via IOBP0 requests. */
-	uint64_t iobp1_magic_addr             : 35; /**< IOBP1 read address to be used for any dummy reads */
+	uint64_t iobp1_magic_addr             : 35; /**< IOBP1 read address to be used for any dummy reads. This must be a valid IOVA of
+                                                         a scratch cache line. PKO will read this address to insure ordering for any PKO
+                                                         send command which does not otherwise have a data fetch associated with it. */
 	uint64_t max_read_size                : 7;  /**< Maximum number of IOBP1 read requests outstanding to be allowed by any given PEB TX FIFO. */
 #else
 	uint64_t max_read_size                : 7;
@@ -16302,7 +16305,7 @@ union cvmx_pko_ptgfx_cfg {
                                                              4    10.0 KB    N/A      N/A      N/A
                                                          </pre>
                                                          Note: 5-7 are illegal [SIZE] values and should not be used.
-                                                         A FIFO labelled N/A in the above table must not be used, and no
+                                                         A FIFO labeled N/A in the above table must not be used, and no
                                                          PKO_MAC()_CFG[FIFO_NUM] should select it. For example,
                                                          if PKO_PTGF(2)_CFG[SIZE]=4, FIFO_NUM 8 is available (with
                                                          10KB), but FIFO_NUMs 9, 10, and 11 are not valid and should
diff --git a/arch/mips/include/asm/octeon/cvmx-pow-defs.h b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
index 38ea05e7aa29..995bca4492a5 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
index e21cb8e54c61..f1d00cbd4bdf 100644
--- a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
@@ -137,8 +137,9 @@ typedef union cvmx_rnm_bist_status cvmx_rnm_bist_status_t;
 /**
  * cvmx_rnm_ctl_status
  *
- * This register is the RNM interrupt-enable register.
+ * RNM_CTL_STATUS = RNM's Control/Status Register
  *
+ * The RNM's interrupt enable register.
  */
 union cvmx_rnm_ctl_status {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 6a7e6b16f01b..a1116c0ef6d3 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -334,7 +334,8 @@ union cvmx_rst_boot {
                                                          'ref-clock speed' should always be 50MHz. */
 	uint64_t reserved_21_23               : 3;
 	uint64_t lboot_oci                    : 3;  /**< Reserved. */
-	uint64_t lboot_ext                    : 6;  /**< Last boot cause mask; resets only with DCOK.
+	uint64_t lboot_ext                    : 6;  /**< For CNF73XX, this field is reserved.
+                                                         For CNF75XX, the last boot cause mask; resets only with DCOK.
                                                          <17> = Warm reset due to Cntl3 link-down or hot-reset.
                                                          <16> = Warm reset due to Cntl2 link-down or hot-reset.
                                                          <15> = Cntl3 reset due to PERST3_L pin.
@@ -510,23 +511,28 @@ union cvmx_rst_ctlx {
 	struct cvmx_rst_ctlx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t prst_link                    : 1;  /**< Controls whether corresponding controller link-down or hot-reset causes the assertion of
-                                                         RST_SOFT_PRST()[SOFT_PRST].
+	uint64_t prst_link                    : 1;  /**< PEM reset on link down.
+                                                         0 = Link-down or hot-reset will set RST_INT[RST_LINK] for the corresponding
+                                                         controller, and (provided properly configured) the link should come back up
+                                                         automatically.
+                                                         1 = Link-down or hot-reset will set RST_INT[RST_LINK] for the corresponding
+                                                         controller, and set RST_SOFT_PRST()[SOFT_PRST]. This will hold the link in reset
+                                                         until software clears RST_SOFT_PRST()[SOFT_PRST].
                                                          A warm/soft reset does not change this field. On cold reset, this field is initialized to
                                                          0. */
 	uint64_t rst_done                     : 1;  /**< Read-only access to controller reset status. RST_DONE is always zero (i.e. the controller
                                                          is held in reset) when:
                                                          * RST_SOFT_PRST()[SOFT_PRST] = 1, or
                                                          * RST_RCV = 1 and PERST*_L pin is asserted. */
-	uint64_t rst_link                     : 1;  /**< Reset link. Controls whether corresponding controller link-down reset or hot reset causes
-                                                         a warm chip reset. On cold reset, this field is initialized as follows:
+	uint64_t rst_link                     : 1;  /**< Reset on link down. When set, a corresponding controller link-down reset or hot
+                                                         reset causes a warm chip reset.
+                                                         On cold reset, this field is initialized as follows:
                                                          _ 0 when RST_CTL()[HOST_MODE] = 1.
                                                          _ 1 when RST_CTL()[HOST_MODE] = 0.
                                                          Note that a link-down or hot-reset event can never cause a warm chip reset when the
                                                          controller is in reset (i.e. can never cause a warm reset when [RST_DONE] = 0). */
 	uint64_t host_mode                    : 1;  /**< Read-only access to the corresponding PEM()_CFG[HOSTMD] field indicating PEMn is root
-                                                         complex (host). For controllers 0 and 2  the initial value is determined by straps. For
-                                                         controllers 1 and 3 this field is initially set as host. */
+                                                         complex (host). */
 	uint64_t reserved_4_5                 : 2;
 	uint64_t rst_drv                      : 1;  /**< Controls whether PERST*_L is driven. A warm/soft reset does not change this field. On cold
                                                          reset, this field is initialized as follows:
@@ -793,7 +799,9 @@ union cvmx_rst_pp_power {
 	uint64_t gate                         : 48; /**< Powerdown enable. When both a bit and the corresponding CIU_PP_RST bit are set, the core
                                                          has voltage removed to save power. In typical operation these bits are setup during
                                                          initialization and PP resets are controlled through CIU_PP_RST. These bits may only be
-                                                         changed when the corresponding core is in reset using CIU_PP_RST. */
+                                                         changed when the corresponding core is in reset using CIU_PP_RST.
+                                                         The upper bits of this field remain accessible but will have no effect if the cores
+                                                         are disabled. The number of bits cleared in CIU_FUSE[FUSE] indicate the number of cores. */
 #else
 	uint64_t gate                         : 48;
 	uint64_t reserved_48_63               : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-sata-defs.h b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
index 25e487cba007..4c3c37ad6681 100644
--- a/arch/mips/include/asm/octeon/cvmx-sata-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -773,7 +773,7 @@ union cvmx_sata_uahc_gbl_cap {
 	uint32_t ssntf                        : 1;  /**< Supports SNotification register. */
 	uint32_t smps                         : 1;  /**< Supports mechanical presence switch. */
 	uint32_t sss                          : 1;  /**< Supports staggered spin-up. */
-	uint32_t salp                         : 1;  /**< Supports agressive link power management. */
+	uint32_t salp                         : 1;  /**< Supports aggressive link power management. */
 	uint32_t sal                          : 1;  /**< Supports activity LED. */
 	uint32_t sclo                         : 1;  /**< Supports command list override. */
 	uint32_t iss                          : 4;  /**< Interface speed support. */
@@ -1804,7 +1804,12 @@ union cvmx_sata_uahc_px_tfd {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
 	uint32_t tferr                        : 8;  /**< Copy of task-file error register. */
-	uint32_t sts                          : 8;  /**< Copy of task-file status register. */
+	uint32_t sts                          : 8;  /**< Copy of task-file status register.
+                                                         <7> = BSY: Indicates the interface is busy.
+                                                         <6:4> = Command specific.
+                                                         <3> = DRQ: Indicates a data transfer is requested.
+                                                         <2:1> = Command specific.
+                                                         <0> = ERR: Indicates an error during the transfer. */
 #else
 	uint32_t sts                          : 8;
 	uint32_t tferr                        : 8;
@@ -1903,7 +1908,7 @@ union cvmx_sata_uctl_ctl {
                                                          SATA()_UCTL_BIST_STATUS. The FULL BIST run takes almost 80,000 host-controller
                                                          clock cycles for the largest RAM. */
 	uint64_t reserved_31_61               : 31;
-	uint64_t a_clk_en                     : 1;  /**< Host-controller clock enable. When set to 1, the host-controller clock is generated. This
+	uint64_t a_clk_en                     : 1;  /**< Host-controller clock enable. When set to one, the host-controller clock is generated. This
                                                          also enables access to UCTL registers 0x30-0xF8. */
 	uint64_t a_clk_byp_sel                : 1;  /**< Select the bypass input to the host-controller clock divider.
                                                          0 = Use the divided coprocessor clock from the A_CLKDIV divider.
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 74e0cea6ce38..bd8bd4b04578 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -4335,51 +4335,75 @@ union cvmx_sli_ciu_int_sum {
 	struct cvmx_sli_ciu_int_sum_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t m3_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 3. This occurs when the window
+	uint64_t m3_un_wi                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported N-TLP for window register from MAC 3. This occurs when
+                                                         the window
                                                          registers are disabled and a window register access occurs.
                                                          This can only be set by a PF and not a VF access.
                                                          This bit is set when SLI_MAC()_PF()_INT_SUM[UN_WI]
                                                          Throws SLI_INTSN_E::SLI_INT_M3_UN_WI. */
-	uint64_t m3_un_b0                     : 1;  /**< Received unsupported N-TLP for Bar 0 from MAC 3. This occurs when the BAR 0 address space
+	uint64_t m3_un_b0                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported N-TLP for Bar 0 from MAC 3. This occurs when the BAR 0
+                                                         address space
                                                          is disabled.
                                                          This can only be set by a PF and not a VF access.
                                                          This bit is set when SLI_MAC()_PF()_INT_SUM[UN_B0]
                                                          Throws SLI_INTSN_E::SLI_INT_M3_UN_B0. */
-	uint64_t m3_up_wi                     : 1;  /**< Received unsupported P-TLP for window register from MAC 3. This occurs when the window
+	uint64_t m3_up_wi                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported P-TLP for window register from MAC 3. This occurs when
+                                                         the window
                                                          registers are disabled and a window register access occurs.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M3_UP_WI. */
-	uint64_t m3_up_b0                     : 1;  /**< Received unsupported P-TLP for Bar 0 from MAC 3. This occurs when the BAR 0 address space
+	uint64_t m3_up_b0                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported P-TLP for Bar 0 from MAC 3. This occurs when the BAR 0
+                                                         address space
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M3_UP_B0. */
-	uint64_t m2_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 2. This occurs when the window
+	uint64_t m2_un_wi                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported N-TLP for window register from MAC 2. This occurs when
+                                                         the window
                                                          registers are disabled and a window register access occurs.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M2_UN_WI. */
-	uint64_t m2_un_b0                     : 1;  /**< Received unsupported N-TLP for Bar 0 from MAC 2. This occurs when the BAR 0 address space
+	uint64_t m2_un_b0                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported N-TLP for Bar 0 from MAC 2. This occurs when the BAR 0
+                                                         address space
                                                          is disabled.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M2_UN_B0. */
-	uint64_t m2_up_wi                     : 1;  /**< Received unsupported P-TLP for window register from MAC 2. This occurs when the window
+	uint64_t m2_up_wi                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported P-TLP for window register from MAC 2. This occurs when
+                                                         the window
                                                          registers are disabled and a window register access occurs.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M2_UP_WI. */
-	uint64_t m2_up_b0                     : 1;  /**< Received unsupported P-TLP for Bar 0 from MAC 2. This occurs when the BAR 0 address space
+	uint64_t m2_up_b0                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported P-TLP for Bar 0 from MAC 2. This occurs when the BAR 0
+                                                         address space
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M2_UP_B0. */
-	uint64_t m1_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 1. This occurs when the window
+	uint64_t m1_un_wi                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported N-TLP for window register from MAC 1. This occurs when
+                                                         the window
                                                          registers are disabled and a window register access occurs.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M1_UN_WI. */
-	uint64_t m1_un_b0                     : 1;  /**< Received unsupported N-TLP for Bar 0 from MAC 1. This occurs when the BAR 0 address space
+	uint64_t m1_un_b0                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported N-TLP for Bar 0 from MAC 1. This occurs when the BAR 0
+                                                         address space
                                                          is disabled.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M1_UN_B0. */
-	uint64_t m1_up_wi                     : 1;  /**< Received unsupported P-TLP for window register from MAC 1. This occurs when the window
+	uint64_t m1_up_wi                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported P-TLP for window register from MAC 1. This occurs when
+                                                         the window
                                                          registers are disabled and a window register access occurs.
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M1_UP_WI. */
-	uint64_t m1_up_b0                     : 1;  /**< Received unsupported P-TLP for Bar 0 from MAC 1. This occurs when the BAR 0 address space
+	uint64_t m1_up_b0                     : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, received unsupported P-TLP for Bar 0 from MAC 1. This occurs when the BAR 0
+                                                         address space
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M1_UP_B0. */
 	uint64_t m0_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 0. This occurs when the window
@@ -4397,39 +4421,57 @@ union cvmx_sli_ciu_int_sum {
 	uint64_t m0_up_b0                     : 1;  /**< Received unsupported P-TLP for Bar 0 from MAC 0. This occurs when the BAR 0 address space
                                                          This can only be set by a PF and not a VF access.
                                                          Throws SLI_INTSN_E::SLI_INT_M0_UP_B0. */
-	uint64_t m3p0_pppf_err                : 1;  /**< On SLI_PORT_E::SRIO1 PF0, when an error response is received for a PF PP transaction read,
+	uint64_t m3p0_pppf_err                : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::SRIO1 PF0, when an error response is received for a PF PP
+                                                         transaction read,
                                                          this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M3P0_PPPF_ERR. */
-	uint64_t m3p0_pktpf_err               : 1;  /**< On SLI_PORT_E::SRIO1 PF0, When an error response is received for a PF packet transaction
+	uint64_t m3p0_pktpf_err               : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::SRIO1 PF0, When an error response is received for a PF packet
+                                                         transaction
                                                          read or a doorbell overflow for a ring associated with this PF occurs, this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M3P0_PKTPF_ERR. */
-	uint64_t m3p0_dmapf_err               : 1;  /**< On SLI_PORT_E::SRIO1 PF0, when an error response is received for a PF DMA transaction
+	uint64_t m3p0_dmapf_err               : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::SRIO1 PF0, when an error response is received for a PF DMA
+                                                         transaction
                                                          read,
                                                          this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M3P0_DMAPF_ERR. */
-	uint64_t m2p0_pppf_err                : 1;  /**< On SLI_PORT_E::SRIO0 PF0, when an error response is received for a PF PP transaction read,
+	uint64_t m2p0_pppf_err                : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::SRIO0 PF0, when an error response is received for a PF PP
+                                                         transaction read,
                                                          this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M2P0_PPPF_ERR. */
 	uint64_t m2p0_ppvf_err                : 1;  /**< This interrupt should not occur.
                                                          Throws SLI_INTSN_E::SLI_INT_M2P0_PPVF_ERR. */
-	uint64_t m2p0_pktpf_err               : 1;  /**< On SLI_PORT_E::SRIO0 PF0, When an error response is received for a PF packet transaction
+	uint64_t m2p0_pktpf_err               : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::SRIO0 PF0, When an error response is received for a PF packet
+                                                         transaction
                                                          read or a doorbell overflow for a ring associated with this PF occurs, this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M2P0_PKTPF_ERR. */
 	uint64_t m2p0_pktvf_err               : 1;  /**< This interrupt should not occur.
                                                          Throws SLI_INTSN_E::SLI_INT_M2P0_PKTVF_ERR. */
-	uint64_t m2p0_dmapf_err               : 1;  /**< On SLI_PORT_E::SRIO0 PF0, when an error response is received for a PF DMA transaction
+	uint64_t m2p0_dmapf_err               : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::SRIO0 PF0, when an error response is received for a PF DMA
+                                                         transaction
                                                          read,
                                                          this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M2P0_DMAPF_ERR. */
 	uint64_t m2p0_dmavf_err               : 1;  /**< This interrupt should not occur.
                                                          Throws SLI_INTSN_E::SLI_INT_M2P0_DMAVF_ERR. */
-	uint64_t m1p0_pppf_err                : 1;  /**< On SLI_PORT_E::PEM1 PF0, when an error response is received for a PF PP transaction read,
+	uint64_t m1p0_pppf_err                : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::PEM1 PF0, when an error response is received for a PF PP
+                                                         transaction read,
                                                          this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M1P0_PPPF_ERR. */
-	uint64_t m1p0_pktpf_err               : 1;  /**< On SLI_PORT_E::PEM1 PF0, When an error response is received for a PF packet transaction
+	uint64_t m1p0_pktpf_err               : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::PEM1 PF0, When an error response is received for a PF packet
+                                                         transaction
                                                          read or a doorbell overflow for a ring associated with this PF occurs, this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M1P0_PKTPF_ERR. */
-	uint64_t m1p0_dmapf_err               : 1;  /**< On SLI_PORT_E::PEM1 PF0, when an error response is received for a PF DMA transaction read,
+	uint64_t m1p0_dmapf_err               : 1;  /**< For CNF73XX, this interrupt should not occur.
+                                                         For CNF75XX, on SLI_PORT_E::PEM1 PF0, when an error response is received for a PF DMA
+                                                         transaction read,
                                                          this bit is set.
                                                          Throws SLI_INTSN_E::SLI_INT_M1P0_DMAPF_ERR. */
 	uint64_t m0p1_pppf_err                : 1;  /**< This interrupt cannot occur.
@@ -4721,7 +4763,9 @@ union cvmx_sli_ctl_status {
 	struct cvmx_sli_ctl_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t m2s1_ncbi                    : 4;  /**< Contains the IOBI that traffic (inbound BAR1/BAR2 posted writes, inbound BAR1/BAR2
+	uint64_t m2s1_ncbi                    : 4;  /**< For CNF73XX, this field is reserved.
+                                                         For CNF75XX, contains the IOBI that traffic (inbound BAR1/BAR2 posted writes, inbound
+                                                         BAR1/BAR2
                                                          non-posted reads, outbound BAR1/BAR2 completions, and inbound CPU completions)
                                                          from SLI_PORT_E::SRIO0 and SLI_PORT_E::SRIO1 is placed on. Values 2-15 are reserved. */
 	uint64_t m2s0_ncbi                    : 4;  /**< Contains the IOBI that traffic  (inbound BAR1/BAR2 posted writes, inbound BAR1/BAR2
@@ -4851,9 +4895,12 @@ union cvmx_sli_data_out_cnt {
 	struct cvmx_sli_data_out_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
-	uint64_t p1_ucnt                      : 16; /**< FIFO1 unload count. This counter is incremented by 1 every time a word is removed from
+	uint64_t p1_ucnt                      : 16; /**< For CNF73XX, reserved.
+                                                         For CNF75XX, FIFO1 unload count. This counter is incremented by 1 every time a word is removed from
                                                          data out FIFO1, whose count is shown in P1_FCNT. */
-	uint64_t p1_fcnt                      : 6;  /**< FIFO1 data out count. Number of address data words presently buffered in the FIFO1. MACs
+	uint64_t p1_fcnt                      : 6;  /**< For CNF73XX, reserved.
+                                                         For CNF75XX, FIFO1 data out count. Number of address data words presently
+                                                         buffered in the FIFO1. MACs
                                                          associated with FIFO1: SRIO0, SRIO1. */
 	uint64_t p0_ucnt                      : 16; /**< FIFO0 unload count. This counter is incremented by 1 every time a word is removed from
                                                          data out FIFO0, whose count is shown in P0_FCNT. */
@@ -8882,7 +8929,7 @@ typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_
  * cvmx_sli_msix_pba0
  *
  * The MSI-X pending bit array cannot be burst read.
- * In SRIO-V mode, a VF will find its pending completion interrupts in bit
+ * In SR-IOV mode, a VF will find its pending completion interrupts in bit
  * positions [(RPVF-1):0]. If RPVF<64, bits [63:RPVF] are returned as zero.
  *
  * Each VF can read their own pending completion interrupts based on the ring/VF
@@ -8909,7 +8956,7 @@ typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_
  * error interrupt in bit position [(TNR+1)]. Bits [63:(TNR+2)] are returned as zero.
  * When SLI_PKT_MAC()_PF()_RINFO[TRS]<63, SLI_MSIX_PBA1 is not used and returns zeros.
  *
- * If SRIO-V Mode is off there is no virtual function support, but the PF can configure up to 65
+ * If SR-IOV Mode is off there is no virtual function support, but the PF can configure up to 65
  * entries (up to 64 DPI Packet Rings plus 1 PF ring) for itself.
  */
 union cvmx_sli_msix_pba0 {
@@ -9400,7 +9447,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
 	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_NSR] is ADDRTYPE<1> for First Direct and
                                                          Gather DPTR reads. ADDRTYPE<1> is the no-snoop attribute for PCIe.
-                                                         ADDRTYPE<1> helps select an SRIO()_S2M_TYPE() entry with sRIO.
+                                                         For CNF75XXX, ADDRTYPE<1> helps select an SRIO()_S2M_TYPE() entry with sRIO.
                                                          If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<61> for First Direct and
                                                          Gather DPTR reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when
                                                          [USE_CSR]=0.) */
@@ -9411,8 +9458,8 @@ union cvmx_sli_pktx_input_control {
                                                          Gather DPTR reads. (ES<1:0> comes from DPTR<63:62> in these cases when
                                                          [USE_CSR]=0.) */
 	uint64_t d_ror                        : 1;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_ROR] is ADDRTYPE<0> for First Direct and
-                                                         Gather DPTR reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. It helps
-                                                         select an SRIO()_S2M_TYPE() entry with sRIO.
+                                                         Gather DPTR reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe.
+                                                         For CNF75XX, ADDRTYPE<0> helps select an SRIO()_S2M_TYPE() entry with sRIO.
                                                          If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<60> for First Direct and
                                                          Gather DPTR reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when
                                                          [USE_CSR]=0.) */
diff --git a/arch/mips/include/asm/octeon/cvmx-smix-defs.h b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
index bd72695f5f2d..4f615d24d658 100644
--- a/arch/mips/include/asm/octeon/cvmx-smix-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
@@ -428,7 +428,7 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
  *
  * This register determines the SMI timing characteristics.
  * If software wants to change SMI CLK timing parameters ([SAMPLE]/[SAMPLE_HI]), software
- * must delay the SMI_()_CLK CSR write by at least 512 coprocessor-clocks after the
+ * must delay the SMI_()_CLK CSR write by at least 512 coprocessor-clock cycles after the
  * previous SMI operation is finished.
  */
 union cvmx_smix_clk {
@@ -623,8 +623,8 @@ union cvmx_smix_en {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t en                           : 1;  /**< SMI/MDIO interface enable:
-                                                         1 = Enable interface.
-                                                         0 = Disable interface: no transactions, no SMIn_MDC transitions. */
+                                                         0 = Disable interface: no transactions, no SMIn_MDC transitions.
+                                                         1 = Enable interface. */
 #else
 	uint64_t en                           : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-spemx-defs.h b/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
index d0e733fed517..29c3995fcee3 100644
--- a/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1252,7 +1252,7 @@ union cvmx_spemx_eco {
 	struct cvmx_spemx_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< N/A */
+	uint64_t eco_rw                       : 8;  /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -1412,12 +1412,13 @@ typedef union cvmx_spemx_flr_pf2_vfx_stopreq cvmx_spemx_flr_pf2_vfx_stopreq_t;
  * STOPREQ mimics the behavior of PCIEEP()_CFG001[ME] for outbound requests that will
  * master the PCIe bus (P and NP).
  *
- * Note that STOPREQ will have no effect on completions returned by CNXXXX over the S2M,
+ * STOPREQ will have no effect on completions returned by CNXXXX over the S2M,
  * nor on M2S traffic.
  *
- * Note that when a PF()_STOPREQ is set, none of the associated
- * PEM()_FLR_PF()_VF_STOPREQ[VF_STOPREQ]
- * will be set.
+ * When a PF()_STOPREQ is set, none of the associated
+ * PEM()_FLR_PF()_VF_STOPREQ[VF_STOPREQ] will be set.
+ *
+ * STOPREQ is reset when the MAC is reset, and is not reset after a chip soft reset.
  */
 union cvmx_spemx_flr_pf_stopreq {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-spxx-defs.h b/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
index 34f781341aab..80ffc37d6eda 100644
--- a/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
index 97133da5c137..b8bed9109690 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
index 12afb1eb8bb4..6c73d4a413ee 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-srxx-defs.h b/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
index a54f7b7dfe37..d71cdd08cf3c 100644
--- a/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 30918e207d6f..173fd1d5c192 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -2224,9 +2224,14 @@ union cvmx_sso_err0 {
                                                          SSO_GRP()_IAQ_THR[RSVD_THR] = 0. Throws SSO_INTSN_E::SSO_ERR0_GRPDIS. */
 	uint64_t bfp                          : 1;  /**< Bad-fill-packet error. The WAE VLD_CRC field was incorrect, or the XAQ next address was
                                                          zero. Throws SSO_INTSN_E::SSO_ERR0_BFP. */
-	uint64_t awe                          : 1;  /**< Out-of-memory error. (ADDWQ request is dropped.) Throws SSO_INTSN_E::SSO_ERR0_AWE. */
-	uint64_t fpe                          : 1;  /**< Free-page error. The free page error bit asserts when a new FPA page is requested and FPA
-                                                         indicates there are no remaining free pages. Throws SSO_INTSN_E::SSO_ERR0_FPE. */
+	uint64_t awe                          : 1;  /**< Out-of-memory error. SSO has dropped some add-work as a result, and this should
+                                                         be considered fatal to SSO. Throws SSO_INTSN_E::SSO_ERR0_AWE.
+                                                         This may indicate software did not allocate sufficient FPA buffers to cover all
+                                                         possible outstanding work. */
+	uint64_t fpe                          : 1;  /**< Free-page error. The free page error bit asserts when a new FPA page is
+                                                         requested and FPA indicates there are no remaining free pages. SSO will keep
+                                                         attempting to allocate pages, and if the situation persists the more critical
+                                                         [AWE] error will be indicated. Throws SSO_INTSN_E::SSO_ERR0_FPE. */
 #else
 	uint64_t fpe                          : 1;
 	uint64_t awe                          : 1;
@@ -2625,10 +2630,10 @@ union cvmx_sso_grpx_iaq_thr {
                                                          To ensure full streaming performance to all cores, should be at least 208. Must not be
                                                          changed after traffic is sent to this group. */
 	uint64_t reserved_13_31               : 19;
-	uint64_t rsvd_thr                     : 13; /**< Reserved threshold for this internal group queue. Should be at least 1 for any groups that
-                                                         must make forward progress when other group's work is pending. Updates to this field must
-                                                         also update SSO_AW_ADD[RSVD_FREE]. Must not be changed after traffic is sent to this
-                                                         group. */
+	uint64_t rsvd_thr                     : 13; /**< Threshold for reserved entries for this internal group queue. Should be at least
+                                                         0x1 for any groups that must make forward progress when other group's work is
+                                                         pending. Updates to this field must also update SSO_AW_ADD[RSVD_FREE]. Must not
+                                                         be changed after traffic is sent to this group. */
 #else
 	uint64_t rsvd_thr                     : 13;
 	uint64_t reserved_13_31               : 19;
@@ -2843,9 +2848,10 @@ union cvmx_sso_grpx_taq_thr {
                                                          if persistently backpressured by IOBI. Must not be changed after traffic is sent to this
                                                          group. */
 	uint64_t reserved_11_31               : 21;
-	uint64_t rsvd_thr                     : 11; /**< Reserved threshold for this transitory admission queue, in buffers of 13 entries. Must be
-                                                         at least 3 buffers for any groups that are to be used. Changes to this field must also
-                                                         update SSO_TAQ_ADD[RSVD_FREE]. Must not be changed after traffic is sent to this group. */
+	uint64_t rsvd_thr                     : 11; /**< Threshold for reserved entries for this transitory admission queue, in buffers
+                                                         of 13 entries. Must be at least 3 buffers for any groups that are to be
+                                                         used. Changes to this field must also update SSO_TAQ_ADD[RSVD_FREE]. Must not be
+                                                         changed after traffic is sent to this group. */
 #else
 	uint64_t rsvd_thr                     : 11;
 	uint64_t reserved_11_31               : 21;
diff --git a/arch/mips/include/asm/octeon/cvmx-stxx-defs.h b/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
index e62c5703a104..9238d93717ed 100644
--- a/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
index 1f5937043403..b76460edf650 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 9170b0c60229..45f656dc5131 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1964,9 +1964,9 @@ union cvmx_usbdrdx_uahc_depcmdx {
                                                              commands:
                                                              _  - [22:16]: Transfer resource index (XferRscIdx). The hardware-assigned
                                                                transfer resource index for the transfer, which was returned
-                                                               in response to the Start Transfer command. The application
-                                                               software-assigned transfer resource index for a Start New
-                                                               Configuration command.
+                                                               in response to the start transfer command. The application
+                                                               software-assigned transfer resource index for a start new
+                                                               configuration command.
                                                          When this register is read:
                                                              For XferNotReady, XferComplete, and stream events on bulk endpoints:
                                                              _  - [31:16]: StreamID. Applies only to bulk endpoints that support streams. This
@@ -2168,7 +2168,7 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
 /**
  * cvmx_usbdrd#_uahc_devten
  *
- * This register controls the generation of Device-Specific events.
+ * This register controls the generation of device-specific events.
  * If an enable bit is set to 0, the event will not be generated.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
@@ -2386,9 +2386,9 @@ union cvmx_usbdrdx_uahc_dsts {
                                                             0x4 = Disconnected state (Default state).
                                                             0x5 = Early Suspend state.
                                                             others: Reserved.
-                                                         The link state resume/reset indicates that the core received a resume or
-                                                         USB reset request from the host while the link was in hibernation. Software
-                                                         must write '8' (recovery) to the USBDRD()_UAHC_DCTL[ULSTCHNGREQ] field to acknowledge
+                                                         The link state resume/reset indicates that the core received a resume or USB
+                                                         reset request from the host while the link was in hibernation. Software must
+                                                         write 0x8 (recovery) to the USBDRD()_UAHC_DCTL[ULSTCHNGREQ] field to acknowledge
                                                          the resume/reset request. */
 	uint32_t rxfifoempty                  : 1;  /**< RxFIFO Empty Indication. */
 	uint32_t soffn                        : 14; /**< Frame/MicroFrame number of the received SOF.
@@ -2396,7 +2396,7 @@ union cvmx_usbdrdx_uahc_dsts {
                                                            <16:6> = Frame number.
                                                            <5:3> = Microframe number.
                                                          When the core is operating at full-speed:
-                                                           <16:14> = Not used, software can ignore these 3 bits.
+                                                           <16:14> = Not used, software can ignore these three bits.
                                                            <13:3> = Frame number. */
 	uint32_t connectspd                   : 3;  /**< Connected speed.
                                                          Indicates the speed at which the controller core has come up after speed
@@ -2526,8 +2526,8 @@ typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
  * associated with all active transactions. It is this address that is reported in
  * USBDRD()_UAHC_GBUSERRADDR when a bus error occurs. For example, if the host controller
  * initiates a DMA
- * transfer to write 1 k of packet data starting at buffer address 0xABCD0000, and this DMA is
- * broken up into multiple 256 B bursts on the AXI, then if a bus error occurs on any of these
+ * transfer to write 1k of packet data starting at buffer address 0xABCD0000, and this DMA is
+ * broken up into multiple 256B bursts on the AXI, then if a bus error occurs on any of these
  * associated AXI transfers, USBDRD()_UAHC_GBUSERRADDR reflects the DMA start address of
  * 0xABCD0000
  * regardless of which AXI transaction received the error.
@@ -2584,7 +2584,7 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          needs to programmed is: power down scale = 10500/16 = 657 (rounded up; and fastest
                                                          frequency used). */
 	uint32_t masterfiltbypass             : 1;  /**< Master filter bypass. Not relevant for Cavium's configuration. */
-	uint32_t bypssetaddr                  : 1;  /**< Bypass SetAddress in Device Mode.
+	uint32_t bypssetaddr                  : 1;  /**< Bypass SetAddress in device mode.
                                                          Always set to 0. */
 	uint32_t u2rstecn                     : 1;  /**< If the SuperSpeed connection fails during POLL or LMP exchange, the device connects
                                                          at non-SuperSpeed mode. If this bit is set, then device attempts three more times to
@@ -2630,7 +2630,7 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          If you plan to enable hardware-based LPM (PORTPMSC[HLE] = 1), this feature cannot be used.
                                                          Turn off this feature by setting this bit to zero and use the
                                                          USBDRD()_UAHC_GFLADJ[GFLADJ_REFCLK_LPM_SEL] feature.
-                                                         If you set this bit to 1, the USBDRD()_UAHC_GUSB2PHYCFG() [U2_FREECLK_EXISTS] bit
+                                                         If you set this bit to 1, the USBDRD()_UAHC_GUSB2PHYCFG()[U2_FREECLK_EXISTS] bit
                                                          must be set to 0. */
 	uint32_t u1u2timerscale               : 1;  /**< Disable U1/U2 timer scaledown. If set to 1, along with SCALEDOWN = 0x1, disables the scale
                                                          down of U1/U2 inactive timer values.
@@ -3720,8 +3720,8 @@ typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
  *
  * For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until
  * the entire packet is completed. The register size corresponds to the number of configured USB
- * bus instances; for example, in the default configuration, there are 3 USB bus instances (1
- * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
+ * bus instances; for example, in the default configuration, there are three USB bus instances (one
+ * SuperSpeed, one high-speed, and one full-speed/low-speed).
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  */
@@ -4838,7 +4838,7 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
 	uint32_t lfpsfilt                     : 1;  /**< LFPS filter. When set to 1, filter LFPS reception with pipe3_RxValid in PHY power state
                                                          P0, ignore LFPS reception from the PHY unless both pipe3_Rxelecidle and pipe3_RxValid are
                                                          deasserted. */
-	uint32_t rxdet2polllfpsctrl           : 1;  /**< RX_DETECT to Polling.
+	uint32_t rxdet2polllfpsctrl           : 1;  /**< RX_DETECT to polling.
                                                          0 = Enables a 400 us delay to start polling LFPS after RX_DETECT. This allows VCM offset
                                                          to settle to a proper level.
                                                          1 = Disables the 400 us delay to start polling LFPS after RX_DETECT. */
diff --git a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
index 0dc82596930d..bf4ae50d3282 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-xcv-defs.h b/arch/mips/include/asm/octeon/cvmx-xcv-defs.h
index 933608030893..462068520004 100644
--- a/arch/mips/include/asm/octeon/cvmx-xcv-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-xcv-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -179,10 +179,10 @@ union cvmx_xcv_comp_ctl {
 	uint64_t cmp_nctl                     : 5;  /**< NCTL drive strength from the hardware compensation controller. */
 	uint64_t reserved_45_47               : 3;
 	uint64_t drv_pctl                     : 5;  /**< PCTL drive strength to use in bypass mode.
-                                                         Reset value of 13 is for 50 ohm termination. */
+                                                         Value of 11 is for 50 ohm termination. */
 	uint64_t reserved_37_39               : 3;
 	uint64_t drv_nctl                     : 5;  /**< NCTL drive strength to use in bypass mode.
-                                                         Reset value of 12 is for 50 ohm termination. */
+                                                         Value of 14 is for 50 ohm termination. */
 	uint64_t reserved_31_31               : 1;
 	uint64_t pctl_lock                    : 1;  /**< PCTL lock. */
 	uint64_t pctl_sat                     : 1;  /**< PCTL saturate. */
-- 
2.25.1

